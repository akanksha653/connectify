{
    "sourceFile": "src/app/rooms/[id]/page.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 30,
            "patches": [
                {
                    "date": 1758888488063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758888523818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n   text: string;\r\n }\r\n \r\n export default function RoomPage() {\r\n-  const { id } = useParams<{ id: string }>();\r\n+  const { id } = useParams() as { id: string };\r\n   const socketRef = useRef<Socket | null>(null);\r\n   const localVideoRef = useRef<HTMLVideoElement>(null);\r\n \r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n"
                },
                {
                    "date": 1758889481708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,9 @@\n import { useParams } from \"next/navigation\";\r\n import io, { Socket } from \"socket.io-client\";\r\n \r\n // ‚ö°Ô∏è Adjust to your signaling server endpoint\r\n-const SOCKET_URL =\r\n-  process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n+const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n \r\n interface RoomInfo {\r\n   id: string;\r\n   name: string;\r\n@@ -31,11 +30,14 @@\n   const [messages, setMessages] = useState<ChatMessage[]>([]);\r\n   const [input, setInput] = useState(\"\");\r\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n+  // Store peer connections in a ref to persist across renders\r\n+  const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n+\r\n   // üü¢ Join Room on mount\r\n   useEffect(() => {\r\n-    const socket = io(SOCKET_URL);\r\n+    const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n     socketRef.current = socket;\r\n \r\n     socket.emit(\"join-room\", { roomId: id });\r\n \r\n@@ -48,18 +50,16 @@\n     );\r\n \r\n     // ‚úÖ New user joins (start WebRTC)\r\n     socket.on(\"user-joined\", async ({ userId }: { userId: string }) => {\r\n-      if (!localVideoRef.current) return;\r\n+      if (!localVideoRef.current?.srcObject) return;\r\n \r\n-      const pc = createPeerConnection(socket, userId);\r\n+      const pc = createPeerConnection(userId);\r\n \r\n-      // Add local stream to connection\r\n-      if (localVideoRef.current.srcObject) {\r\n-        (localVideoRef.current.srcObject as MediaStream)\r\n-          .getTracks()\r\n-          .forEach((track) => pc.addTrack(track));\r\n-      }\r\n+      // Add local stream tracks\r\n+      (localVideoRef.current.srcObject as MediaStream)\r\n+        .getTracks()\r\n+        .forEach((track) => pc.addTrack(track));\r\n \r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n@@ -68,9 +68,10 @@\n     // ‚úÖ Handle incoming offer\r\n     socket.on(\r\n       \"room-offer\",\r\n       async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-        const pc = createPeerConnection(socket, from);\r\n+        const pc = createPeerConnection(from);\r\n+\r\n         await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n \r\n         if (localVideoRef.current?.srcObject) {\r\n           (localVideoRef.current.srcObject as MediaStream)\r\n@@ -87,39 +88,40 @@\n     // ‚úÖ Handle answer\r\n     socket.on(\r\n       \"room-answer\",\r\n       async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-        const pc = peerConnections[from];\r\n+        const pc = peerConnections.current[from];\r\n         if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n       }\r\n     );\r\n \r\n     // ‚úÖ Handle ICE candidates\r\n     socket.on(\r\n       \"room-ice\",\r\n       ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-        const pc = peerConnections[from];\r\n+        const pc = peerConnections.current[from];\r\n         if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n       }\r\n     );\r\n \r\n     // ‚úÖ User left\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n-      const pc = peerConnections[userId];\r\n+      const pc = peerConnections.current[userId];\r\n       if (pc) pc.close();\r\n-      delete peerConnections[userId];\r\n+      delete peerConnections.current[userId];\r\n+\r\n       setPeers((prev) => {\r\n         const updated = { ...prev };\r\n         delete updated[userId];\r\n         return updated;\r\n       });\r\n     });\r\n \r\n-    // üî¥ Leave room on unmount\r\n     return () => {\r\n       socket.emit(\"leave-room\", { roomId: id });\r\n       socket.disconnect();\r\n-      Object.values(peerConnections).forEach((pc) => pc.close());\r\n+      Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+      peerConnections.current = {};\r\n     };\r\n   }, [id]);\r\n \r\n   // üé• Start local camera\r\n@@ -129,11 +131,9 @@\n         const stream = await navigator.mediaDevices.getUserMedia({\r\n           video: true,\r\n           audio: true,\r\n         });\r\n-        if (localVideoRef.current) {\r\n-          localVideoRef.current.srcObject = stream;\r\n-        }\r\n+        if (localVideoRef.current) localVideoRef.current.srcObject = stream;\r\n       } catch (err) {\r\n         console.error(\"Camera error\", err);\r\n       }\r\n     })();\r\n@@ -149,29 +149,25 @@\n     setInput(\"\");\r\n   };\r\n \r\n   // ======= WebRTC Helper =======\r\n-  const peerConnections: { [peerId: string]: RTCPeerConnection } = {};\r\n-  const createPeerConnection = (socket: Socket, peerId: string) => {\r\n+  const createPeerConnection = (peerId: string) => {\r\n+    const socket = socketRef.current!;\r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n     pc.onicecandidate = (e) => {\r\n       if (e.candidate) {\r\n-        socket.emit(\"room-ice\", {\r\n-          roomId: id,\r\n-          candidate: e.candidate,\r\n-          to: peerId,\r\n-        });\r\n+        socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n       }\r\n     };\r\n \r\n     pc.ontrack = (e) => {\r\n       setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n     };\r\n \r\n-    peerConnections[peerId] = pc;\r\n+    peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n   return (\r\n"
                },
                {
                    "date": 1758889992103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import { useParams } from \"next/navigation\";\r\n import io, { Socket } from \"socket.io-client\";\r\n \r\n // ‚ö°Ô∏è Adjust to your signaling server endpoint\r\n-const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n+const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"https://connectify-z9gv.onrender.com/\";\r\n \r\n interface RoomInfo {\r\n   id: string;\r\n   name: string;\r\n"
                },
                {
                    "date": 1758893048299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,19 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n-import io, { Socket } from \"socket.io-client\";\r\n+import { io, Socket } from \"socket.io-client\";\r\n \r\n-// ‚ö°Ô∏è Adjust to your signaling server endpoint\r\n-const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"https://connectify-z9gv.onrender.com/\";\r\n+// ‚ö° Adjust to your signaling server endpoint\r\n+const SOCKET_URL =\r\n+  process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n \r\n interface RoomInfo {\r\n   id: string;\r\n   name: string;\r\n   topic: string;\r\n-  description: string;\r\n+  description?: string;\r\n   users: string[];\r\n }\r\n \r\n interface ChatMessage {\r\n@@ -30,86 +31,66 @@\n   const [messages, setMessages] = useState<ChatMessage[]>([]);\r\n   const [input, setInput] = useState(\"\");\r\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n-  // Store peer connections in a ref to persist across renders\r\n   const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n \r\n-  // üü¢ Join Room on mount\r\n+  // üü¢ Connect to room and handle WebRTC\r\n   useEffect(() => {\r\n     const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n     socketRef.current = socket;\r\n \r\n     socket.emit(\"join-room\", { roomId: id });\r\n \r\n-    // ‚úÖ Room info updates\r\n     socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n \r\n-    // ‚úÖ Chat messages\r\n     socket.on(\"room-message\", (msg: ChatMessage) =>\r\n       setMessages((prev) => [...prev, msg])\r\n     );\r\n \r\n-    // ‚úÖ New user joins (start WebRTC)\r\n     socket.on(\"user-joined\", async ({ userId }: { userId: string }) => {\r\n       if (!localVideoRef.current?.srcObject) return;\r\n \r\n       const pc = createPeerConnection(userId);\r\n+      (localVideoRef.current.srcObject as MediaStream).getTracks().forEach((t) => pc.addTrack(t));\r\n \r\n-      // Add local stream tracks\r\n-      (localVideoRef.current.srcObject as MediaStream)\r\n-        .getTracks()\r\n-        .forEach((track) => pc.addTrack(track));\r\n-\r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n     });\r\n \r\n-    // ‚úÖ Handle incoming offer\r\n     socket.on(\r\n       \"room-offer\",\r\n       async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n         const pc = createPeerConnection(from);\r\n-\r\n         await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-\r\n-        if (localVideoRef.current?.srcObject) {\r\n-          (localVideoRef.current.srcObject as MediaStream)\r\n-            .getTracks()\r\n-            .forEach((track) => pc.addTrack(track));\r\n-        }\r\n-\r\n+        (localVideoRef.current?.srcObject as MediaStream)?.getTracks().forEach((t) => pc.addTrack(t));\r\n         const answer = await pc.createAnswer();\r\n         await pc.setLocalDescription(answer);\r\n         socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n       }\r\n     );\r\n \r\n-    // ‚úÖ Handle answer\r\n     socket.on(\r\n       \"room-answer\",\r\n       async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n         const pc = peerConnections.current[from];\r\n         if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n       }\r\n     );\r\n \r\n-    // ‚úÖ Handle ICE candidates\r\n     socket.on(\r\n       \"room-ice\",\r\n       ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n         const pc = peerConnections.current[from];\r\n         if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n       }\r\n     );\r\n \r\n-    // ‚úÖ User left\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n       const pc = peerConnections.current[userId];\r\n       if (pc) pc.close();\r\n       delete peerConnections.current[userId];\r\n-\r\n       setPeers((prev) => {\r\n         const updated = { ...prev };\r\n         delete updated[userId];\r\n         return updated;\r\n@@ -123,9 +104,9 @@\n       peerConnections.current = {};\r\n     };\r\n   }, [id]);\r\n \r\n-  // üé• Start local camera\r\n+  // üé• Start local video/audio\r\n   useEffect(() => {\r\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({\r\n@@ -133,39 +114,30 @@\n           audio: true,\r\n         });\r\n         if (localVideoRef.current) localVideoRef.current.srcObject = stream;\r\n       } catch (err) {\r\n-        console.error(\"Camera error\", err);\r\n+        console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n   }, []);\r\n \r\n   // üí¨ Send chat message\r\n   const sendMessage = () => {\r\n     if (!input.trim() || !socketRef.current) return;\r\n-    socketRef.current.emit(\"room-message\", {\r\n-      roomId: id,\r\n-      text: input.trim(),\r\n-    });\r\n+    socketRef.current.emit(\"room-message\", { roomId: id, text: input.trim() });\r\n     setInput(\"\");\r\n   };\r\n \r\n-  // ======= WebRTC Helper =======\r\n+  // ===== WebRTC helper =====\r\n   const createPeerConnection = (peerId: string) => {\r\n     const socket = socketRef.current!;\r\n-    const pc = new RTCPeerConnection({\r\n-      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n-    });\r\n+    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n     pc.onicecandidate = (e) => {\r\n-      if (e.candidate) {\r\n-        socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n-      }\r\n+      if (e.candidate) socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n     };\r\n \r\n-    pc.ontrack = (e) => {\r\n-      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-    };\r\n+    pc.ontrack = (e) => setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n \r\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n@@ -176,11 +148,9 @@\n         <div className=\"bg-gray-100 p-4 rounded-lg shadow\">\r\n           <h1 className=\"text-2xl font-bold\">{room.name}</h1>\r\n           <p className=\"text-sm text-gray-700\">{room.topic}</p>\r\n           <p className=\"text-sm text-gray-500\">{room.description}</p>\r\n-          <p className=\"mt-2 text-sm font-medium\">\r\n-            Users in Room: {room.users.length}\r\n-          </p>\r\n+          <p className=\"mt-2 text-sm font-medium\">Users: {room.users.length}</p>\r\n         </div>\r\n       ) : (\r\n         <p>Loading room...</p>\r\n       )}\r\n@@ -215,12 +185,9 @@\n             value={input}\r\n             onChange={(e) => setInput(e.target.value)}\r\n             onKeyDown={(e) => e.key === \"Enter\" && sendMessage()}\r\n           />\r\n-          <button\r\n-            onClick={sendMessage}\r\n-            className=\"bg-blue-500 text-white px-4 py-2 rounded\"\r\n-          >\r\n+          <button onClick={sendMessage} className=\"bg-blue-500 text-white px-4 py-2 rounded\">\r\n             Send\r\n           </button>\r\n         </div>\r\n       </div>\r\n@@ -233,13 +200,6 @@\n   const ref = useRef<HTMLVideoElement>(null);\r\n   useEffect(() => {\r\n     if (ref.current) ref.current.srcObject = stream;\r\n   }, [stream]);\r\n-  return (\r\n-    <video\r\n-      ref={ref}\r\n-      autoPlay\r\n-      playsInline\r\n-      className=\"w-full h-48 bg-black rounded-lg\"\r\n-    />\r\n-  );\r\n+  return <video ref={ref} autoPlay playsInline className=\"w-full h-48 bg-black rounded-lg\" />;\r\n }\r\n"
                },
                {
                    "date": 1758893226832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,11 +3,10 @@\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n-// ‚ö° Adjust to your signaling server endpoint\r\n-const SOCKET_URL =\r\n-  process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n+// Signaling server URL\r\n+const SOCKET_URL = process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n \r\n interface RoomInfo {\r\n   id: string;\r\n   name: string;\r\n@@ -33,14 +32,14 @@\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n   const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n \r\n-  // üü¢ Connect to room and handle WebRTC\r\n+  // Connect to room & handle WebRTC\r\n   useEffect(() => {\r\n     const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n     socketRef.current = socket;\r\n \r\n-    socket.emit(\"join-room\", { roomId: id });\r\n+    socket.emit(\"join-room-dynamic\", { roomId: id });\r\n \r\n     socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n \r\n     socket.on(\"room-message\", (msg: ChatMessage) =>\r\n@@ -50,9 +49,11 @@\n     socket.on(\"user-joined\", async ({ userId }: { userId: string }) => {\r\n       if (!localVideoRef.current?.srcObject) return;\r\n \r\n       const pc = createPeerConnection(userId);\r\n-      (localVideoRef.current.srcObject as MediaStream).getTracks().forEach((t) => pc.addTrack(t));\r\n+      (localVideoRef.current.srcObject as MediaStream)\r\n+        .getTracks()\r\n+        .forEach((t) => pc.addTrack(t));\r\n \r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n@@ -62,9 +63,11 @@\n       \"room-offer\",\r\n       async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n         const pc = createPeerConnection(from);\r\n         await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        (localVideoRef.current?.srcObject as MediaStream)?.getTracks().forEach((t) => pc.addTrack(t));\r\n+        (localVideoRef.current?.srcObject as MediaStream)\r\n+          ?.getTracks()\r\n+          .forEach((t) => pc.addTrack(t));\r\n         const answer = await pc.createAnswer();\r\n         await pc.setLocalDescription(answer);\r\n         socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n       }\r\n@@ -104,9 +107,9 @@\n       peerConnections.current = {};\r\n     };\r\n   }, [id]);\r\n \r\n-  // üé• Start local video/audio\r\n+  // Start local camera & mic\r\n   useEffect(() => {\r\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({\r\n@@ -119,16 +122,16 @@\n       }\r\n     })();\r\n   }, []);\r\n \r\n-  // üí¨ Send chat message\r\n+  // Send chat message\r\n   const sendMessage = () => {\r\n     if (!input.trim() || !socketRef.current) return;\r\n     socketRef.current.emit(\"room-message\", { roomId: id, text: input.trim() });\r\n     setInput(\"\");\r\n   };\r\n \r\n-  // ===== WebRTC helper =====\r\n+  // Create peer connection\r\n   const createPeerConnection = (peerId: string) => {\r\n     const socket = socketRef.current!;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n@@ -194,9 +197,9 @@\n     </div>\r\n   );\r\n }\r\n \r\n-// ‚úÖ Component for remote streams\r\n+// Remote video component\r\n function RemoteVideo({ stream }: { stream: MediaStream }) {\r\n   const ref = useRef<HTMLVideoElement>(null);\r\n   useEffect(() => {\r\n     if (ref.current) ref.current.srcObject = stream;\r\n"
                },
                {
                    "date": 1758899353979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,11 @@\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n import { io, Socket } from \"socket.io-client\";\r\n+import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n+import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n+import ChatBox from \"../../../../features/RoomChat/components/ChatBox\";\r\n \r\n // Signaling server URL\r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n \r\n@@ -14,82 +17,86 @@\n   description?: string;\r\n   users: string[];\r\n }\r\n \r\n-interface ChatMessage {\r\n-  id: string;\r\n-  user: string;\r\n-  text: string;\r\n+interface UserInfo {\r\n+  name: string;\r\n+  age: string;\r\n+  gender: string;\r\n+  country: string;\r\n }\r\n \r\n export default function RoomPage() {\r\n   const { id } = useParams() as { id: string };\r\n   const socketRef = useRef<Socket | null>(null);\r\n-  const localVideoRef = useRef<HTMLVideoElement>(null);\r\n+  const localStreamRef = useRef<MediaStream | null>(null);\r\n \r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n-  const [messages, setMessages] = useState<ChatMessage[]>([]);\r\n-  const [input, setInput] = useState(\"\");\r\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n   const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n \r\n+  const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n+\r\n+  // Start local camera & mic\r\n+  useEffect(() => {\r\n+    (async () => {\r\n+      try {\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        localStreamRef.current = stream;\r\n+      } catch (err) {\r\n+        console.error(\"Camera error:\", err);\r\n+      }\r\n+    })();\r\n+  }, []);\r\n+\r\n   // Connect to room & handle WebRTC\r\n   useEffect(() => {\r\n+    if (!localStreamRef.current) return;\r\n+\r\n     const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n     socketRef.current = socket;\r\n \r\n-    socket.emit(\"join-room-dynamic\", { roomId: id });\r\n+    // Join room\r\n+    socket.emit(\"join-room-dynamic\", { roomId: id, userInfo });\r\n \r\n     socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n \r\n-    socket.on(\"room-message\", (msg: ChatMessage) =>\r\n-      setMessages((prev) => [...prev, msg])\r\n-    );\r\n-\r\n+    // When a new user joins, create a peer connection and send offer\r\n     socket.on(\"user-joined\", async ({ userId }: { userId: string }) => {\r\n-      if (!localVideoRef.current?.srcObject) return;\r\n-\r\n+      if (!localStreamRef.current) return;\r\n       const pc = createPeerConnection(userId);\r\n-      (localVideoRef.current.srcObject as MediaStream)\r\n-        .getTracks()\r\n-        .forEach((t) => pc.addTrack(t));\r\n+      localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n \r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n     });\r\n \r\n-    socket.on(\r\n-      \"room-offer\",\r\n-      async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-        const pc = createPeerConnection(from);\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        (localVideoRef.current?.srcObject as MediaStream)\r\n-          ?.getTracks()\r\n-          .forEach((t) => pc.addTrack(t));\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-      }\r\n-    );\r\n+    // Receive offer from another peer\r\n+    socket.on(\"room-offer\", async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n+      if (!localStreamRef.current) return;\r\n+      const pc = createPeerConnection(from);\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+    });\r\n \r\n-    socket.on(\r\n-      \"room-answer\",\r\n-      async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-        const pc = peerConnections.current[from];\r\n-        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-      }\r\n-    );\r\n+    // Receive answer\r\n+    socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    });\r\n \r\n-    socket.on(\r\n-      \"room-ice\",\r\n-      ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-        const pc = peerConnections.current[from];\r\n-        if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n-      }\r\n-    );\r\n+    // ICE candidates\r\n+    socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    });\r\n \r\n+    // Handle user leaving\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n       const pc = peerConnections.current[userId];\r\n       if (pc) pc.close();\r\n       delete peerConnections.current[userId];\r\n@@ -105,33 +112,11 @@\n       socket.disconnect();\r\n       Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n       peerConnections.current = {};\r\n     };\r\n-  }, [id]);\r\n+  }, [id, userInfo]);\r\n \r\n-  // Start local camera & mic\r\n-  useEffect(() => {\r\n-    (async () => {\r\n-      try {\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n-        if (localVideoRef.current) localVideoRef.current.srcObject = stream;\r\n-      } catch (err) {\r\n-        console.error(\"Camera error:\", err);\r\n-      }\r\n-    })();\r\n-  }, []);\r\n-\r\n-  // Send chat message\r\n-  const sendMessage = () => {\r\n-    if (!input.trim() || !socketRef.current) return;\r\n-    socketRef.current.emit(\"room-message\", { roomId: id, text: input.trim() });\r\n-    setInput(\"\");\r\n-  };\r\n-\r\n-  // Create peer connection\r\n+  // Create peer connection helper\r\n   const createPeerConnection = (peerId: string) => {\r\n     const socket = socketRef.current!;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n@@ -144,65 +129,31 @@\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n+  if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n+\r\n   return (\r\n     <div className=\"p-4 space-y-4\">\r\n-      {room ? (\r\n+      {/* Room info */}\r\n+      {room && (\r\n         <div className=\"bg-gray-100 p-4 rounded-lg shadow\">\r\n           <h1 className=\"text-2xl font-bold\">{room.name}</h1>\r\n           <p className=\"text-sm text-gray-700\">{room.topic}</p>\r\n           <p className=\"text-sm text-gray-500\">{room.description}</p>\r\n           <p className=\"mt-2 text-sm font-medium\">Users: {room.users.length}</p>\r\n         </div>\r\n-      ) : (\r\n-        <p>Loading room...</p>\r\n       )}\r\n \r\n       {/* Video Grid */}\r\n       <div className=\"grid grid-cols-2 md:grid-cols-3 gap-4\">\r\n-        <video\r\n-          ref={localVideoRef}\r\n-          autoPlay\r\n-          playsInline\r\n-          muted\r\n-          className=\"w-full h-48 bg-black rounded-lg\"\r\n-        />\r\n+        <LocalVideo stream={localStreamRef.current} label={userInfo.name} />\r\n         {Object.entries(peers).map(([peerId, stream]) => (\r\n-          <RemoteVideo key={peerId} stream={stream} />\r\n+          <RemoteVideo key={peerId} stream={stream} label={peerId} />\r\n         ))}\r\n       </div>\r\n \r\n-      {/* Chat */}\r\n-      <div className=\"bg-white p-4 rounded-lg shadow max-w-lg\">\r\n-        <div className=\"h-48 overflow-y-auto mb-2 border p-2\">\r\n-          {messages.map((m) => (\r\n-            <p key={m.id}>\r\n-              <strong>{m.user}:</strong> {m.text}\r\n-            </p>\r\n-          ))}\r\n-        </div>\r\n-        <div className=\"flex gap-2\">\r\n-          <input\r\n-            className=\"flex-1 border p-2 rounded\"\r\n-            placeholder=\"Type a message...\"\r\n-            value={input}\r\n-            onChange={(e) => setInput(e.target.value)}\r\n-            onKeyDown={(e) => e.key === \"Enter\" && sendMessage()}\r\n-          />\r\n-          <button onClick={sendMessage} className=\"bg-blue-500 text-white px-4 py-2 rounded\">\r\n-            Send\r\n-          </button>\r\n-        </div>\r\n-      </div>\r\n+      {/* Chat Box */}\r\n+      {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name} />}\r\n     </div>\r\n   );\r\n }\r\n-\r\n-// Remote video component\r\n-function RemoteVideo({ stream }: { stream: MediaStream }) {\r\n-  const ref = useRef<HTMLVideoElement>(null);\r\n-  useEffect(() => {\r\n-    if (ref.current) ref.current.srcObject = stream;\r\n-  }, [stream]);\r\n-  return <video ref={ref} autoPlay playsInline className=\"w-full h-48 bg-black rounded-lg\" />;\r\n-}\r\n"
                },
                {
                    "date": 1758899925089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,8 @@\n import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n import ChatBox from \"../../../../features/RoomChat/components/ChatBox\";\r\n \r\n-// Signaling server URL\r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n \r\n interface RoomInfo {\r\n   id: string;\r\n@@ -42,8 +41,10 @@\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         localStreamRef.current = stream;\r\n+        // Force re-render\r\n+        setPeers((prev) => ({ ...prev }));\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n@@ -60,46 +61,45 @@\n     socket.emit(\"join-room-dynamic\", { roomId: id, userInfo });\r\n \r\n     socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n \r\n-    // When a new user joins, create a peer connection and send offer\r\n-    socket.on(\"user-joined\", async ({ userId }: { userId: string }) => {\r\n+    socket.on(\"user-joined\", async ({ userId, userName }: { userId: string; userName: string }) => {\r\n       if (!localStreamRef.current) return;\r\n-      const pc = createPeerConnection(userId);\r\n+\r\n+      const pc = createPeerConnection(userId, userName);\r\n       localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n \r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n     });\r\n \r\n-    // Receive offer from another peer\r\n-    socket.on(\"room-offer\", async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-      if (!localStreamRef.current) return;\r\n-      const pc = createPeerConnection(from);\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n-      const answer = await pc.createAnswer();\r\n-      await pc.setLocalDescription(answer);\r\n-      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-    });\r\n+    socket.on(\r\n+      \"room-offer\",\r\n+      async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name: string }) => {\r\n+        if (!localStreamRef.current) return;\r\n+        const pc = createPeerConnection(from, name);\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+      }\r\n+    );\r\n \r\n-    // Receive answer\r\n     socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-      const pc = peerConnections.current[from];\r\n+      const pc = peerConnections.current[from]?.pc;\r\n       if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     });\r\n \r\n-    // ICE candidates\r\n     socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-      const pc = peerConnections.current[from];\r\n+      const pc = peerConnections.current[from]?.pc;\r\n       if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n     });\r\n \r\n-    // Handle user leaving\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n-      const pc = peerConnections.current[userId];\r\n-      if (pc) pc.close();\r\n+      const pcData = peerConnections.current[userId];\r\n+      if (pcData) pcData.pc.close();\r\n       delete peerConnections.current[userId];\r\n       setPeers((prev) => {\r\n         const updated = { ...prev };\r\n         delete updated[userId];\r\n@@ -109,30 +109,42 @@\n \r\n     return () => {\r\n       socket.emit(\"leave-room\", { roomId: id });\r\n       socket.disconnect();\r\n-      Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+      Object.values(peerConnections.current).forEach((p) => p.pc.close());\r\n       peerConnections.current = {};\r\n     };\r\n   }, [id, userInfo]);\r\n \r\n-  // Create peer connection helper\r\n-  const createPeerConnection = (peerId: string) => {\r\n+  const createPeerConnection = (peerId: string, name: string) => {\r\n     const socket = socketRef.current!;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n     pc.onicecandidate = (e) => {\r\n       if (e.candidate) socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n     };\r\n \r\n-    pc.ontrack = (e) => setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n+    pc.ontrack = (e) =>\r\n+      setPeers((prev) => ({\r\n+        ...prev,\r\n+        [peerId]: e.streams[0],\r\n+      }));\r\n \r\n-    peerConnections.current[peerId] = pc;\r\n+    peerConnections.current[peerId] = { pc, name };\r\n     return pc;\r\n   };\r\n \r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n+  const totalUsers = Object.keys(peers).length + 1;\r\n+  const getGridCols = () => {\r\n+    if (totalUsers <= 1) return \"grid-cols-1\";\r\n+    if (totalUsers === 2) return \"grid-cols-2\";\r\n+    if (totalUsers <= 4) return \"grid-cols-2 md:grid-cols-2\";\r\n+    if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n+    return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n+  };\r\n+\r\n   return (\r\n     <div className=\"p-4 space-y-4\">\r\n       {/* Room info */}\r\n       {room && (\r\n@@ -144,16 +156,17 @@\n         </div>\r\n       )}\r\n \r\n       {/* Video Grid */}\r\n-      <div className=\"grid grid-cols-2 md:grid-cols-3 gap-4\">\r\n+      <div className={`grid ${getGridCols()} gap-4`}>\r\n         <LocalVideo stream={localStreamRef.current} label={userInfo.name} />\r\n-        {Object.entries(peers).map(([peerId, stream]) => (\r\n-          <RemoteVideo key={peerId} stream={stream} label={peerId} />\r\n-        ))}\r\n+        {Object.entries(peers).map(([peerId, stream]) => {\r\n+          const name = peerConnections.current[peerId]?.name || peerId;\r\n+          return <RemoteVideo key={peerId} stream={stream} label={name} />;\r\n+        })}\r\n       </div>\r\n \r\n-      {/* Chat Box */}\r\n+      {/* Chat */}\r\n       {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name} />}\r\n     </div>\r\n   );\r\n }\r\n"
                },
                {
                    "date": 1758900042103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,10 @@\n \r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n-  const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n+  // Store peer connections with name for labels\r\n+  const peerConnections = useRef<{ [peerId: string]: { pc: RTCPeerConnection; name: string } }>({});\r\n \r\n   const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n \r\n   // Start local camera & mic\r\n@@ -41,10 +42,9 @@\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         localStreamRef.current = stream;\r\n-        // Force re-render\r\n-        setPeers((prev) => ({ ...prev }));\r\n+        setPeers((prev) => ({ ...prev })); // Force re-render\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n@@ -56,18 +56,18 @@\n \r\n     const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n     socketRef.current = socket;\r\n \r\n-    // Join room\r\n+    // Join room with user info\r\n     socket.emit(\"join-room-dynamic\", { roomId: id, userInfo });\r\n \r\n     socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n \r\n     socket.on(\"user-joined\", async ({ userId, userName }: { userId: string; userName: string }) => {\r\n       if (!localStreamRef.current) return;\r\n \r\n       const pc = createPeerConnection(userId, userName);\r\n-      localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n+      localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n \r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n@@ -76,11 +76,13 @@\n     socket.on(\r\n       \"room-offer\",\r\n       async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name: string }) => {\r\n         if (!localStreamRef.current) return;\r\n+\r\n         const pc = createPeerConnection(from, name);\r\n         await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        localStreamRef.current.getTracks().forEach((t) => pc.addTrack(t));\r\n+        localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n+\r\n         const answer = await pc.createAnswer();\r\n         await pc.setLocalDescription(answer);\r\n         socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n       }\r\n@@ -134,39 +136,42 @@\n   };\r\n \r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n+  // Responsive grid columns\r\n   const totalUsers = Object.keys(peers).length + 1;\r\n   const getGridCols = () => {\r\n-    if (totalUsers <= 1) return \"grid-cols-1\";\r\n+    if (totalUsers === 1) return \"grid-cols-1\";\r\n     if (totalUsers === 2) return \"grid-cols-2\";\r\n     if (totalUsers <= 4) return \"grid-cols-2 md:grid-cols-2\";\r\n     if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n     return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n   };\r\n \r\n   return (\r\n-    <div className=\"p-4 space-y-4\">\r\n-      {/* Room info */}\r\n-      {room && (\r\n-        <div className=\"bg-gray-100 p-4 rounded-lg shadow\">\r\n-          <h1 className=\"text-2xl font-bold\">{room.name}</h1>\r\n-          <p className=\"text-sm text-gray-700\">{room.topic}</p>\r\n-          <p className=\"text-sm text-gray-500\">{room.description}</p>\r\n-          <p className=\"mt-2 text-sm font-medium\">Users: {room.users.length}</p>\r\n-        </div>\r\n-      )}\r\n-\r\n+    <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n       {/* Video Grid */}\r\n-      <div className={`grid ${getGridCols()} gap-4`}>\r\n+      <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n         <LocalVideo stream={localStreamRef.current} label={userInfo.name} />\r\n         {Object.entries(peers).map(([peerId, stream]) => {\r\n           const name = peerConnections.current[peerId]?.name || peerId;\r\n           return <RemoteVideo key={peerId} stream={stream} label={name} />;\r\n         })}\r\n       </div>\r\n \r\n       {/* Chat */}\r\n-      {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name} />}\r\n+      <div className=\"md:w-80 flex-shrink-0\">\r\n+        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name} />}\r\n+      </div>\r\n+\r\n+      {/* Room Info */}\r\n+      {room && (\r\n+        <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n+          <h2 className=\"text-lg font-bold\">{room.name}</h2>\r\n+          <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n+          <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n+          <p className=\"mt-2 text-sm font-medium\">Users: {room.users.length}</p>\r\n+        </div>\r\n+      )}\r\n     </div>\r\n   );\r\n }\r\n"
                },
                {
                    "date": 1758902632049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,14 +8,19 @@\n import ChatBox from \"../../../../features/RoomChat/components/ChatBox\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n \r\n+interface RoomUser {\r\n+  id: string;\r\n+  userInfo: UserInfo;\r\n+}\r\n+\r\n interface RoomInfo {\r\n   id: string;\r\n   name: string;\r\n   topic: string;\r\n   description?: string;\r\n-  users: string[];\r\n+  users: RoomUser[];\r\n }\r\n \r\n interface UserInfo {\r\n   name: string;\r\n@@ -31,9 +36,8 @@\n \r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n-  // Store peer connections with name for labels\r\n   const peerConnections = useRef<{ [peerId: string]: { pc: RTCPeerConnection; name: string } }>({});\r\n \r\n   const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n \r\n@@ -42,9 +46,9 @@\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         localStreamRef.current = stream;\r\n-        setPeers((prev) => ({ ...prev })); // Force re-render\r\n+        setPeers((prev) => ({ ...prev }));\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n@@ -59,19 +63,19 @@\n \r\n     // Join room with user info\r\n     socket.emit(\"join-room-dynamic\", { roomId: id, userInfo });\r\n \r\n-    socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n+    // Update room info\r\n+    socket.on(\"room-update\", async (data: RoomInfo) => {\r\n+      setRoom(data);\r\n \r\n-    socket.on(\"user-joined\", async ({ userId, userName }: { userId: string; userName: string }) => {\r\n-      if (!localStreamRef.current) return;\r\n-\r\n-      const pc = createPeerConnection(userId, userName);\r\n-      localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n-\r\n-      const offer = await pc.createOffer();\r\n-      await pc.setLocalDescription(offer);\r\n-      socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n+      // Create peer connections for new users\r\n+      for (const user of data.users) {\r\n+        if (user.id === socket.id) continue;\r\n+        if (!peerConnections.current[user.id]) {\r\n+          await createOfferToPeer(user.id, user.userInfo.name);\r\n+        }\r\n+      }\r\n     });\r\n \r\n     socket.on(\r\n       \"room-offer\",\r\n@@ -134,11 +138,22 @@\n     peerConnections.current[peerId] = { pc, name };\r\n     return pc;\r\n   };\r\n \r\n+  const createOfferToPeer = async (peerId: string, name: string) => {\r\n+    if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n+\r\n+    const pc = createPeerConnection(peerId, name);\r\n+    localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n+\r\n+    const offer = await pc.createOffer();\r\n+    await pc.setLocalDescription(offer);\r\n+\r\n+    socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n+  };\r\n+\r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n-  // Responsive grid columns\r\n   const totalUsers = Object.keys(peers).length + 1;\r\n   const getGridCols = () => {\r\n     if (totalUsers === 1) return \"grid-cols-1\";\r\n     if (totalUsers === 2) return \"grid-cols-2\";\r\n@@ -148,23 +163,20 @@\n   };\r\n \r\n   return (\r\n     <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n-      {/* Video Grid */}\r\n       <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n         <LocalVideo stream={localStreamRef.current} label={userInfo.name} />\r\n         {Object.entries(peers).map(([peerId, stream]) => {\r\n           const name = peerConnections.current[peerId]?.name || peerId;\r\n           return <RemoteVideo key={peerId} stream={stream} label={name} />;\r\n         })}\r\n       </div>\r\n \r\n-      {/* Chat */}\r\n       <div className=\"md:w-80 flex-shrink-0\">\r\n         {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name} />}\r\n       </div>\r\n \r\n-      {/* Room Info */}\r\n       {room && (\r\n         <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n           <h2 className=\"text-lg font-bold\">{room.name}</h2>\r\n           <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n"
                },
                {
                    "date": 1758906386073,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,15 @@\n import ChatBox from \"../../../../features/RoomChat/components/ChatBox\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n \r\n+interface UserInfo {\r\n+  name: string;\r\n+  age: string;\r\n+  gender: string;\r\n+  country: string;\r\n+}\r\n+\r\n interface RoomUser {\r\n   id: string;\r\n   userInfo: UserInfo;\r\n }\r\n@@ -21,15 +28,8 @@\n   description?: string;\r\n   users: RoomUser[];\r\n }\r\n \r\n-interface UserInfo {\r\n-  name: string;\r\n-  age: string;\r\n-  gender: string;\r\n-  country: string;\r\n-}\r\n-\r\n export default function RoomPage() {\r\n   const { id } = useParams() as { id: string };\r\n   const socketRef = useRef<Socket | null>(null);\r\n   const localStreamRef = useRef<MediaStream | null>(null);\r\n@@ -46,38 +46,39 @@\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         localStreamRef.current = stream;\r\n-        setPeers((prev) => ({ ...prev }));\r\n+        setPeers((prev) => ({ ...prev })); // force re-render\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n   }, []);\r\n \r\n-  // Connect to room & handle WebRTC\r\n+  // Connect to socket & handle WebRTC\r\n   useEffect(() => {\r\n     if (!localStreamRef.current) return;\r\n \r\n     const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n     socketRef.current = socket;\r\n \r\n-    // Join room with user info\r\n+    // Join room\r\n     socket.emit(\"join-room-dynamic\", { roomId: id, userInfo });\r\n \r\n-    // Update room info\r\n+    // Room update\r\n     socket.on(\"room-update\", async (data: RoomInfo) => {\r\n+      if (!data?.users) return;\r\n       setRoom(data);\r\n \r\n-      // Create peer connections for new users\r\n       for (const user of data.users) {\r\n         if (user.id === socket.id) continue;\r\n         if (!peerConnections.current[user.id]) {\r\n           await createOfferToPeer(user.id, user.userInfo.name);\r\n         }\r\n       }\r\n     });\r\n \r\n+    // Offer received\r\n     socket.on(\r\n       \"room-offer\",\r\n       async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name: string }) => {\r\n         if (!localStreamRef.current) return;\r\n@@ -91,18 +92,21 @@\n         socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n       }\r\n     );\r\n \r\n+    // Answer received\r\n     socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n       const pc = peerConnections.current[from]?.pc;\r\n       if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     });\r\n \r\n+    // ICE candidate\r\n     socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n       const pc = peerConnections.current[from]?.pc;\r\n-      if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+      if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n     });\r\n \r\n+    // User left\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n       const pcData = peerConnections.current[userId];\r\n       if (pcData) pcData.pc.close();\r\n       delete peerConnections.current[userId];\r\n@@ -121,20 +125,21 @@\n     };\r\n   }, [id, userInfo]);\r\n \r\n   const createPeerConnection = (peerId: string, name: string) => {\r\n+    if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n+\r\n     const socket = socketRef.current!;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n     pc.onicecandidate = (e) => {\r\n       if (e.candidate) socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n     };\r\n \r\n-    pc.ontrack = (e) =>\r\n-      setPeers((prev) => ({\r\n-        ...prev,\r\n-        [peerId]: e.streams[0],\r\n-      }));\r\n+    pc.ontrack = (e) => {\r\n+      if (!e.streams[0]) return;\r\n+      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n+    };\r\n \r\n     peerConnections.current[peerId] = { pc, name };\r\n     return pc;\r\n   };\r\n@@ -164,22 +169,23 @@\n \r\n   return (\r\n     <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n       <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n-        <LocalVideo stream={localStreamRef.current} label={userInfo.name} />\r\n+        <LocalVideo stream={localStreamRef.current} label={userInfo.name || \"You\"} />\r\n         {Object.entries(peers).map(([peerId, stream]) => {\r\n-          const name = peerConnections.current[peerId]?.name || peerId;\r\n+          const name = peerConnections.current[peerId]?.name || \"Stranger\";\r\n+          if (!stream) return null;\r\n           return <RemoteVideo key={peerId} stream={stream} label={name} />;\r\n         })}\r\n       </div>\r\n \r\n       <div className=\"md:w-80 flex-shrink-0\">\r\n-        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name} />}\r\n+        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name || \"You\"} />}\r\n       </div>\r\n \r\n       {room && (\r\n         <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n-          <h2 className=\"text-lg font-bold\">{room.name}</h2>\r\n+          <h2 className=\"text-lg font-bold\">{room.name || \"Room\"}</h2>\r\n           <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n           <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n           <p className=\"mt-2 text-sm font-medium\">Users: {room.users.length}</p>\r\n         </div>\r\n"
                },
                {
                    "date": 1760156505117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,24 +1,22 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n-import { io, Socket } from \"socket.io-client\";\r\n import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n import ChatBox from \"../../../../features/RoomChat/components/ChatBox\";\r\n+import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n \r\n-const SOCKET_URL = process.env.NEXT_PUBLIC_SIGNALING_URL || \"http://localhost:3001\";\r\n-\r\n interface UserInfo {\r\n   name: string;\r\n   age: string;\r\n   gender: string;\r\n   country: string;\r\n }\r\n \r\n interface RoomUser {\r\n-  id: string;\r\n+  socketId: string;\r\n   userInfo: UserInfo;\r\n }\r\n \r\n interface RoomInfo {\r\n@@ -30,78 +28,64 @@\n }\r\n \r\n export default function RoomPage() {\r\n   const { id } = useParams() as { id: string };\r\n-  const socketRef = useRef<Socket | null>(null);\r\n+  const socketRef = useRef<any>(null);\r\n   const localStreamRef = useRef<MediaStream | null>(null);\r\n-\r\n+  const peerConnections = useRef<{ [peerId: string]: { pc: RTCPeerConnection; name: string } }>({});\r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n   const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n \r\n-  const peerConnections = useRef<{ [peerId: string]: { pc: RTCPeerConnection; name: string } }>({});\r\n-\r\n   const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n \r\n-  // Start local camera & mic\r\n+  // Start camera & mic\r\n   useEffect(() => {\r\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         localStreamRef.current = stream;\r\n-        setPeers((prev) => ({ ...prev })); // force re-render\r\n+        setPeers((prev) => ({ ...prev })); // force render\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n   }, []);\r\n \r\n-  // Connect to socket & handle WebRTC\r\n+  // Connect to /rooms socket and handle WebRTC\r\n   useEffect(() => {\r\n     if (!localStreamRef.current) return;\r\n \r\n-    const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n+    const socket = connectRoomSocket();\r\n     socketRef.current = socket;\r\n \r\n     // Join room\r\n-    socket.emit(\"join-room-dynamic\", { roomId: id, userInfo });\r\n+    socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n \r\n     // Room update\r\n-    socket.on(\"room-update\", async (data: RoomInfo) => {\r\n-      if (!data?.users) return;\r\n-      setRoom(data);\r\n+    socket.on(\"user-joined\", (user: RoomUser) => {\r\n+      if (user.socketId === socket.id) return;\r\n+      createOfferToPeer(user.socketId, user.userInfo.name);\r\n+    });\r\n \r\n-      for (const user of data.users) {\r\n-        if (user.id === socket.id) continue;\r\n-        if (!peerConnections.current[user.id]) {\r\n-          await createOfferToPeer(user.id, user.userInfo.name);\r\n-        }\r\n-      }\r\n+    // Receive offer\r\n+    socket.on(\"room-offer\", async ({ from, offer, name }) => {\r\n+      if (!localStreamRef.current) return;\r\n+      const pc = createPeerConnection(from, name);\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n     });\r\n \r\n-    // Offer received\r\n-    socket.on(\r\n-      \"room-offer\",\r\n-      async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name: string }) => {\r\n-        if (!localStreamRef.current) return;\r\n-\r\n-        const pc = createPeerConnection(from, name);\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n-\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-      }\r\n-    );\r\n-\r\n-    // Answer received\r\n-    socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+    // Receive answer\r\n+    socket.on(\"room-answer\", async ({ from, answer }) => {\r\n       const pc = peerConnections.current[from]?.pc;\r\n       if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     });\r\n \r\n-    // ICE candidate\r\n-    socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+    // Receive ICE\r\n+    socket.on(\"room-ice\", ({ from, candidate }) => {\r\n       const pc = peerConnections.current[from]?.pc;\r\n       if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n     });\r\n \r\n@@ -117,19 +101,19 @@\n       });\r\n     });\r\n \r\n     return () => {\r\n-      socket.emit(\"leave-room\", { roomId: id });\r\n-      socket.disconnect();\r\n+      socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n       Object.values(peerConnections.current).forEach((p) => p.pc.close());\r\n       peerConnections.current = {};\r\n+      disconnectRoomSocket();\r\n     };\r\n   }, [id, userInfo]);\r\n \r\n   const createPeerConnection = (peerId: string, name: string) => {\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n \r\n-    const socket = socketRef.current!;\r\n+    const socket = socketRef.current;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n     pc.onicecandidate = (e) => {\r\n       if (e.candidate) socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n"
                },
                {
                    "date": 1760187049806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n-import ChatBox from \"../../../../features/RoomChat/components/ChatBox\";\r\n+import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n \r\n interface UserInfo {\r\n   name: string;\r\n"
                },
                {
                    "date": 1760187436371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,15 +4,18 @@\n import { useParams } from \"next/navigation\";\r\n import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n-import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n+import {\r\n+  connectRoomSocket,\r\n+  disconnectRoomSocket,\r\n+} from \"../../../../features/RoomChat/services/roomSocketService\";\r\n \r\n interface UserInfo {\r\n-  name: string;\r\n-  age: string;\r\n-  gender: string;\r\n-  country: string;\r\n+  name?: string;\r\n+  age?: string;\r\n+  gender?: string;\r\n+  country?: string;\r\n }\r\n \r\n interface RoomUser {\r\n   socketId: string;\r\n@@ -30,120 +33,292 @@\n export default function RoomPage() {\r\n   const { id } = useParams() as { id: string };\r\n   const socketRef = useRef<any>(null);\r\n   const localStreamRef = useRef<MediaStream | null>(null);\r\n-  const peerConnections = useRef<{ [peerId: string]: { pc: RTCPeerConnection; name: string } }>({});\r\n+\r\n+  // map peerId -> { pc, name }\r\n+  const peerConnections = useRef<Record<string, { pc: RTCPeerConnection; name?: string }>>({});\r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n-  const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n+  const [peers, setPeers] = useState<Record<string, MediaStream>>({});\r\n \r\n+  // Get user-info from localStorage (your code stores it there)\r\n   const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n \r\n   // Start camera & mic\r\n   useEffect(() => {\r\n+    let mounted = true;\r\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        if (!mounted) {\r\n+          // safety: if unmounted while awaiting\r\n+          stream.getTracks().forEach((t) => t.stop());\r\n+          return;\r\n+        }\r\n         localStreamRef.current = stream;\r\n-        setPeers((prev) => ({ ...prev })); // force render\r\n+        // force a render so local video appears\r\n+        setPeers((p) => ({ ...p }));\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n+    return () => {\r\n+      mounted = false;\r\n+    };\r\n   }, []);\r\n \r\n-  // Connect to /rooms socket and handle WebRTC\r\n+  // Helper: create RTCPeerConnection for a peerId\r\n+  const createPeerConnection = (peerId: string, name?: string) => {\r\n+    if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n+\r\n+    const socket = socketRef.current;\r\n+    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n+\r\n+    // Attach local tracks (if available)\r\n+    if (localStreamRef.current) {\r\n+      try {\r\n+        localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n+      } catch (e) {\r\n+        console.warn(\"Failed to add local tracks:\", e);\r\n+      }\r\n+    }\r\n+\r\n+    pc.onicecandidate = (e) => {\r\n+      if (e.candidate && socket) {\r\n+        // send candidate to the target peer\r\n+        socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n+      }\r\n+    };\r\n+\r\n+    pc.ontrack = (e) => {\r\n+      // set remote stream for rendering\r\n+      if (!e.streams || !e.streams[0]) return;\r\n+      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n+    };\r\n+\r\n+    pc.onconnectionstatechange = () => {\r\n+      // debug\r\n+      console.log(`Peer ${peerId} connectionState:`, pc.connectionState);\r\n+      if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\" || pc.connectionState === \"closed\") {\r\n+        // cleanup\r\n+        removePeer(peerId);\r\n+      }\r\n+    };\r\n+\r\n+    peerConnections.current[peerId] = { pc, name };\r\n+    return pc;\r\n+  };\r\n+\r\n+  // Remove peer and its stream\r\n+  const removePeer = (peerId: string) => {\r\n+    const data = peerConnections.current[peerId];\r\n+    if (data?.pc) {\r\n+      try {\r\n+        data.pc.close();\r\n+      } catch (e) {\r\n+        console.warn(\"Error closing pc:\", e);\r\n+      }\r\n+    }\r\n+    delete peerConnections.current[peerId];\r\n+    setPeers((prev) => {\r\n+      const copy = { ...prev };\r\n+      delete copy[peerId];\r\n+      return copy;\r\n+    });\r\n+  };\r\n+\r\n+  // Create an offer to a given peerId\r\n+  const createOfferToPeer = async (peerId: string, name?: string) => {\r\n+    if (!localStreamRef.current) {\r\n+      console.warn(\"No local stream available for offer\");\r\n+      return;\r\n+    }\r\n+    // don't recreate if exists\r\n+    if (peerConnections.current[peerId]) return;\r\n+\r\n+    const pc = createPeerConnection(peerId, name);\r\n+    try {\r\n+      // ensure local tracks attached\r\n+      localStreamRef.current.getTracks().forEach((t) => {\r\n+        try {\r\n+          pc.addTrack(t, localStreamRef.current!);\r\n+        } catch (err) {\r\n+          // adding same track twice can throw ‚Äî ignore\r\n+        }\r\n+      });\r\n+\r\n+      const offer = await pc.createOffer();\r\n+      await pc.setLocalDescription(offer);\r\n+      socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n+      console.log(\"Sent offer to\", peerId);\r\n+    } catch (err) {\r\n+      console.error(\"Error creating offer:\", err);\r\n+    }\r\n+  };\r\n+\r\n+  // Clean up all peer connections\r\n+  const cleanupAllPeers = () => {\r\n+    Object.keys(peerConnections.current).forEach((pid) => {\r\n+      try {\r\n+        peerConnections.current[pid].pc.close();\r\n+      } catch (e) {\r\n+        // ignore\r\n+      }\r\n+      delete peerConnections.current[pid];\r\n+    });\r\n+    setPeers({});\r\n+  };\r\n+\r\n+  // Connect to /rooms namespace, join room, and wire signaling listeners\r\n   useEffect(() => {\r\n+    // wait for local stream to be ready\r\n     if (!localStreamRef.current) return;\r\n \r\n     const socket = connectRoomSocket();\r\n     socketRef.current = socket;\r\n \r\n-    // Join room\r\n-    socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n+    // Ask server for rooms list (so we can find room metadata/users)\r\n+    socket.emit(\"list-rooms\");\r\n \r\n-    // Room update\r\n-    socket.on(\"user-joined\", (user: RoomUser) => {\r\n-      if (user.socketId === socket.id) return;\r\n-      createOfferToPeer(user.socketId, user.userInfo.name);\r\n+    // When server sends the list of rooms, extract this room's info (if present)\r\n+    socket.on(\"rooms\", (roomsArray: RoomInfo[]) => {\r\n+      try {\r\n+        const found = (roomsArray || []).find((r: any) => r.id === id);\r\n+        if (found) {\r\n+          // server's room object may or may not include users; normalize\r\n+          const users = (found.users || []).map((u: any) =>\r\n+            typeof u === \"string\" ? { socketId: u, userInfo: {} } : u\r\n+          );\r\n+          setRoom({ ...found, users });\r\n+        }\r\n+      } catch (e) {\r\n+        console.warn(\"Error parsing rooms list\", e);\r\n+      }\r\n     });\r\n \r\n-    // Receive offer\r\n-    socket.on(\"room-offer\", async ({ from, offer, name }) => {\r\n-      if (!localStreamRef.current) return;\r\n-      const pc = createPeerConnection(from, name);\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n-      const answer = await pc.createAnswer();\r\n-      await pc.setLocalDescription(answer);\r\n-      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+    // IMPORTANT: request user list for this room if your server supports it\r\n+    // If your server emits \"room-users\" with [{ socketId, userInfo }], we'll use it.\r\n+    socket.on(\"room-users\", (users: RoomUser[]) => {\r\n+      // Replace room state and create offers to existing users\r\n+      setRoom((prev) => ({ ...(prev || {}), users: users || [] } as RoomInfo));\r\n+\r\n+      // Create offers to each existing user (except ourselves)\r\n+      users.forEach((u) => {\r\n+        if (u.socketId && u.socketId !== socket.id) {\r\n+          // wait a moment to ensure we have local tracks\r\n+          setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 50);\r\n+        }\r\n+      });\r\n     });\r\n \r\n-    // Receive answer\r\n-    socket.on(\"room-answer\", async ({ from, answer }) => {\r\n-      const pc = peerConnections.current[from]?.pc;\r\n-      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    // When someone joins the room, server should emit 'user-joined'.\r\n+    // Preferred: server includes socketId in payload. If server only sends userInfo (no socketId),\r\n+    // you should update the server to emit full user object including socketId.\r\n+    socket.on(\"user-joined\", (payload: any) => {\r\n+      // payload ideally: { socketId, userInfo } OR userInfo only\r\n+      console.log(\"user-joined payload:\", payload);\r\n+      const hasSocketId = payload && payload.socketId;\r\n+      if (hasSocketId) {\r\n+        const u: RoomUser = payload;\r\n+        setRoom((prev) => {\r\n+          const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n+          copy.users = copy.users ? [...copy.users.filter((x) => x.socketId !== u.socketId), u] : [u];\r\n+          return copy;\r\n+        });\r\n+\r\n+        // create offer to the newcomer\r\n+        if (payload.socketId !== socket.id) {\r\n+          setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 50);\r\n+        }\r\n+      } else {\r\n+        // No socketId present ‚Äî fall back: ask server to send room-users list (server should do this)\r\n+        console.warn(\"user-joined did not include socketId. Please update server to emit socketId or emit 'room-users'.\");\r\n+        socket.emit(\"list-rooms\");\r\n+      }\r\n     });\r\n \r\n-    // Receive ICE\r\n-    socket.on(\"room-ice\", ({ from, candidate }) => {\r\n-      const pc = peerConnections.current[from]?.pc;\r\n-      if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    // Handle offers from peers\r\n+    socket.on(\"room-offer\", async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name?: string }) => {\r\n+      try {\r\n+        if (!localStreamRef.current) {\r\n+          console.warn(\"Got offer but localStream not ready\");\r\n+          return;\r\n+        }\r\n+        console.log(\"Received offer from\", from);\r\n+        const pc = createPeerConnection(from, name);\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        // ensure our local tracks added\r\n+        localStreamRef.current.getTracks().forEach((t) => {\r\n+          try {\r\n+            pc.addTrack(t, localStreamRef.current!);\r\n+          } catch (e) {}\r\n+        });\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+      } catch (err) {\r\n+        console.error(\"Error handling offer:\", err);\r\n+      }\r\n     });\r\n \r\n-    // User left\r\n+    // Handle answers from peers\r\n+    socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+      try {\r\n+        const pc = peerConnections.current[from]?.pc;\r\n+        if (pc) {\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          console.log(\"Set remote description (answer) from\", from);\r\n+        } else {\r\n+          console.warn(\"Received answer but no pc for\", from);\r\n+        }\r\n+      } catch (err) {\r\n+        console.error(\"Error applying answer:\", err);\r\n+      }\r\n+    });\r\n+\r\n+    // Handle ICE candidates from peers\r\n+    socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+      try {\r\n+        const pc = peerConnections.current[from]?.pc;\r\n+        if (pc && candidate) {\r\n+          pc.addIceCandidate(new RTCIceCandidate(candidate)).catch((err) => {\r\n+            console.warn(\"addIceCandidate error:\", err);\r\n+          });\r\n+        } else {\r\n+          console.warn(\"No pc to add ICE for\", from);\r\n+        }\r\n+      } catch (err) {\r\n+        console.error(\"Error handling ICE:\", err);\r\n+      }\r\n+    });\r\n+\r\n+    // When a user leaves, server should emit 'user-left' with { userId: socketId }\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n-      const pcData = peerConnections.current[userId];\r\n-      if (pcData) pcData.pc.close();\r\n-      delete peerConnections.current[userId];\r\n-      setPeers((prev) => {\r\n-        const updated = { ...prev };\r\n-        delete updated[userId];\r\n-        return updated;\r\n+      removePeer(userId);\r\n+      setRoom((prev) => {\r\n+        if (!prev) return prev;\r\n+        return { ...prev, users: prev.users.filter((u) => u.socketId !== userId) };\r\n       });\r\n     });\r\n \r\n+    // Finally, emit join - telling server we joined (server should respond with room-users or user-joined)\r\n+    socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n+\r\n+    // cleanup on unmount\r\n     return () => {\r\n-      socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n-      Object.values(peerConnections.current).forEach((p) => p.pc.close());\r\n-      peerConnections.current = {};\r\n+      try {\r\n+        socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n+      } catch (e) {}\r\n+      cleanupAllPeers();\r\n       disconnectRoomSocket();\r\n+      socketRef.current = null;\r\n     };\r\n   }, [id, userInfo]);\r\n \r\n-  const createPeerConnection = (peerId: string, name: string) => {\r\n-    if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n-\r\n-    const socket = socketRef.current;\r\n-    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n-\r\n-    pc.onicecandidate = (e) => {\r\n-      if (e.candidate) socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n-    };\r\n-\r\n-    pc.ontrack = (e) => {\r\n-      if (!e.streams[0]) return;\r\n-      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-    };\r\n-\r\n-    peerConnections.current[peerId] = { pc, name };\r\n-    return pc;\r\n-  };\r\n-\r\n-  const createOfferToPeer = async (peerId: string, name: string) => {\r\n-    if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n-\r\n-    const pc = createPeerConnection(peerId, name);\r\n-    localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track));\r\n-\r\n-    const offer = await pc.createOffer();\r\n-    await pc.setLocalDescription(offer);\r\n-\r\n-    socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n-  };\r\n-\r\n+  // If no local stream yet\r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n-  const totalUsers = Object.keys(peers).length + 1;\r\n+  const totalUsers = (room?.users?.length || Object.keys(peers).length + 1) || 1;\r\n   const getGridCols = () => {\r\n     if (totalUsers === 1) return \"grid-cols-1\";\r\n     if (totalUsers === 2) return \"grid-cols-2\";\r\n     if (totalUsers <= 4) return \"grid-cols-2 md:grid-cols-2\";\r\n@@ -153,26 +328,37 @@\n \r\n   return (\r\n     <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n       <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n-        <LocalVideo stream={localStreamRef.current} label={userInfo.name || \"You\"} />\r\n+        <LocalVideo stream={localStreamRef.current} label={userInfo?.name || \"You\"} />\r\n         {Object.entries(peers).map(([peerId, stream]) => {\r\n           const name = peerConnections.current[peerId]?.name || \"Stranger\";\r\n           if (!stream) return null;\r\n           return <RemoteVideo key={peerId} stream={stream} label={name} />;\r\n         })}\r\n       </div>\r\n \r\n       <div className=\"md:w-80 flex-shrink-0\">\r\n-        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo.name || \"You\"} />}\r\n+        {socketRef.current && (\r\n+          <ChatBox\r\n+            socket={socketRef.current}\r\n+            roomId={id}\r\n+            userName={userInfo?.name || \"You\"}\r\n+          />\r\n+        )}\r\n       </div>\r\n \r\n       {room && (\r\n         <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n           <h2 className=\"text-lg font-bold\">{room.name || \"Room\"}</h2>\r\n           <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n-          <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n-          <p className=\"mt-2 text-sm font-medium\">Users: {room.users.length}</p>\r\n+          {room.description && (\r\n+            <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n+          )}\r\n+          <p className=\"mt-2 text-sm font-medium\">Users: {room.users?.length ?? Object.keys(peers).length + 1}</p>\r\n+          <div className=\"mt-3 text-xs text-neutral-600\">\r\n+            <div>Tip: Mute/unmute and other controls are available in the top-right of the video tiles.</div>\r\n+          </div>\r\n         </div>\r\n       )}\r\n     </div>\r\n   );\r\n"
                },
                {
                    "date": 1760188209180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n-import { useParams } from \"next/navigation\";\r\n+import { useParams, useRouter } from \"next/navigation\";\r\n import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n import {\r\n@@ -31,17 +31,19 @@\n }\r\n \r\n export default function RoomPage() {\r\n   const { id } = useParams() as { id: string };\r\n+  const router = useRouter();\r\n   const socketRef = useRef<any>(null);\r\n   const localStreamRef = useRef<MediaStream | null>(null);\r\n \r\n-  // map peerId -> { pc, name }\r\n   const peerConnections = useRef<Record<string, { pc: RTCPeerConnection; name?: string }>>({});\r\n   const [room, setRoom] = useState<RoomInfo | null>(null);\r\n   const [peers, setPeers] = useState<Record<string, MediaStream>>({});\r\n+  const [muted, setMuted] = useState(false);\r\n+  const [cameraOff, setCameraOff] = useState(false);\r\n+  const [speakingPeers, setSpeakingPeers] = useState<Record<string, boolean>>({});\r\n \r\n-  // Get user-info from localStorage (your code stores it there)\r\n   const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n \r\n   // Start camera & mic\r\n   useEffect(() => {\r\n@@ -49,15 +51,30 @@\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         if (!mounted) {\r\n-          // safety: if unmounted while awaiting\r\n           stream.getTracks().forEach((t) => t.stop());\r\n           return;\r\n         }\r\n         localStreamRef.current = stream;\r\n-        // force a render so local video appears\r\n         setPeers((p) => ({ ...p }));\r\n+\r\n+        // Mute/unmute and speaking detection\r\n+        const audioCtx = new AudioContext();\r\n+        const source = audioCtx.createMediaStreamSource(stream);\r\n+        const analyser = audioCtx.createAnalyser();\r\n+        analyser.fftSize = 512;\r\n+        source.connect(analyser);\r\n+        const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n+\r\n+        const detectSpeaking = () => {\r\n+          analyser.getByteFrequencyData(dataArray);\r\n+          const sum = dataArray.reduce((a, b) => a + b, 0);\r\n+          setSpeakingPeers((prev) => ({ ...prev, local: sum > 2000 }));\r\n+          requestAnimationFrame(detectSpeaking);\r\n+        };\r\n+        detectSpeaking();\r\n+\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n@@ -65,16 +82,14 @@\n       mounted = false;\r\n     };\r\n   }, []);\r\n \r\n-  // Helper: create RTCPeerConnection for a peerId\r\n   const createPeerConnection = (peerId: string, name?: string) => {\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n \r\n     const socket = socketRef.current;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n-    // Attach local tracks (if available)\r\n     if (localStreamRef.current) {\r\n       try {\r\n         localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n       } catch (e) {\r\n@@ -83,239 +98,155 @@\n     }\r\n \r\n     pc.onicecandidate = (e) => {\r\n       if (e.candidate && socket) {\r\n-        // send candidate to the target peer\r\n         socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n       }\r\n     };\r\n \r\n     pc.ontrack = (e) => {\r\n-      // set remote stream for rendering\r\n       if (!e.streams || !e.streams[0]) return;\r\n       setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n+\r\n+      // Speaking detection for remote\r\n+      const audioCtx = new AudioContext();\r\n+      const source = audioCtx.createMediaStreamSource(e.streams[0]);\r\n+      const analyser = audioCtx.createAnalyser();\r\n+      analyser.fftSize = 512;\r\n+      source.connect(analyser);\r\n+      const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n+\r\n+      const detectRemoteSpeaking = () => {\r\n+        analyser.getByteFrequencyData(dataArray);\r\n+        const sum = dataArray.reduce((a, b) => a + b, 0);\r\n+        setSpeakingPeers((prev) => ({ ...prev, [peerId]: sum > 2000 }));\r\n+        requestAnimationFrame(detectRemoteSpeaking);\r\n+      };\r\n+      detectRemoteSpeaking();\r\n     };\r\n \r\n     pc.onconnectionstatechange = () => {\r\n-      // debug\r\n-      console.log(`Peer ${peerId} connectionState:`, pc.connectionState);\r\n-      if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\" || pc.connectionState === \"closed\") {\r\n-        // cleanup\r\n+      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) {\r\n         removePeer(peerId);\r\n       }\r\n     };\r\n \r\n     peerConnections.current[peerId] = { pc, name };\r\n     return pc;\r\n   };\r\n \r\n-  // Remove peer and its stream\r\n   const removePeer = (peerId: string) => {\r\n     const data = peerConnections.current[peerId];\r\n     if (data?.pc) {\r\n-      try {\r\n-        data.pc.close();\r\n-      } catch (e) {\r\n-        console.warn(\"Error closing pc:\", e);\r\n-      }\r\n+      try { data.pc.close(); } catch (e) {}\r\n     }\r\n     delete peerConnections.current[peerId];\r\n     setPeers((prev) => {\r\n       const copy = { ...prev };\r\n       delete copy[peerId];\r\n       return copy;\r\n     });\r\n+    setSpeakingPeers((prev) => {\r\n+      const copy = { ...prev };\r\n+      delete copy[peerId];\r\n+      return copy;\r\n+    });\r\n   };\r\n \r\n-  // Create an offer to a given peerId\r\n   const createOfferToPeer = async (peerId: string, name?: string) => {\r\n-    if (!localStreamRef.current) {\r\n-      console.warn(\"No local stream available for offer\");\r\n-      return;\r\n-    }\r\n-    // don't recreate if exists\r\n-    if (peerConnections.current[peerId]) return;\r\n+    if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n \r\n     const pc = createPeerConnection(peerId, name);\r\n     try {\r\n-      // ensure local tracks attached\r\n       localStreamRef.current.getTracks().forEach((t) => {\r\n-        try {\r\n-          pc.addTrack(t, localStreamRef.current!);\r\n-        } catch (err) {\r\n-          // adding same track twice can throw ‚Äî ignore\r\n-        }\r\n+        try { pc.addTrack(t, localStreamRef.current!); } catch {}\r\n       });\r\n-\r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n-      console.log(\"Sent offer to\", peerId);\r\n     } catch (err) {\r\n       console.error(\"Error creating offer:\", err);\r\n     }\r\n   };\r\n \r\n-  // Clean up all peer connections\r\n   const cleanupAllPeers = () => {\r\n     Object.keys(peerConnections.current).forEach((pid) => {\r\n-      try {\r\n-        peerConnections.current[pid].pc.close();\r\n-      } catch (e) {\r\n-        // ignore\r\n-      }\r\n+      try { peerConnections.current[pid].pc.close(); } catch {}\r\n       delete peerConnections.current[pid];\r\n     });\r\n     setPeers({});\r\n+    setSpeakingPeers({});\r\n   };\r\n \r\n-  // Connect to /rooms namespace, join room, and wire signaling listeners\r\n+  // Socket logic\r\n   useEffect(() => {\r\n-    // wait for local stream to be ready\r\n     if (!localStreamRef.current) return;\r\n \r\n     const socket = connectRoomSocket();\r\n     socketRef.current = socket;\r\n \r\n-    // Ask server for rooms list (so we can find room metadata/users)\r\n     socket.emit(\"list-rooms\");\r\n-\r\n-    // When server sends the list of rooms, extract this room's info (if present)\r\n     socket.on(\"rooms\", (roomsArray: RoomInfo[]) => {\r\n-      try {\r\n-        const found = (roomsArray || []).find((r: any) => r.id === id);\r\n-        if (found) {\r\n-          // server's room object may or may not include users; normalize\r\n-          const users = (found.users || []).map((u: any) =>\r\n-            typeof u === \"string\" ? { socketId: u, userInfo: {} } : u\r\n-          );\r\n-          setRoom({ ...found, users });\r\n-        }\r\n-      } catch (e) {\r\n-        console.warn(\"Error parsing rooms list\", e);\r\n+      const found = (roomsArray || []).find((r) => r.id === id);\r\n+      if (found) {\r\n+        const users = (found.users || []).map((u: any) =>\r\n+          typeof u === \"string\" ? { socketId: u, userInfo: {} } : u\r\n+        );\r\n+        setRoom({ ...found, users });\r\n       }\r\n     });\r\n \r\n-    // IMPORTANT: request user list for this room if your server supports it\r\n-    // If your server emits \"room-users\" with [{ socketId, userInfo }], we'll use it.\r\n     socket.on(\"room-users\", (users: RoomUser[]) => {\r\n-      // Replace room state and create offers to existing users\r\n       setRoom((prev) => ({ ...(prev || {}), users: users || [] } as RoomInfo));\r\n-\r\n-      // Create offers to each existing user (except ourselves)\r\n-      users.forEach((u) => {\r\n-        if (u.socketId && u.socketId !== socket.id) {\r\n-          // wait a moment to ensure we have local tracks\r\n-          setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 50);\r\n-        }\r\n-      });\r\n+      users.forEach((u) => { if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 50); });\r\n     });\r\n \r\n-    // When someone joins the room, server should emit 'user-joined'.\r\n-    // Preferred: server includes socketId in payload. If server only sends userInfo (no socketId),\r\n-    // you should update the server to emit full user object including socketId.\r\n     socket.on(\"user-joined\", (payload: any) => {\r\n-      // payload ideally: { socketId, userInfo } OR userInfo only\r\n-      console.log(\"user-joined payload:\", payload);\r\n-      const hasSocketId = payload && payload.socketId;\r\n-      if (hasSocketId) {\r\n+      if (payload?.socketId) {\r\n         const u: RoomUser = payload;\r\n         setRoom((prev) => {\r\n           const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n-          copy.users = copy.users ? [...copy.users.filter((x) => x.socketId !== u.socketId), u] : [u];\r\n+          copy.users = copy.users ? [...copy.users.filter(x => x.socketId !== u.socketId), u] : [u];\r\n           return copy;\r\n         });\r\n-\r\n-        // create offer to the newcomer\r\n-        if (payload.socketId !== socket.id) {\r\n-          setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 50);\r\n-        }\r\n-      } else {\r\n-        // No socketId present ‚Äî fall back: ask server to send room-users list (server should do this)\r\n-        console.warn(\"user-joined did not include socketId. Please update server to emit socketId or emit 'room-users'.\");\r\n-        socket.emit(\"list-rooms\");\r\n+        if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 50);\r\n       }\r\n     });\r\n \r\n-    // Handle offers from peers\r\n     socket.on(\"room-offer\", async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name?: string }) => {\r\n-      try {\r\n-        if (!localStreamRef.current) {\r\n-          console.warn(\"Got offer but localStream not ready\");\r\n-          return;\r\n-        }\r\n-        console.log(\"Received offer from\", from);\r\n-        const pc = createPeerConnection(from, name);\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        // ensure our local tracks added\r\n-        localStreamRef.current.getTracks().forEach((t) => {\r\n-          try {\r\n-            pc.addTrack(t, localStreamRef.current!);\r\n-          } catch (e) {}\r\n-        });\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-      } catch (err) {\r\n-        console.error(\"Error handling offer:\", err);\r\n-      }\r\n+      const pc = createPeerConnection(from, name);\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      localStreamRef.current?.getTracks().forEach((t) => { try { pc.addTrack(t, localStreamRef.current!); } catch {} });\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n     });\r\n \r\n-    // Handle answers from peers\r\n     socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-      try {\r\n-        const pc = peerConnections.current[from]?.pc;\r\n-        if (pc) {\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-          console.log(\"Set remote description (answer) from\", from);\r\n-        } else {\r\n-          console.warn(\"Received answer but no pc for\", from);\r\n-        }\r\n-      } catch (err) {\r\n-        console.error(\"Error applying answer:\", err);\r\n-      }\r\n+      const pc = peerConnections.current[from]?.pc;\r\n+      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     });\r\n \r\n-    // Handle ICE candidates from peers\r\n     socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-      try {\r\n-        const pc = peerConnections.current[from]?.pc;\r\n-        if (pc && candidate) {\r\n-          pc.addIceCandidate(new RTCIceCandidate(candidate)).catch((err) => {\r\n-            console.warn(\"addIceCandidate error:\", err);\r\n-          });\r\n-        } else {\r\n-          console.warn(\"No pc to add ICE for\", from);\r\n-        }\r\n-      } catch (err) {\r\n-        console.error(\"Error handling ICE:\", err);\r\n-      }\r\n+      const pc = peerConnections.current[from]?.pc;\r\n+      if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n     });\r\n \r\n-    // When a user leaves, server should emit 'user-left' with { userId: socketId }\r\n     socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n       removePeer(userId);\r\n-      setRoom((prev) => {\r\n-        if (!prev) return prev;\r\n-        return { ...prev, users: prev.users.filter((u) => u.socketId !== userId) };\r\n-      });\r\n+      setRoom((prev) => prev ? { ...prev, users: prev.users.filter(u => u.socketId !== userId) } : prev);\r\n     });\r\n \r\n-    // Finally, emit join - telling server we joined (server should respond with room-users or user-joined)\r\n     socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n \r\n-    // cleanup on unmount\r\n     return () => {\r\n-      try {\r\n-        socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n-      } catch (e) {}\r\n+      try { socket.emit(\"leave-room\", { roomId: id, userId: socket.id }); } catch {}\r\n       cleanupAllPeers();\r\n       disconnectRoomSocket();\r\n       socketRef.current = null;\r\n     };\r\n   }, [id, userInfo]);\r\n \r\n-  // If no local stream yet\r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n   const totalUsers = (room?.users?.length || Object.keys(peers).length + 1) || 1;\r\n   const getGridCols = () => {\r\n@@ -325,26 +256,72 @@\n     if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n     return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n   };\r\n \r\n+  const toggleMute = () => {\r\n+    if (!localStreamRef.current) return;\r\n+    localStreamRef.current.getAudioTracks().forEach((track) => (track.enabled = muted));\r\n+    setMuted(!muted);\r\n+  };\r\n+\r\n+  const toggleCamera = () => {\r\n+    if (!localStreamRef.current) return;\r\n+    localStreamRef.current.getVideoTracks().forEach((track) => (track.enabled = cameraOff));\r\n+    setCameraOff(!cameraOff);\r\n+  };\r\n+\r\n+  const leaveRoom = () => {\r\n+    cleanupAllPeers();\r\n+    disconnectRoomSocket();\r\n+    router.push(\"/\"); // redirect to home\r\n+  };\r\n+\r\n   return (\r\n     <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n       <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n-        <LocalVideo stream={localStreamRef.current} label={userInfo?.name || \"You\"} />\r\n+        <div className=\"relative\">\r\n+          <LocalVideo\r\n+            stream={localStreamRef.current}\r\n+            label={userInfo?.name || \"You\"}\r\n+            isSpeaking={speakingPeers[\"local\"] || false}\r\n+          />\r\n+          <div className=\"absolute top-2 right-2 flex gap-2\">\r\n+            <button\r\n+              className=\"bg-white dark:bg-gray-700 p-1 rounded\"\r\n+              onClick={toggleMute}\r\n+            >\r\n+              {muted ? \"Unmute\" : \"Mute\"}\r\n+            </button>\r\n+            <button\r\n+              className=\"bg-white dark:bg-gray-700 p-1 rounded\"\r\n+              onClick={toggleCamera}\r\n+            >\r\n+              {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n+            </button>\r\n+            <button\r\n+              className=\"bg-red-500 text-white p-1 rounded\"\r\n+              onClick={leaveRoom}\r\n+            >\r\n+              Leave\r\n+            </button>\r\n+          </div>\r\n+        </div>\r\n         {Object.entries(peers).map(([peerId, stream]) => {\r\n           const name = peerConnections.current[peerId]?.name || \"Stranger\";\r\n-          if (!stream) return null;\r\n-          return <RemoteVideo key={peerId} stream={stream} label={name} />;\r\n+          return (\r\n+            <RemoteVideo\r\n+              key={peerId}\r\n+              stream={stream}\r\n+              label={name}\r\n+              isSpeaking={speakingPeers[peerId] || false}\r\n+            />\r\n+          );\r\n         })}\r\n       </div>\r\n \r\n       <div className=\"md:w-80 flex-shrink-0\">\r\n         {socketRef.current && (\r\n-          <ChatBox\r\n-            socket={socketRef.current}\r\n-            roomId={id}\r\n-            userName={userInfo?.name || \"You\"}\r\n-          />\r\n+          <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />\r\n         )}\r\n       </div>\r\n \r\n       {room && (\r\n@@ -355,9 +332,9 @@\n             <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n           )}\r\n           <p className=\"mt-2 text-sm font-medium\">Users: {room.users?.length ?? Object.keys(peers).length + 1}</p>\r\n           <div className=\"mt-3 text-xs text-neutral-600\">\r\n-            <div>Tip: Mute/unmute and other controls are available in the top-right of the video tiles.</div>\r\n+            <div>Tip: Use the buttons on your video tile to mute/unmute, toggle camera, or leave.</div>\r\n           </div>\r\n         </div>\r\n       )}\r\n     </div>\r\n"
                },
                {
                    "date": 1760188609345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,22 +44,20 @@\n   const [speakingPeers, setSpeakingPeers] = useState<Record<string, boolean>>({});\r\n \r\n   const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n \r\n-  // Start camera & mic\r\n+  /** Start local camera & mic */\r\n   useEffect(() => {\r\n     let mounted = true;\r\n     (async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        if (!mounted) {\r\n-          stream.getTracks().forEach((t) => t.stop());\r\n-          return;\r\n-        }\r\n+        if (!mounted) return stream.getTracks().forEach(t => t.stop());\r\n+\r\n         localStreamRef.current = stream;\r\n         setPeers((p) => ({ ...p }));\r\n \r\n-        // Mute/unmute and speaking detection\r\n+        // Local speaking detection\r\n         const audioCtx = new AudioContext();\r\n         const source = audioCtx.createMediaStreamSource(stream);\r\n         const analyser = audioCtx.createAnalyser();\r\n         analyser.fftSize = 512;\r\n@@ -72,43 +70,36 @@\n           setSpeakingPeers((prev) => ({ ...prev, local: sum > 2000 }));\r\n           requestAnimationFrame(detectSpeaking);\r\n         };\r\n         detectSpeaking();\r\n-\r\n       } catch (err) {\r\n         console.error(\"Camera error:\", err);\r\n       }\r\n     })();\r\n-    return () => {\r\n-      mounted = false;\r\n-    };\r\n+    return () => { mounted = false; };\r\n   }, []);\r\n \r\n+  /** Create a peer connection for remote user */\r\n   const createPeerConnection = (peerId: string, name?: string) => {\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n \r\n     const socket = socketRef.current;\r\n     const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n-    if (localStreamRef.current) {\r\n-      try {\r\n-        localStreamRef.current.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n-      } catch (e) {\r\n-        console.warn(\"Failed to add local tracks:\", e);\r\n-      }\r\n-    }\r\n+    // Add local tracks\r\n+    localStreamRef.current?.getTracks().forEach(track => pc.addTrack(track, localStreamRef.current!));\r\n \r\n+    // ICE Candidate\r\n     pc.onicecandidate = (e) => {\r\n-      if (e.candidate && socket) {\r\n-        socket.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n-      }\r\n+      if (e.candidate) socket?.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n     };\r\n \r\n+    // Remote track received\r\n     pc.ontrack = (e) => {\r\n-      if (!e.streams || !e.streams[0]) return;\r\n+      if (!e.streams[0]) return;\r\n       setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n \r\n-      // Speaking detection for remote\r\n+      // Remote speaking detection\r\n       const audioCtx = new AudioContext();\r\n       const source = audioCtx.createMediaStreamSource(e.streams[0]);\r\n       const analyser = audioCtx.createAnalyser();\r\n       analyser.fftSize = 512;\r\n@@ -124,117 +115,93 @@\n       detectRemoteSpeaking();\r\n     };\r\n \r\n     pc.onconnectionstatechange = () => {\r\n-      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) {\r\n-        removePeer(peerId);\r\n-      }\r\n+      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) removePeer(peerId);\r\n     };\r\n \r\n     peerConnections.current[peerId] = { pc, name };\r\n     return pc;\r\n   };\r\n \r\n+  /** Remove peer connection */\r\n   const removePeer = (peerId: string) => {\r\n-    const data = peerConnections.current[peerId];\r\n-    if (data?.pc) {\r\n-      try { data.pc.close(); } catch (e) {}\r\n-    }\r\n+    peerConnections.current[peerId]?.pc.close();\r\n     delete peerConnections.current[peerId];\r\n-    setPeers((prev) => {\r\n-      const copy = { ...prev };\r\n-      delete copy[peerId];\r\n-      return copy;\r\n-    });\r\n-    setSpeakingPeers((prev) => {\r\n-      const copy = { ...prev };\r\n-      delete copy[peerId];\r\n-      return copy;\r\n-    });\r\n+\r\n+    setPeers(prev => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n+    setSpeakingPeers(prev => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n   };\r\n \r\n+  /** Offer to peer */\r\n   const createOfferToPeer = async (peerId: string, name?: string) => {\r\n     if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n-\r\n     const pc = createPeerConnection(peerId, name);\r\n-    try {\r\n-      localStreamRef.current.getTracks().forEach((t) => {\r\n-        try { pc.addTrack(t, localStreamRef.current!); } catch {}\r\n-      });\r\n-      const offer = await pc.createOffer();\r\n-      await pc.setLocalDescription(offer);\r\n-      socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n-    } catch (err) {\r\n-      console.error(\"Error creating offer:\", err);\r\n-    }\r\n+    localStreamRef.current.getTracks().forEach(track => { try { pc.addTrack(track, localStreamRef.current!); } catch {} });\r\n+    const offer = await pc.createOffer();\r\n+    await pc.setLocalDescription(offer);\r\n+    socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n   };\r\n \r\n+  /** Cleanup all peers */\r\n   const cleanupAllPeers = () => {\r\n-    Object.keys(peerConnections.current).forEach((pid) => {\r\n+    Object.keys(peerConnections.current).forEach(pid => {\r\n       try { peerConnections.current[pid].pc.close(); } catch {}\r\n       delete peerConnections.current[pid];\r\n     });\r\n     setPeers({});\r\n     setSpeakingPeers({});\r\n   };\r\n \r\n-  // Socket logic\r\n+  /** Socket handlers */\r\n   useEffect(() => {\r\n     if (!localStreamRef.current) return;\r\n-\r\n     const socket = connectRoomSocket();\r\n     socketRef.current = socket;\r\n \r\n     socket.emit(\"list-rooms\");\r\n-    socket.on(\"rooms\", (roomsArray: RoomInfo[]) => {\r\n-      const found = (roomsArray || []).find((r) => r.id === id);\r\n-      if (found) {\r\n-        const users = (found.users || []).map((u: any) =>\r\n-          typeof u === \"string\" ? { socketId: u, userInfo: {} } : u\r\n-        );\r\n-        setRoom({ ...found, users });\r\n-      }\r\n+    socket.on(\"rooms\", (rooms: RoomInfo[]) => {\r\n+      const found = rooms.find(r => r.id === id);\r\n+      if (found) setRoom({ ...found, users: found.users || [] });\r\n     });\r\n \r\n     socket.on(\"room-users\", (users: RoomUser[]) => {\r\n-      setRoom((prev) => ({ ...(prev || {}), users: users || [] } as RoomInfo));\r\n-      users.forEach((u) => { if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 50); });\r\n+      setRoom(prev => ({ ...(prev || {}), users }) as RoomInfo);\r\n+      users.forEach(u => { if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 50); });\r\n     });\r\n \r\n-    socket.on(\"user-joined\", (payload: any) => {\r\n-      if (payload?.socketId) {\r\n-        const u: RoomUser = payload;\r\n-        setRoom((prev) => {\r\n-          const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n-          copy.users = copy.users ? [...copy.users.filter(x => x.socketId !== u.socketId), u] : [u];\r\n-          return copy;\r\n-        });\r\n-        if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 50);\r\n-      }\r\n+    socket.on(\"user-joined\", (payload: RoomUser) => {\r\n+      if (!payload.socketId) return;\r\n+      setRoom(prev => {\r\n+        const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n+        copy.users = copy.users ? [...copy.users.filter(x => x.socketId !== payload.socketId), payload] : [payload];\r\n+        return copy;\r\n+      });\r\n+      if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 50);\r\n     });\r\n \r\n-    socket.on(\"room-offer\", async ({ from, offer, name }: { from: string; offer: RTCSessionDescriptionInit; name?: string }) => {\r\n+    socket.on(\"room-offer\", async ({ from, offer, name }) => {\r\n       const pc = createPeerConnection(from, name);\r\n       await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      localStreamRef.current?.getTracks().forEach((t) => { try { pc.addTrack(t, localStreamRef.current!); } catch {} });\r\n+      localStreamRef.current?.getTracks().forEach(t => { try { pc.addTrack(t, localStreamRef.current!); } catch {} });\r\n       const answer = await pc.createAnswer();\r\n       await pc.setLocalDescription(answer);\r\n       socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n     });\r\n \r\n-    socket.on(\"room-answer\", async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+    socket.on(\"room-answer\", async ({ from, answer }) => {\r\n       const pc = peerConnections.current[from]?.pc;\r\n       if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     });\r\n \r\n-    socket.on(\"room-ice\", ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+    socket.on(\"room-ice\", ({ from, candidate }) => {\r\n       const pc = peerConnections.current[from]?.pc;\r\n       if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n     });\r\n \r\n-    socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n+    socket.on(\"user-left\", ({ userId }) => {\r\n       removePeer(userId);\r\n-      setRoom((prev) => prev ? { ...prev, users: prev.users.filter(u => u.socketId !== userId) } : prev);\r\n+      setRoom(prev => prev ? { ...prev, users: prev.users.filter(u => u.socketId !== userId) } : prev);\r\n     });\r\n \r\n     socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n \r\n@@ -256,82 +223,46 @@\n     if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n     return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n   };\r\n \r\n+  /** UI actions */\r\n   const toggleMute = () => {\r\n     if (!localStreamRef.current) return;\r\n-    localStreamRef.current.getAudioTracks().forEach((track) => (track.enabled = muted));\r\n+    localStreamRef.current.getAudioTracks().forEach(track => (track.enabled = muted));\r\n     setMuted(!muted);\r\n   };\r\n-\r\n   const toggleCamera = () => {\r\n     if (!localStreamRef.current) return;\r\n-    localStreamRef.current.getVideoTracks().forEach((track) => (track.enabled = cameraOff));\r\n+    localStreamRef.current.getVideoTracks().forEach(track => (track.enabled = cameraOff));\r\n     setCameraOff(!cameraOff);\r\n   };\r\n+  const leaveRoom = () => { cleanupAllPeers(); disconnectRoomSocket(); router.push(\"/\"); };\r\n \r\n-  const leaveRoom = () => {\r\n-    cleanupAllPeers();\r\n-    disconnectRoomSocket();\r\n-    router.push(\"/\"); // redirect to home\r\n-  };\r\n-\r\n   return (\r\n     <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n       <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n         <div className=\"relative\">\r\n-          <LocalVideo\r\n-            stream={localStreamRef.current}\r\n-            label={userInfo?.name || \"You\"}\r\n-            isSpeaking={speakingPeers[\"local\"] || false}\r\n-          />\r\n+          <LocalVideo stream={localStreamRef.current} label={userInfo?.name || \"You\"} isSpeaking={speakingPeers[\"local\"] || false} />\r\n           <div className=\"absolute top-2 right-2 flex gap-2\">\r\n-            <button\r\n-              className=\"bg-white dark:bg-gray-700 p-1 rounded\"\r\n-              onClick={toggleMute}\r\n-            >\r\n-              {muted ? \"Unmute\" : \"Mute\"}\r\n-            </button>\r\n-            <button\r\n-              className=\"bg-white dark:bg-gray-700 p-1 rounded\"\r\n-              onClick={toggleCamera}\r\n-            >\r\n-              {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n-            </button>\r\n-            <button\r\n-              className=\"bg-red-500 text-white p-1 rounded\"\r\n-              onClick={leaveRoom}\r\n-            >\r\n-              Leave\r\n-            </button>\r\n+            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleMute}>{muted ? \"Unmute\" : \"Mute\"}</button>\r\n+            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleCamera}>{cameraOff ? \"Camera On\" : \"Camera Off\"}</button>\r\n+            <button className=\"bg-red-500 text-white p-1 rounded\" onClick={leaveRoom}>Leave</button>\r\n           </div>\r\n         </div>\r\n-        {Object.entries(peers).map(([peerId, stream]) => {\r\n-          const name = peerConnections.current[peerId]?.name || \"Stranger\";\r\n-          return (\r\n-            <RemoteVideo\r\n-              key={peerId}\r\n-              stream={stream}\r\n-              label={name}\r\n-              isSpeaking={speakingPeers[peerId] || false}\r\n-            />\r\n-          );\r\n-        })}\r\n+        {Object.entries(peers).map(([peerId, stream]) => (\r\n+          <RemoteVideo key={peerId} stream={stream} label={peerConnections.current[peerId]?.name || \"Stranger\"} isSpeaking={speakingPeers[peerId] || false} />\r\n+        ))}\r\n       </div>\r\n \r\n       <div className=\"md:w-80 flex-shrink-0\">\r\n-        {socketRef.current && (\r\n-          <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />\r\n-        )}\r\n+        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />}\r\n       </div>\r\n \r\n       {room && (\r\n         <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n           <h2 className=\"text-lg font-bold\">{room.name || \"Room\"}</h2>\r\n           <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n-          {room.description && (\r\n-            <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n-          )}\r\n+          {room.description && <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>}\r\n           <p className=\"mt-2 text-sm font-medium\">Users: {room.users?.length ?? Object.keys(peers).length + 1}</p>\r\n           <div className=\"mt-3 text-xs text-neutral-600\">\r\n             <div>Tip: Use the buttons on your video tile to mute/unmute, toggle camera, or leave.</div>\r\n           </div>\r\n"
                },
                {
                    "date": 1760191478312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,363 @@\n+\"use client\";\r\n+\r\n+import React, { useEffect, useRef, useState } from \"react\";\r\n+import { useParams, useRouter } from \"next/navigation\";\r\n+import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n+import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n+import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n+import {\r\n+  connectRoomSocket,\r\n+  disconnectRoomSocket,\r\n+} from \"../../../../features/RoomChat/services/roomSocketService\";\r\n+\r\n+interface UserInfo {\r\n+  name?: string;\r\n+  age?: string;\r\n+  gender?: string;\r\n+  country?: string;\r\n+}\r\n+\r\n+interface RoomUser {\r\n+  socketId: string;\r\n+  userInfo: UserInfo;\r\n+}\r\n+\r\n+interface RoomInfo {\r\n+  id: string;\r\n+  name: string;\r\n+  topic: string;\r\n+  description?: string;\r\n+  users: RoomUser[];\r\n+}\r\n+\r\n+export default function RoomPage() {\r\n+  const { id } = useParams() as { id: string };\r\n+  const router = useRouter();\r\n+  const socketRef = useRef<any>(null);\r\n+  const localStreamRef = useRef<MediaStream | null>(null);\r\n+  const peerConnections = useRef<Record<string, { pc: RTCPeerConnection; name?: string }>>({});\r\n+\r\n+  const [room, setRoom] = useState<RoomInfo | null>(null);\r\n+  const [peers, setPeers] = useState<Record<string, MediaStream>>({});\r\n+  const [muted, setMuted] = useState(false);\r\n+  const [cameraOff, setCameraOff] = useState(false);\r\n+  const [speakingPeers, setSpeakingPeers] = useState<Record<string, boolean>>({});\r\n+\r\n+  const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n+\r\n+  // -----------------------------\r\n+  // üé• Start local camera & mic\r\n+  // -----------------------------\r\n+  useEffect(() => {\r\n+    let mounted = true;\r\n+\r\n+    (async () => {\r\n+      try {\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n+        });\r\n+        if (!mounted) return stream.getTracks().forEach((t) => t.stop());\r\n+\r\n+        localStreamRef.current = stream;\r\n+        setPeers((p) => ({ ...p }));\r\n+\r\n+        // ‚úÖ Local speaking detection\r\n+        const audioCtx = new AudioContext();\r\n+        const source = audioCtx.createMediaStreamSource(stream);\r\n+        const analyser = audioCtx.createAnalyser();\r\n+        analyser.fftSize = 512;\r\n+        source.connect(analyser);\r\n+        const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n+\r\n+        const detectSpeaking = () => {\r\n+          analyser.getByteFrequencyData(dataArray);\r\n+          const sum = dataArray.reduce((a, b) => a + b, 0);\r\n+          setSpeakingPeers((prev) => ({ ...prev, local: sum > 2000 }));\r\n+          requestAnimationFrame(detectSpeaking);\r\n+        };\r\n+        detectSpeaking();\r\n+      } catch (err) {\r\n+        console.error(\"üé• Camera error:\", err);\r\n+      }\r\n+    })();\r\n+\r\n+    return () => {\r\n+      mounted = false;\r\n+      localStreamRef.current?.getTracks().forEach((t) => t.stop());\r\n+    };\r\n+  }, []);\r\n+\r\n+  // -----------------------------\r\n+  // üîó Create Peer Connection\r\n+  // -----------------------------\r\n+  const createPeerConnection = (peerId: string, name?: string) => {\r\n+    if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n+    const socket = socketRef.current;\r\n+\r\n+    const pc = new RTCPeerConnection({\r\n+      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+    });\r\n+\r\n+    // Add local tracks only once\r\n+    localStreamRef.current?.getTracks().forEach((track) => {\r\n+      pc.addTrack(track, localStreamRef.current!);\r\n+    });\r\n+\r\n+    // ICE Candidate\r\n+    pc.onicecandidate = (e) => {\r\n+      if (e.candidate) {\r\n+        socket?.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n+      }\r\n+    };\r\n+\r\n+    // Remote stream\r\n+    pc.ontrack = (e) => {\r\n+      if (!e.streams[0]) return;\r\n+      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n+\r\n+      // üé§ Remote speaking detection\r\n+      const audioCtx = new AudioContext();\r\n+      const source = audioCtx.createMediaStreamSource(e.streams[0]);\r\n+      const analyser = audioCtx.createAnalyser();\r\n+      analyser.fftSize = 512;\r\n+      source.connect(analyser);\r\n+      const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n+\r\n+      const detectRemoteSpeaking = () => {\r\n+        analyser.getByteFrequencyData(dataArray);\r\n+        const sum = dataArray.reduce((a, b) => a + b, 0);\r\n+        setSpeakingPeers((prev) => ({ ...prev, [peerId]: sum > 2000 }));\r\n+        requestAnimationFrame(detectRemoteSpeaking);\r\n+      };\r\n+      detectRemoteSpeaking();\r\n+    };\r\n+\r\n+    // Handle disconnection\r\n+    pc.onconnectionstatechange = () => {\r\n+      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) {\r\n+        removePeer(peerId);\r\n+      }\r\n+    };\r\n+\r\n+    peerConnections.current[peerId] = { pc, name };\r\n+    return pc;\r\n+  };\r\n+\r\n+  const removePeer = (peerId: string) => {\r\n+    peerConnections.current[peerId]?.pc.close();\r\n+    delete peerConnections.current[peerId];\r\n+    setPeers((prev) => {\r\n+      const copy = { ...prev };\r\n+      delete copy[peerId];\r\n+      return copy;\r\n+    });\r\n+    setSpeakingPeers((prev) => {\r\n+      const copy = { ...prev };\r\n+      delete copy[peerId];\r\n+      return copy;\r\n+    });\r\n+  };\r\n+\r\n+  const cleanupAllPeers = () => {\r\n+    Object.keys(peerConnections.current).forEach((pid) => {\r\n+      peerConnections.current[pid].pc.close();\r\n+      delete peerConnections.current[pid];\r\n+    });\r\n+    setPeers({});\r\n+    setSpeakingPeers({});\r\n+  };\r\n+\r\n+  // -----------------------------\r\n+  // üî• Socket.io Setup\r\n+  // -----------------------------\r\n+  useEffect(() => {\r\n+    if (!id) return;\r\n+    let active = true;\r\n+\r\n+    (async () => {\r\n+      // Warm up Render namespace\r\n+      await fetch(\"https://connectify-z9gv.onrender.com/rooms\").catch(() => {});\r\n+\r\n+      const socket = connectRoomSocket();\r\n+      socketRef.current = socket;\r\n+\r\n+      socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n+\r\n+      // Update room info\r\n+      socket.on(\"rooms\", (rooms: RoomInfo[]) => {\r\n+        if (!active) return;\r\n+        const found = rooms.find((r) => r.id === id);\r\n+        if (found) setRoom(found);\r\n+      });\r\n+\r\n+      socket.on(\"room-users\", (users: RoomUser[]) => {\r\n+        if (!active) return;\r\n+        setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n+        users.forEach((u) => {\r\n+          if (u.socketId !== socket.id)\r\n+            setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n+        });\r\n+      });\r\n+\r\n+      socket.on(\"user-joined\", (payload: RoomUser) => {\r\n+        if (!active || !payload.socketId) return;\r\n+        setRoom((prev) => {\r\n+          const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n+          copy.users = copy.users\r\n+            ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n+            : [payload];\r\n+          return copy;\r\n+        });\r\n+        if (payload.socketId !== socket.id)\r\n+          setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n+      });\r\n+\r\n+      socket.on(\"room-offer\", async ({ from, offer, name }) => {\r\n+        const pc = createPeerConnection(from, name);\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+      });\r\n+\r\n+      socket.on(\"room-answer\", async ({ from, answer }) => {\r\n+        const pc = peerConnections.current[from]?.pc;\r\n+        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+      });\r\n+\r\n+      socket.on(\"room-ice\", ({ from, candidate }) => {\r\n+        const pc = peerConnections.current[from]?.pc;\r\n+        if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n+      });\r\n+\r\n+      socket.on(\"user-left\", ({ userId }) => {\r\n+        removePeer(userId);\r\n+        setRoom((prev) =>\r\n+          prev ? { ...prev, users: prev.users.filter((u) => u.socketId !== userId) } : prev\r\n+        );\r\n+      });\r\n+\r\n+      return () => {\r\n+        active = false;\r\n+        try {\r\n+          socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n+        } catch {}\r\n+        cleanupAllPeers();\r\n+        disconnectRoomSocket();\r\n+        socketRef.current = null;\r\n+      };\r\n+    })();\r\n+  }, [id]);\r\n+\r\n+  // -----------------------------\r\n+  // üß† Peer Offer Creation\r\n+  // -----------------------------\r\n+  const createOfferToPeer = async (peerId: string, name?: string) => {\r\n+    if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n+    const pc = createPeerConnection(peerId, name);\r\n+    const offer = await pc.createOffer();\r\n+    await pc.setLocalDescription(offer);\r\n+    socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n+  };\r\n+\r\n+  // -----------------------------\r\n+  // üéõ UI Actions\r\n+  // -----------------------------\r\n+  const toggleMute = () => {\r\n+    if (!localStreamRef.current) return;\r\n+    const newMuted = !muted;\r\n+    localStreamRef.current.getAudioTracks().forEach((track) => (track.enabled = !newMuted));\r\n+    setMuted(newMuted);\r\n+  };\r\n+\r\n+  const toggleCamera = () => {\r\n+    if (!localStreamRef.current) return;\r\n+    const newOff = !cameraOff;\r\n+    localStreamRef.current.getVideoTracks().forEach((track) => (track.enabled = !newOff));\r\n+    setCameraOff(newOff);\r\n+  };\r\n+\r\n+  const leaveRoom = () => {\r\n+    cleanupAllPeers();\r\n+    disconnectRoomSocket();\r\n+    router.push(\"/\");\r\n+  };\r\n+\r\n+  // -----------------------------\r\n+  // üß± Layout\r\n+  // -----------------------------\r\n+  if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n+\r\n+  const totalUsers =\r\n+    room?.users?.length || Object.keys(peers).length + 1 || 1;\r\n+\r\n+  const getGridCols = () => {\r\n+    if (totalUsers === 1) return \"grid-cols-1\";\r\n+    if (totalUsers === 2) return \"grid-cols-2\";\r\n+    if (totalUsers <= 4) return \"grid-cols-2 md:grid-cols-2\";\r\n+    if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n+    return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n+  };\r\n+\r\n+  return (\r\n+    <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n+      {/* Video Grid */}\r\n+      <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n+        <div className=\"relative\">\r\n+          <LocalVideo\r\n+            stream={localStreamRef.current}\r\n+            label={userInfo?.name || \"You\"}\r\n+            isSpeaking={speakingPeers[\"local\"] || false}\r\n+          />\r\n+          <div className=\"absolute top-2 right-2 flex gap-2\">\r\n+            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleMute}>\r\n+              {muted ? \"Unmute\" : \"Mute\"}\r\n+            </button>\r\n+            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleCamera}>\r\n+              {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n+            </button>\r\n+            <button className=\"bg-red-500 text-white p-1 rounded\" onClick={leaveRoom}>\r\n+              Leave\r\n+            </button>\r\n+          </div>\r\n+        </div>\r\n+\r\n+        {Object.entries(peers).map(([peerId, stream]) => (\r\n+          <RemoteVideo\r\n+            key={peerId}\r\n+            stream={stream}\r\n+            label={peerConnections.current[peerId]?.name || \"Stranger\"}\r\n+            isSpeaking={speakingPeers[peerId] || false}\r\n+          />\r\n+        ))}\r\n+      </div>\r\n+\r\n+      {/* Chat Box */}\r\n+      <div className=\"md:w-80 flex-shrink-0\">\r\n+        {socketRef.current && (\r\n+          <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />\r\n+        )}\r\n+      </div>\r\n+\r\n+      {/* Room Info Panel */}\r\n+      {room && (\r\n+        <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n+          <h2 className=\"text-lg font-bold\">{room.name || \"Room\"}</h2>\r\n+          <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n+          {room.description && (\r\n+            <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n+          )}\r\n+          <p className=\"mt-2 text-sm font-medium\">\r\n+            Users: {room.users?.length ?? Object.keys(peers).length + 1}\r\n+          </p>\r\n+          <div className=\"mt-3 text-xs text-neutral-600\">\r\n+            <div>\r\n+              Tip: Use the buttons on your video tile to mute/unmute, toggle camera, or leave.\r\n+            </div>\r\n+          </div>\r\n+        </div>\r\n+      )}\r\n+    </div>\r\n+  );\r\n+}\r\n"
                },
                {
                    "date": 1760191478409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,277 +360,4 @@\n       )}\r\n     </div>\r\n   );\r\n }\r\n-\"use client\";\r\n-\r\n-import React, { useEffect, useRef, useState } from \"react\";\r\n-import { useParams, useRouter } from \"next/navigation\";\r\n-import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n-import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n-import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n-import {\r\n-  connectRoomSocket,\r\n-  disconnectRoomSocket,\r\n-} from \"../../../../features/RoomChat/services/roomSocketService\";\r\n-\r\n-interface UserInfo {\r\n-  name?: string;\r\n-  age?: string;\r\n-  gender?: string;\r\n-  country?: string;\r\n-}\r\n-\r\n-interface RoomUser {\r\n-  socketId: string;\r\n-  userInfo: UserInfo;\r\n-}\r\n-\r\n-interface RoomInfo {\r\n-  id: string;\r\n-  name: string;\r\n-  topic: string;\r\n-  description?: string;\r\n-  users: RoomUser[];\r\n-}\r\n-\r\n-export default function RoomPage() {\r\n-  const { id } = useParams() as { id: string };\r\n-  const router = useRouter();\r\n-  const socketRef = useRef<any>(null);\r\n-  const localStreamRef = useRef<MediaStream | null>(null);\r\n-\r\n-  const peerConnections = useRef<Record<string, { pc: RTCPeerConnection; name?: string }>>({});\r\n-  const [room, setRoom] = useState<RoomInfo | null>(null);\r\n-  const [peers, setPeers] = useState<Record<string, MediaStream>>({});\r\n-  const [muted, setMuted] = useState(false);\r\n-  const [cameraOff, setCameraOff] = useState(false);\r\n-  const [speakingPeers, setSpeakingPeers] = useState<Record<string, boolean>>({});\r\n-\r\n-  const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n-\r\n-  /** Start local camera & mic */\r\n-  useEffect(() => {\r\n-    let mounted = true;\r\n-    (async () => {\r\n-      try {\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        if (!mounted) return stream.getTracks().forEach(t => t.stop());\r\n-\r\n-        localStreamRef.current = stream;\r\n-        setPeers((p) => ({ ...p }));\r\n-\r\n-        // Local speaking detection\r\n-        const audioCtx = new AudioContext();\r\n-        const source = audioCtx.createMediaStreamSource(stream);\r\n-        const analyser = audioCtx.createAnalyser();\r\n-        analyser.fftSize = 512;\r\n-        source.connect(analyser);\r\n-        const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n-\r\n-        const detectSpeaking = () => {\r\n-          analyser.getByteFrequencyData(dataArray);\r\n-          const sum = dataArray.reduce((a, b) => a + b, 0);\r\n-          setSpeakingPeers((prev) => ({ ...prev, local: sum > 2000 }));\r\n-          requestAnimationFrame(detectSpeaking);\r\n-        };\r\n-        detectSpeaking();\r\n-      } catch (err) {\r\n-        console.error(\"Camera error:\", err);\r\n-      }\r\n-    })();\r\n-    return () => { mounted = false; };\r\n-  }, []);\r\n-\r\n-  /** Create a peer connection for remote user */\r\n-  const createPeerConnection = (peerId: string, name?: string) => {\r\n-    if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n-\r\n-    const socket = socketRef.current;\r\n-    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n-\r\n-    // Add local tracks\r\n-    localStreamRef.current?.getTracks().forEach(track => pc.addTrack(track, localStreamRef.current!));\r\n-\r\n-    // ICE Candidate\r\n-    pc.onicecandidate = (e) => {\r\n-      if (e.candidate) socket?.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n-    };\r\n-\r\n-    // Remote track received\r\n-    pc.ontrack = (e) => {\r\n-      if (!e.streams[0]) return;\r\n-      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-\r\n-      // Remote speaking detection\r\n-      const audioCtx = new AudioContext();\r\n-      const source = audioCtx.createMediaStreamSource(e.streams[0]);\r\n-      const analyser = audioCtx.createAnalyser();\r\n-      analyser.fftSize = 512;\r\n-      source.connect(analyser);\r\n-      const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n-\r\n-      const detectRemoteSpeaking = () => {\r\n-        analyser.getByteFrequencyData(dataArray);\r\n-        const sum = dataArray.reduce((a, b) => a + b, 0);\r\n-        setSpeakingPeers((prev) => ({ ...prev, [peerId]: sum > 2000 }));\r\n-        requestAnimationFrame(detectRemoteSpeaking);\r\n-      };\r\n-      detectRemoteSpeaking();\r\n-    };\r\n-\r\n-    pc.onconnectionstatechange = () => {\r\n-      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) removePeer(peerId);\r\n-    };\r\n-\r\n-    peerConnections.current[peerId] = { pc, name };\r\n-    return pc;\r\n-  };\r\n-\r\n-  /** Remove peer connection */\r\n-  const removePeer = (peerId: string) => {\r\n-    peerConnections.current[peerId]?.pc.close();\r\n-    delete peerConnections.current[peerId];\r\n-\r\n-    setPeers(prev => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n-    setSpeakingPeers(prev => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n-  };\r\n-\r\n-  /** Offer to peer */\r\n-  const createOfferToPeer = async (peerId: string, name?: string) => {\r\n-    if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n-    const pc = createPeerConnection(peerId, name);\r\n-    localStreamRef.current.getTracks().forEach(track => { try { pc.addTrack(track, localStreamRef.current!); } catch {} });\r\n-    const offer = await pc.createOffer();\r\n-    await pc.setLocalDescription(offer);\r\n-    socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n-  };\r\n-\r\n-  /** Cleanup all peers */\r\n-  const cleanupAllPeers = () => {\r\n-    Object.keys(peerConnections.current).forEach(pid => {\r\n-      try { peerConnections.current[pid].pc.close(); } catch {}\r\n-      delete peerConnections.current[pid];\r\n-    });\r\n-    setPeers({});\r\n-    setSpeakingPeers({});\r\n-  };\r\n-\r\n-  /** Socket handlers */\r\n-  useEffect(() => {\r\n-    if (!localStreamRef.current) return;\r\n-    const socket = connectRoomSocket();\r\n-    socketRef.current = socket;\r\n-\r\n-    socket.emit(\"list-rooms\");\r\n-    socket.on(\"rooms\", (rooms: RoomInfo[]) => {\r\n-      const found = rooms.find(r => r.id === id);\r\n-      if (found) setRoom({ ...found, users: found.users || [] });\r\n-    });\r\n-\r\n-    socket.on(\"room-users\", (users: RoomUser[]) => {\r\n-      setRoom(prev => ({ ...(prev || {}), users }) as RoomInfo);\r\n-      users.forEach(u => { if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 50); });\r\n-    });\r\n-\r\n-    socket.on(\"user-joined\", (payload: RoomUser) => {\r\n-      if (!payload.socketId) return;\r\n-      setRoom(prev => {\r\n-        const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n-        copy.users = copy.users ? [...copy.users.filter(x => x.socketId !== payload.socketId), payload] : [payload];\r\n-        return copy;\r\n-      });\r\n-      if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 50);\r\n-    });\r\n-\r\n-    socket.on(\"room-offer\", async ({ from, offer, name }) => {\r\n-      const pc = createPeerConnection(from, name);\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      localStreamRef.current?.getTracks().forEach(t => { try { pc.addTrack(t, localStreamRef.current!); } catch {} });\r\n-      const answer = await pc.createAnswer();\r\n-      await pc.setLocalDescription(answer);\r\n-      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-    });\r\n-\r\n-    socket.on(\"room-answer\", async ({ from, answer }) => {\r\n-      const pc = peerConnections.current[from]?.pc;\r\n-      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-    });\r\n-\r\n-    socket.on(\"room-ice\", ({ from, candidate }) => {\r\n-      const pc = peerConnections.current[from]?.pc;\r\n-      if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n-    });\r\n-\r\n-    socket.on(\"user-left\", ({ userId }) => {\r\n-      removePeer(userId);\r\n-      setRoom(prev => prev ? { ...prev, users: prev.users.filter(u => u.socketId !== userId) } : prev);\r\n-    });\r\n-\r\n-    socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n-\r\n-    return () => {\r\n-      try { socket.emit(\"leave-room\", { roomId: id, userId: socket.id }); } catch {}\r\n-      cleanupAllPeers();\r\n-      disconnectRoomSocket();\r\n-      socketRef.current = null;\r\n-    };\r\n-  }, [id, userInfo]);\r\n-\r\n-  if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n-\r\n-  const totalUsers = (room?.users?.length || Object.keys(peers).length + 1) || 1;\r\n-  const getGridCols = () => {\r\n-    if (totalUsers === 1) return \"grid-cols-1\";\r\n-    if (totalUsers === 2) return \"grid-cols-2\";\r\n-    if (totalUsers <= 4) return \"grid-cols-2 md:grid-cols-2\";\r\n-    if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n-    return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n-  };\r\n-\r\n-  /** UI actions */\r\n-  const toggleMute = () => {\r\n-    if (!localStreamRef.current) return;\r\n-    localStreamRef.current.getAudioTracks().forEach(track => (track.enabled = muted));\r\n-    setMuted(!muted);\r\n-  };\r\n-  const toggleCamera = () => {\r\n-    if (!localStreamRef.current) return;\r\n-    localStreamRef.current.getVideoTracks().forEach(track => (track.enabled = cameraOff));\r\n-    setCameraOff(!cameraOff);\r\n-  };\r\n-  const leaveRoom = () => { cleanupAllPeers(); disconnectRoomSocket(); router.push(\"/\"); };\r\n-\r\n-  return (\r\n-    <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n-      <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n-        <div className=\"relative\">\r\n-          <LocalVideo stream={localStreamRef.current} label={userInfo?.name || \"You\"} isSpeaking={speakingPeers[\"local\"] || false} />\r\n-          <div className=\"absolute top-2 right-2 flex gap-2\">\r\n-            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleMute}>{muted ? \"Unmute\" : \"Mute\"}</button>\r\n-            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleCamera}>{cameraOff ? \"Camera On\" : \"Camera Off\"}</button>\r\n-            <button className=\"bg-red-500 text-white p-1 rounded\" onClick={leaveRoom}>Leave</button>\r\n-          </div>\r\n-        </div>\r\n-        {Object.entries(peers).map(([peerId, stream]) => (\r\n-          <RemoteVideo key={peerId} stream={stream} label={peerConnections.current[peerId]?.name || \"Stranger\"} isSpeaking={speakingPeers[peerId] || false} />\r\n-        ))}\r\n-      </div>\r\n-\r\n-      <div className=\"md:w-80 flex-shrink-0\">\r\n-        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />}\r\n-      </div>\r\n-\r\n-      {room && (\r\n-        <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n-          <h2 className=\"text-lg font-bold\">{room.name || \"Room\"}</h2>\r\n-          <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n-          {room.description && <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>}\r\n-          <p className=\"mt-2 text-sm font-medium\">Users: {room.users?.length ?? Object.keys(peers).length + 1}</p>\r\n-          <div className=\"mt-3 text-xs text-neutral-600\">\r\n-            <div>Tip: Use the buttons on your video tile to mute/unmute, toggle camera, or leave.</div>\r\n-          </div>\r\n-        </div>\r\n-      )}\r\n-    </div>\r\n-  );\r\n-}\r\n"
                },
                {
                    "date": 1760246611456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,11 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams, useRouter } from \"next/navigation\";\r\n-import LocalVideo from \"../../../../features/RoomChat/components/LocalVideo\";\r\n-import RemoteVideo from \"../../../../features/RoomChat/components/RemoteVideo\";\r\n+import VideoGrid from \"../../../../features/RoomChat/components/VideoGrid\";\r\n import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n-import {\r\n-  connectRoomSocket,\r\n-  disconnectRoomSocket,\r\n-} from \"../../../../features/RoomChat/services/roomSocketService\";\r\n+import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n \r\n interface UserInfo {\r\n   name?: string;\r\n   age?: string;\r\n@@ -32,8 +28,9 @@\n \r\n export default function RoomPage() {\r\n   const { id } = useParams() as { id: string };\r\n   const router = useRouter();\r\n+\r\n   const socketRef = useRef<any>(null);\r\n   const localStreamRef = useRef<MediaStream | null>(null);\r\n   const peerConnections = useRef<Record<string, { pc: RTCPeerConnection; name?: string }>>({});\r\n \r\n@@ -52,18 +49,14 @@\n     let mounted = true;\r\n \r\n     (async () => {\r\n       try {\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         if (!mounted) return stream.getTracks().forEach((t) => t.stop());\r\n \r\n         localStreamRef.current = stream;\r\n-        setPeers((p) => ({ ...p }));\r\n \r\n-        // ‚úÖ Local speaking detection\r\n+        // Local speaking detection\r\n         const audioCtx = new AudioContext();\r\n         const source = audioCtx.createMediaStreamSource(stream);\r\n         const analyser = audioCtx.createAnalyser();\r\n         analyser.fftSize = 512;\r\n@@ -98,26 +91,22 @@\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n-    // Add local tracks only once\r\n-    localStreamRef.current?.getTracks().forEach((track) => {\r\n-      pc.addTrack(track, localStreamRef.current!);\r\n-    });\r\n+    // Add local tracks\r\n+    localStreamRef.current?.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n \r\n     // ICE Candidate\r\n     pc.onicecandidate = (e) => {\r\n-      if (e.candidate) {\r\n-        socket?.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n-      }\r\n+      if (e.candidate) socket?.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n     };\r\n \r\n-    // Remote stream\r\n+    // Remote Stream\r\n     pc.ontrack = (e) => {\r\n       if (!e.streams[0]) return;\r\n       setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n \r\n-      // üé§ Remote speaking detection\r\n+      // Remote speaking detection\r\n       const audioCtx = new AudioContext();\r\n       const source = audioCtx.createMediaStreamSource(e.streams[0]);\r\n       const analyser = audioCtx.createAnalyser();\r\n       analyser.fftSize = 512;\r\n@@ -132,13 +121,11 @@\n       };\r\n       detectRemoteSpeaking();\r\n     };\r\n \r\n-    // Handle disconnection\r\n+    // Connection state\r\n     pc.onconnectionstatechange = () => {\r\n-      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) {\r\n-        removePeer(peerId);\r\n-      }\r\n+      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) removePeer(peerId);\r\n     };\r\n \r\n     peerConnections.current[peerId] = { pc, name };\r\n     return pc;\r\n@@ -159,12 +146,10 @@\n     });\r\n   };\r\n \r\n   const cleanupAllPeers = () => {\r\n-    Object.keys(peerConnections.current).forEach((pid) => {\r\n-      peerConnections.current[pid].pc.close();\r\n-      delete peerConnections.current[pid];\r\n-    });\r\n+    Object.keys(peerConnections.current).forEach((pid) => peerConnections.current[pid].pc.close());\r\n+    peerConnections.current = {};\r\n     setPeers({});\r\n     setSpeakingPeers({});\r\n   };\r\n \r\n@@ -175,32 +160,22 @@\n     if (!id) return;\r\n     let active = true;\r\n \r\n     (async () => {\r\n-      // Warm up Render namespace\r\n-      await fetch(\"https://connectify-z9gv.onrender.com/rooms\").catch(() => {});\r\n-\r\n       const socket = connectRoomSocket();\r\n       socketRef.current = socket;\r\n-\r\n       socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n \r\n-      // Update room info\r\n-      socket.on(\"rooms\", (rooms: RoomInfo[]) => {\r\n-        if (!active) return;\r\n-        const found = rooms.find((r) => r.id === id);\r\n-        if (found) setRoom(found);\r\n-      });\r\n-\r\n+      // Room users update\r\n       socket.on(\"room-users\", (users: RoomUser[]) => {\r\n         if (!active) return;\r\n         setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n         users.forEach((u) => {\r\n-          if (u.socketId !== socket.id)\r\n-            setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n+          if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n         });\r\n       });\r\n \r\n+      // User joined\r\n       socket.on(\"user-joined\", (payload: RoomUser) => {\r\n         if (!active || !payload.socketId) return;\r\n         setRoom((prev) => {\r\n           const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n@@ -208,14 +183,14 @@\n             ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n             : [payload];\r\n           return copy;\r\n         });\r\n-        if (payload.socketId !== socket.id)\r\n-          setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n+        if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n       });\r\n \r\n-      socket.on(\"room-offer\", async ({ from, offer, name }) => {\r\n-        const pc = createPeerConnection(from, name);\r\n+      // WebRTC signaling\r\n+      socket.on(\"room-offer\", async ({ from, offer }) => {\r\n+        const pc = createPeerConnection(from);\r\n         await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n         const answer = await pc.createAnswer();\r\n         await pc.setLocalDescription(answer);\r\n         socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n@@ -284,79 +259,52 @@\n     router.push(\"/\");\r\n   };\r\n \r\n   // -----------------------------\r\n-  // üß± Layout\r\n+  // Render\r\n   // -----------------------------\r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n-  const totalUsers =\r\n-    room?.users?.length || Object.keys(peers).length + 1 || 1;\r\n+  const userStreams = [\r\n+    ...(localStreamRef.current ? [{ id: \"local\", stream: localStreamRef.current, name: userInfo?.name || \"You\", isSpeaking: speakingPeers[\"local\"] }] : []),\r\n+    ...Object.entries(peers).map(([id, stream]) => ({\r\n+      id,\r\n+      stream,\r\n+      name: peerConnections.current[id]?.name || \"Stranger\",\r\n+      isSpeaking: speakingPeers[id],\r\n+    })),\r\n+  ];\r\n \r\n-  const getGridCols = () => {\r\n-    if (totalUsers === 1) return \"grid-cols-1\";\r\n-    if (totalUsers === 2) return \"grid-cols-2\";\r\n-    if (totalUsers <= 4) return \"grid-cols-2 md:grid-cols-2\";\r\n-    if (totalUsers <= 6) return \"grid-cols-2 md:grid-cols-3\";\r\n-    return \"grid-cols-2 md:grid-cols-3 lg:grid-cols-4\";\r\n-  };\r\n-\r\n   return (\r\n     <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n       {/* Video Grid */}\r\n-      <div className={`flex-1 grid ${getGridCols()} gap-4`}>\r\n-        <div className=\"relative\">\r\n-          <LocalVideo\r\n-            stream={localStreamRef.current}\r\n-            label={userInfo?.name || \"You\"}\r\n-            isSpeaking={speakingPeers[\"local\"] || false}\r\n-          />\r\n-          <div className=\"absolute top-2 right-2 flex gap-2\">\r\n-            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleMute}>\r\n-              {muted ? \"Unmute\" : \"Mute\"}\r\n-            </button>\r\n-            <button className=\"bg-white dark:bg-gray-700 p-1 rounded\" onClick={toggleCamera}>\r\n-              {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n-            </button>\r\n-            <button className=\"bg-red-500 text-white p-1 rounded\" onClick={leaveRoom}>\r\n-              Leave\r\n-            </button>\r\n-          </div>\r\n+      <div className=\"flex-1\">\r\n+        <VideoGrid localStream={localStreamRef.current} localName={userInfo?.name || \"You\"} remoteStreams={userStreams.filter((u) => u.id !== \"local\")} />\r\n+        <div className=\"flex gap-2 mt-2 justify-end\">\r\n+          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleMute}>\r\n+            {muted ? \"Unmute\" : \"Mute\"}\r\n+          </button>\r\n+          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleCamera}>\r\n+            {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n+          </button>\r\n+          <button className=\"bg-red-500 text-white p-2 rounded\" onClick={leaveRoom}>\r\n+            Leave\r\n+          </button>\r\n         </div>\r\n-\r\n-        {Object.entries(peers).map(([peerId, stream]) => (\r\n-          <RemoteVideo\r\n-            key={peerId}\r\n-            stream={stream}\r\n-            label={peerConnections.current[peerId]?.name || \"Stranger\"}\r\n-            isSpeaking={speakingPeers[peerId] || false}\r\n-          />\r\n-        ))}\r\n       </div>\r\n \r\n       {/* Chat Box */}\r\n       <div className=\"md:w-80 flex-shrink-0\">\r\n-        {socketRef.current && (\r\n-          <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />\r\n-        )}\r\n+        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />}\r\n       </div>\r\n \r\n-      {/* Room Info Panel */}\r\n+      {/* Room Info */}\r\n       {room && (\r\n         <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n-          <h2 className=\"text-lg font-bold\">{room.name || \"Room\"}</h2>\r\n+          <h2 className=\"text-lg font-bold\">{room.name}</h2>\r\n           <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n-          {room.description && (\r\n-            <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>\r\n-          )}\r\n-          <p className=\"mt-2 text-sm font-medium\">\r\n-            Users: {room.users?.length ?? Object.keys(peers).length + 1}\r\n-          </p>\r\n-          <div className=\"mt-3 text-xs text-neutral-600\">\r\n-            <div>\r\n-              Tip: Use the buttons on your video tile to mute/unmute, toggle camera, or leave.\r\n-            </div>\r\n-          </div>\r\n+          {room.description && <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>}\r\n+          <p className=\"mt-2 text-sm font-medium\">Users: {room.users?.length ?? Object.keys(peers).length + 1}</p>\r\n         </div>\r\n       )}\r\n     </div>\r\n   );\r\n"
                },
                {
                    "date": 1760246845370,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,11 +87,9 @@\n   const createPeerConnection = (peerId: string, name?: string) => {\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n     const socket = socketRef.current;\r\n \r\n-    const pc = new RTCPeerConnection({\r\n-      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n-    });\r\n+    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n \r\n     // Add local tracks\r\n     localStreamRef.current?.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n \r\n@@ -133,18 +131,10 @@\n \r\n   const removePeer = (peerId: string) => {\r\n     peerConnections.current[peerId]?.pc.close();\r\n     delete peerConnections.current[peerId];\r\n-    setPeers((prev) => {\r\n-      const copy = { ...prev };\r\n-      delete copy[peerId];\r\n-      return copy;\r\n-    });\r\n-    setSpeakingPeers((prev) => {\r\n-      const copy = { ...prev };\r\n-      delete copy[peerId];\r\n-      return copy;\r\n-    });\r\n+    setPeers((prev) => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n+    setSpeakingPeers((prev) => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n   };\r\n \r\n   const cleanupAllPeers = () => {\r\n     Object.keys(peerConnections.current).forEach((pid) => peerConnections.current[pid].pc.close());\r\n@@ -159,71 +149,65 @@\n   useEffect(() => {\r\n     if (!id) return;\r\n     let active = true;\r\n \r\n-    (async () => {\r\n-      const socket = connectRoomSocket();\r\n-      socketRef.current = socket;\r\n-      socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n+    const socket = connectRoomSocket();\r\n+    socketRef.current = socket;\r\n+    socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n \r\n-      // Room users update\r\n-      socket.on(\"room-users\", (users: RoomUser[]) => {\r\n-        if (!active) return;\r\n-        setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n-        users.forEach((u) => {\r\n-          if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n-        });\r\n+    // Room users update\r\n+    socket.on(\"room-users\", (users: RoomUser[]) => {\r\n+      if (!active) return;\r\n+      setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n+      users.forEach((u) => {\r\n+        if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n       });\r\n+    });\r\n \r\n-      // User joined\r\n-      socket.on(\"user-joined\", (payload: RoomUser) => {\r\n-        if (!active || !payload.socketId) return;\r\n-        setRoom((prev) => {\r\n-          const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n-          copy.users = copy.users\r\n-            ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n-            : [payload];\r\n-          return copy;\r\n-        });\r\n-        if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n+    // User joined\r\n+    socket.on(\"user-joined\", (payload: RoomUser) => {\r\n+      if (!active || !payload.socketId) return;\r\n+      setRoom((prev) => {\r\n+        const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n+        copy.users = copy.users\r\n+          ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n+          : [payload];\r\n+        return copy;\r\n       });\r\n+      if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n+    });\r\n \r\n-      // WebRTC signaling\r\n-      socket.on(\"room-offer\", async ({ from, offer }) => {\r\n-        const pc = createPeerConnection(from);\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-      });\r\n+    // WebRTC signaling\r\n+    socket.on(\"room-offer\", async ({ from, offer }) => {\r\n+      const pc = createPeerConnection(from);\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+    });\r\n \r\n-      socket.on(\"room-answer\", async ({ from, answer }) => {\r\n-        const pc = peerConnections.current[from]?.pc;\r\n-        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-      });\r\n+    socket.on(\"room-answer\", async ({ from, answer }) => {\r\n+      const pc = peerConnections.current[from]?.pc;\r\n+      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    });\r\n \r\n-      socket.on(\"room-ice\", ({ from, candidate }) => {\r\n-        const pc = peerConnections.current[from]?.pc;\r\n-        if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n-      });\r\n+    socket.on(\"room-ice\", ({ from, candidate }) => {\r\n+      const pc = peerConnections.current[from]?.pc;\r\n+      if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n+    });\r\n \r\n-      socket.on(\"user-left\", ({ userId }) => {\r\n-        removePeer(userId);\r\n-        setRoom((prev) =>\r\n-          prev ? { ...prev, users: prev.users.filter((u) => u.socketId !== userId) } : prev\r\n-        );\r\n-      });\r\n+    socket.on(\"user-left\", ({ userId }) => {\r\n+      removePeer(userId);\r\n+      setRoom((prev) => prev ? { ...prev, users: prev.users.filter((u) => u.socketId !== userId) } : prev);\r\n+    });\r\n \r\n-      return () => {\r\n-        active = false;\r\n-        try {\r\n-          socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n-        } catch {}\r\n-        cleanupAllPeers();\r\n-        disconnectRoomSocket();\r\n-        socketRef.current = null;\r\n-      };\r\n-    })();\r\n+    return () => {\r\n+      active = false;\r\n+      try { socket.emit(\"leave-room\", { roomId: id, userId: socket.id }); } catch {}\r\n+      cleanupAllPeers();\r\n+      disconnectRoomSocket();\r\n+      socketRef.current = null;\r\n+    };\r\n   }, [id]);\r\n \r\n   // -----------------------------\r\n   // üß† Peer Offer Creation\r\n@@ -255,18 +239,18 @@\n \r\n   const leaveRoom = () => {\r\n     cleanupAllPeers();\r\n     disconnectRoomSocket();\r\n-    router.push(\"/\");\r\n+    router.push(\"/rooms\");\r\n   };\r\n \r\n   // -----------------------------\r\n   // Render\r\n   // -----------------------------\r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n   const userStreams = [\r\n-    ...(localStreamRef.current ? [{ id: \"local\", stream: localStreamRef.current, name: userInfo?.name || \"You\", isSpeaking: speakingPeers[\"local\"] }] : []),\r\n+    { id: \"local\", stream: localStreamRef.current, name: userInfo?.name || \"You\", isSpeaking: speakingPeers[\"local\"] },\r\n     ...Object.entries(peers).map(([id, stream]) => ({\r\n       id,\r\n       stream,\r\n       name: peerConnections.current[id]?.name || \"Stranger\",\r\n@@ -279,17 +263,11 @@\n       {/* Video Grid */}\r\n       <div className=\"flex-1\">\r\n         <VideoGrid localStream={localStreamRef.current} localName={userInfo?.name || \"You\"} remoteStreams={userStreams.filter((u) => u.id !== \"local\")} />\r\n         <div className=\"flex gap-2 mt-2 justify-end\">\r\n-          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleMute}>\r\n-            {muted ? \"Unmute\" : \"Mute\"}\r\n-          </button>\r\n-          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleCamera}>\r\n-            {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n-          </button>\r\n-          <button className=\"bg-red-500 text-white p-2 rounded\" onClick={leaveRoom}>\r\n-            Leave\r\n-          </button>\r\n+          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleMute}>{muted ? \"Unmute\" : \"Mute\"}</button>\r\n+          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleCamera}>{cameraOff ? \"Camera On\" : \"Camera Off\"}</button>\r\n+          <button className=\"bg-red-500 text-white p-2 rounded\" onClick={leaveRoom}>Leave</button>\r\n         </div>\r\n       </div>\r\n \r\n       {/* Chat Box */}\r\n"
                },
                {
                    "date": 1760249525482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,11 @@\n   const createPeerConnection = (peerId: string, name?: string) => {\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n     const socket = socketRef.current;\r\n \r\n-    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n+    const pc = new RTCPeerConnection({\r\n+      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+    });\r\n \r\n     // Add local tracks\r\n     localStreamRef.current?.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n \r\n@@ -131,10 +133,18 @@\n \r\n   const removePeer = (peerId: string) => {\r\n     peerConnections.current[peerId]?.pc.close();\r\n     delete peerConnections.current[peerId];\r\n-    setPeers((prev) => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n-    setSpeakingPeers((prev) => { const copy = { ...prev }; delete copy[peerId]; return copy; });\r\n+    setPeers((prev) => {\r\n+      const copy = { ...prev };\r\n+      delete copy[peerId];\r\n+      return copy;\r\n+    });\r\n+    setSpeakingPeers((prev) => {\r\n+      const copy = { ...prev };\r\n+      delete copy[peerId];\r\n+      return copy;\r\n+    });\r\n   };\r\n \r\n   const cleanupAllPeers = () => {\r\n     Object.keys(peerConnections.current).forEach((pid) => peerConnections.current[pid].pc.close());\r\n@@ -149,65 +159,71 @@\n   useEffect(() => {\r\n     if (!id) return;\r\n     let active = true;\r\n \r\n-    const socket = connectRoomSocket();\r\n-    socketRef.current = socket;\r\n-    socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n+    (async () => {\r\n+      const socket = connectRoomSocket();\r\n+      socketRef.current = socket;\r\n+      socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n \r\n-    // Room users update\r\n-    socket.on(\"room-users\", (users: RoomUser[]) => {\r\n-      if (!active) return;\r\n-      setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n-      users.forEach((u) => {\r\n-        if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n+      // Room users update\r\n+      socket.on(\"room-users\", (users: RoomUser[]) => {\r\n+        if (!active) return;\r\n+        setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n+        users.forEach((u) => {\r\n+          if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n+        });\r\n       });\r\n-    });\r\n \r\n-    // User joined\r\n-    socket.on(\"user-joined\", (payload: RoomUser) => {\r\n-      if (!active || !payload.socketId) return;\r\n-      setRoom((prev) => {\r\n-        const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n-        copy.users = copy.users\r\n-          ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n-          : [payload];\r\n-        return copy;\r\n+      // User joined\r\n+      socket.on(\"user-joined\", (payload: RoomUser) => {\r\n+        if (!active || !payload.socketId) return;\r\n+        setRoom((prev) => {\r\n+          const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n+          copy.users = copy.users\r\n+            ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n+            : [payload];\r\n+          return copy;\r\n+        });\r\n+        if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n       });\r\n-      if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n-    });\r\n \r\n-    // WebRTC signaling\r\n-    socket.on(\"room-offer\", async ({ from, offer }) => {\r\n-      const pc = createPeerConnection(from);\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      const answer = await pc.createAnswer();\r\n-      await pc.setLocalDescription(answer);\r\n-      socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-    });\r\n+      // WebRTC signaling\r\n+      socket.on(\"room-offer\", async ({ from, offer }) => {\r\n+        const pc = createPeerConnection(from);\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n+      });\r\n \r\n-    socket.on(\"room-answer\", async ({ from, answer }) => {\r\n-      const pc = peerConnections.current[from]?.pc;\r\n-      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-    });\r\n+      socket.on(\"room-answer\", async ({ from, answer }) => {\r\n+        const pc = peerConnections.current[from]?.pc;\r\n+        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+      });\r\n \r\n-    socket.on(\"room-ice\", ({ from, candidate }) => {\r\n-      const pc = peerConnections.current[from]?.pc;\r\n-      if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n-    });\r\n+      socket.on(\"room-ice\", ({ from, candidate }) => {\r\n+        const pc = peerConnections.current[from]?.pc;\r\n+        if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n+      });\r\n \r\n-    socket.on(\"user-left\", ({ userId }) => {\r\n-      removePeer(userId);\r\n-      setRoom((prev) => prev ? { ...prev, users: prev.users.filter((u) => u.socketId !== userId) } : prev);\r\n-    });\r\n+      socket.on(\"user-left\", ({ userId }) => {\r\n+        removePeer(userId);\r\n+        setRoom((prev) =>\r\n+          prev ? { ...prev, users: prev.users.filter((u) => u.socketId !== userId) } : prev\r\n+        );\r\n+      });\r\n \r\n-    return () => {\r\n-      active = false;\r\n-      try { socket.emit(\"leave-room\", { roomId: id, userId: socket.id }); } catch {}\r\n-      cleanupAllPeers();\r\n-      disconnectRoomSocket();\r\n-      socketRef.current = null;\r\n-    };\r\n+      return () => {\r\n+        active = false;\r\n+        try {\r\n+          socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n+        } catch {}\r\n+        cleanupAllPeers();\r\n+        disconnectRoomSocket();\r\n+        socketRef.current = null;\r\n+      };\r\n+    })();\r\n   }, [id]);\r\n \r\n   // -----------------------------\r\n   // üß† Peer Offer Creation\r\n@@ -239,18 +255,18 @@\n \r\n   const leaveRoom = () => {\r\n     cleanupAllPeers();\r\n     disconnectRoomSocket();\r\n-    router.push(\"/rooms\");\r\n+    router.push(\"/\");\r\n   };\r\n \r\n   // -----------------------------\r\n   // Render\r\n   // -----------------------------\r\n   if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n \r\n   const userStreams = [\r\n-    { id: \"local\", stream: localStreamRef.current, name: userInfo?.name || \"You\", isSpeaking: speakingPeers[\"local\"] },\r\n+    ...(localStreamRef.current ? [{ id: \"local\", stream: localStreamRef.current, name: userInfo?.name || \"You\", isSpeaking: speakingPeers[\"local\"] }] : []),\r\n     ...Object.entries(peers).map(([id, stream]) => ({\r\n       id,\r\n       stream,\r\n       name: peerConnections.current[id]?.name || \"Stranger\",\r\n@@ -263,11 +279,17 @@\n       {/* Video Grid */}\r\n       <div className=\"flex-1\">\r\n         <VideoGrid localStream={localStreamRef.current} localName={userInfo?.name || \"You\"} remoteStreams={userStreams.filter((u) => u.id !== \"local\")} />\r\n         <div className=\"flex gap-2 mt-2 justify-end\">\r\n-          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleMute}>{muted ? \"Unmute\" : \"Mute\"}</button>\r\n-          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleCamera}>{cameraOff ? \"Camera On\" : \"Camera Off\"}</button>\r\n-          <button className=\"bg-red-500 text-white p-2 rounded\" onClick={leaveRoom}>Leave</button>\r\n+          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleMute}>\r\n+            {muted ? \"Unmute\" : \"Mute\"}\r\n+          </button>\r\n+          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleCamera}>\r\n+            {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n+          </button>\r\n+          <button className=\"bg-red-500 text-white p-2 rounded\" onClick={leaveRoom}>\r\n+            Leave\r\n+          </button>\r\n         </div>\r\n       </div>\r\n \r\n       {/* Chat Box */}\r\n"
                },
                {
                    "date": 1760250127330,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams, useRouter } from \"next/navigation\";\r\n-import VideoGrid from \"../../../../features/RoomChat/components/VideoGrid\";\r\n-import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n-import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n+import VideoGrid from \"../../features/RoomChat/components/VideoGrid\";\r\n+import ChatBox from \"../../features/RoomChat/components/RoomChatBox\";\r\n+import { connectRoomSocket, disconnectRoomSocket } from \"../../features/RoomChat/services/roomSocketService\";\r\n \r\n interface UserInfo {\r\n   name?: string;\r\n   age?: string;\r\n"
                },
                {
                    "date": 1760262454833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams, useRouter } from \"next/navigation\";\r\n-import VideoGrid from \"../../features/RoomChat/components/VideoGrid\";\r\n-import ChatBox from \"../../features/RoomChat/components/RoomChatBox\";\r\n-import { connectRoomSocket, disconnectRoomSocket } from \"../../features/RoomChat/services/roomSocketService\";\r\n+import VideoGrid from \"../../../../features/RoomChat/components/VideoGrid\";\r\n+import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n+import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n \r\n interface UserInfo {\r\n   name?: string;\r\n   age?: string;\r\n"
                },
                {
                    "date": 1760262468340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n \"use client\";\r\n \r\n import React, { useEffect, useRef, useState } from \"react\";\r\n import { useParams, useRouter } from \"next/navigation\";\r\n-import VideoGrid from \"../../../../features/RoomChat/components/VideoGrid\";\r\n-import ChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n-import { connectRoomSocket, disconnectRoomSocket } from \"../../../../features/RoomChat/services/roomSocketService\";\r\n+import VideoGrid from \"../../features/RoomChat/components/VideoGrid\";\r\n+import ChatBox from \"../../features/RoomChat/components/RoomChatBox\";\r\n+import { connectRoomSocket, disconnectRoomSocket } from \"../../features/RoomChat/services/roomSocketService\";\r\n \r\n interface UserInfo {\r\n   name?: string;\r\n   age?: string;\r\n"
                },
                {
                    "date": 1760267738973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,311 +1,57 @@\n+// src/app/rooms/[id]/page.tsx\r\n \"use client\";\r\n+import React, { useEffect, useMemo, useState } from \"react\";\r\n+import { useRouter, useParams } from \"next/navigation\";\r\n+import RoomVideoGrid from \"../../../../features/RoomChat/components/RoomVideoGrid\";\r\n+import RoomChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n+import { useRoomSocket } from \"../../../../features/RoomChat/hooks/useRoomSocket\";\r\n+import { useRoomWebRTC } from \"../../../../features/RoomChat/hooks/useRoomWebRTC\";\r\n \r\n-import React, { useEffect, useRef, useState } from \"react\";\r\n-import { useParams, useRouter } from \"next/navigation\";\r\n-import VideoGrid from \"../../features/RoomChat/components/VideoGrid\";\r\n-import ChatBox from \"../../features/RoomChat/components/RoomChatBox\";\r\n-import { connectRoomSocket, disconnectRoomSocket } from \"../../features/RoomChat/services/roomSocketService\";\r\n-\r\n-interface UserInfo {\r\n-  name?: string;\r\n-  age?: string;\r\n-  gender?: string;\r\n-  country?: string;\r\n-}\r\n-\r\n-interface RoomUser {\r\n-  socketId: string;\r\n-  userInfo: UserInfo;\r\n-}\r\n-\r\n-interface RoomInfo {\r\n-  id: string;\r\n-  name: string;\r\n-  topic: string;\r\n-  description?: string;\r\n-  users: RoomUser[];\r\n-}\r\n-\r\n export default function RoomPage() {\r\n-  const { id } = useParams() as { id: string };\r\n-  const router = useRouter();\r\n+  const params = useParams();\r\n+  const roomId = params?.id as string;\r\n+  const { joinRoom, leaveRoom } = useRoomSocket();\r\n+  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n+  const { remoteStreams, joinRoom: joinWebRTCRoom, leaveRoom: leaveWebRTCRoom } = useRoomWebRTC(localStream);\r\n \r\n-  const socketRef = useRef<any>(null);\r\n-  const localStreamRef = useRef<MediaStream | null>(null);\r\n-  const peerConnections = useRef<Record<string, { pc: RTCPeerConnection; name?: string }>>({});\r\n-\r\n-  const [room, setRoom] = useState<RoomInfo | null>(null);\r\n-  const [peers, setPeers] = useState<Record<string, MediaStream>>({});\r\n-  const [muted, setMuted] = useState(false);\r\n-  const [cameraOff, setCameraOff] = useState(false);\r\n-  const [speakingPeers, setSpeakingPeers] = useState<Record<string, boolean>>({});\r\n-\r\n-  const userInfo: UserInfo = JSON.parse(localStorage.getItem(\"user-info\") || \"{}\");\r\n-\r\n-  // -----------------------------\r\n-  // üé• Start local camera & mic\r\n-  // -----------------------------\r\n   useEffect(() => {\r\n-    let mounted = true;\r\n-\r\n-    (async () => {\r\n+    // simple getUserMedia\r\n+    const start = async () => {\r\n       try {\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        if (!mounted) return stream.getTracks().forEach((t) => t.stop());\r\n-\r\n-        localStreamRef.current = stream;\r\n-\r\n-        // Local speaking detection\r\n-        const audioCtx = new AudioContext();\r\n-        const source = audioCtx.createMediaStreamSource(stream);\r\n-        const analyser = audioCtx.createAnalyser();\r\n-        analyser.fftSize = 512;\r\n-        source.connect(analyser);\r\n-        const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n-\r\n-        const detectSpeaking = () => {\r\n-          analyser.getByteFrequencyData(dataArray);\r\n-          const sum = dataArray.reduce((a, b) => a + b, 0);\r\n-          setSpeakingPeers((prev) => ({ ...prev, local: sum > 2000 }));\r\n-          requestAnimationFrame(detectSpeaking);\r\n-        };\r\n-        detectSpeaking();\r\n-      } catch (err) {\r\n-        console.error(\"üé• Camera error:\", err);\r\n+        const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        setLocalStream(s);\r\n+      } catch (e) {\r\n+        console.error(\"getUserMedia error\", e);\r\n       }\r\n-    })();\r\n-\r\n+    };\r\n+    start();\r\n     return () => {\r\n-      mounted = false;\r\n-      localStreamRef.current?.getTracks().forEach((t) => t.stop());\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n     };\r\n+  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n   }, []);\r\n \r\n-  // -----------------------------\r\n-  // üîó Create Peer Connection\r\n-  // -----------------------------\r\n-  const createPeerConnection = (peerId: string, name?: string) => {\r\n-    if (peerConnections.current[peerId]) return peerConnections.current[peerId].pc;\r\n-    const socket = socketRef.current;\r\n+  useEffect(() => {\r\n+    if (!roomId) return;\r\n+    const user = { name: \"Guest\", country: \"Unknown\", age: \"?\" };\r\n+    joinRoom(roomId, user);\r\n+    joinWebRTCRoom(roomId);\r\n \r\n-    const pc = new RTCPeerConnection({\r\n-      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n-    });\r\n-\r\n-    // Add local tracks\r\n-    localStreamRef.current?.getTracks().forEach((track) => pc.addTrack(track, localStreamRef.current!));\r\n-\r\n-    // ICE Candidate\r\n-    pc.onicecandidate = (e) => {\r\n-      if (e.candidate) socket?.emit(\"room-ice\", { roomId: id, candidate: e.candidate, to: peerId });\r\n+    return () => {\r\n+      leaveRoom(roomId);\r\n+      leaveWebRTCRoom(roomId);\r\n     };\r\n+  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n+  }, [roomId, localStream]);\r\n \r\n-    // Remote Stream\r\n-    pc.ontrack = (e) => {\r\n-      if (!e.streams[0]) return;\r\n-      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-\r\n-      // Remote speaking detection\r\n-      const audioCtx = new AudioContext();\r\n-      const source = audioCtx.createMediaStreamSource(e.streams[0]);\r\n-      const analyser = audioCtx.createAnalyser();\r\n-      analyser.fftSize = 512;\r\n-      source.connect(analyser);\r\n-      const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n-\r\n-      const detectRemoteSpeaking = () => {\r\n-        analyser.getByteFrequencyData(dataArray);\r\n-        const sum = dataArray.reduce((a, b) => a + b, 0);\r\n-        setSpeakingPeers((prev) => ({ ...prev, [peerId]: sum > 2000 }));\r\n-        requestAnimationFrame(detectRemoteSpeaking);\r\n-      };\r\n-      detectRemoteSpeaking();\r\n-    };\r\n-\r\n-    // Connection state\r\n-    pc.onconnectionstatechange = () => {\r\n-      if ([\"failed\", \"disconnected\", \"closed\"].includes(pc.connectionState)) removePeer(peerId);\r\n-    };\r\n-\r\n-    peerConnections.current[peerId] = { pc, name };\r\n-    return pc;\r\n-  };\r\n-\r\n-  const removePeer = (peerId: string) => {\r\n-    peerConnections.current[peerId]?.pc.close();\r\n-    delete peerConnections.current[peerId];\r\n-    setPeers((prev) => {\r\n-      const copy = { ...prev };\r\n-      delete copy[peerId];\r\n-      return copy;\r\n-    });\r\n-    setSpeakingPeers((prev) => {\r\n-      const copy = { ...prev };\r\n-      delete copy[peerId];\r\n-      return copy;\r\n-    });\r\n-  };\r\n-\r\n-  const cleanupAllPeers = () => {\r\n-    Object.keys(peerConnections.current).forEach((pid) => peerConnections.current[pid].pc.close());\r\n-    peerConnections.current = {};\r\n-    setPeers({});\r\n-    setSpeakingPeers({});\r\n-  };\r\n-\r\n-  // -----------------------------\r\n-  // üî• Socket.io Setup\r\n-  // -----------------------------\r\n-  useEffect(() => {\r\n-    if (!id) return;\r\n-    let active = true;\r\n-\r\n-    (async () => {\r\n-      const socket = connectRoomSocket();\r\n-      socketRef.current = socket;\r\n-      socket.emit(\"join-room\", { roomId: id, user: userInfo });\r\n-\r\n-      // Room users update\r\n-      socket.on(\"room-users\", (users: RoomUser[]) => {\r\n-        if (!active) return;\r\n-        setRoom((prev) => ({ ...(prev || {}), users }) as RoomInfo);\r\n-        users.forEach((u) => {\r\n-          if (u.socketId !== socket.id) setTimeout(() => createOfferToPeer(u.socketId, u.userInfo?.name), 80);\r\n-        });\r\n-      });\r\n-\r\n-      // User joined\r\n-      socket.on(\"user-joined\", (payload: RoomUser) => {\r\n-        if (!active || !payload.socketId) return;\r\n-        setRoom((prev) => {\r\n-          const copy = prev ? { ...prev } : { id, name: \"\", topic: \"\", users: [] } as RoomInfo;\r\n-          copy.users = copy.users\r\n-            ? [...copy.users.filter((x) => x.socketId !== payload.socketId), payload]\r\n-            : [payload];\r\n-          return copy;\r\n-        });\r\n-        if (payload.socketId !== socket.id) setTimeout(() => createOfferToPeer(payload.socketId, payload.userInfo?.name), 80);\r\n-      });\r\n-\r\n-      // WebRTC signaling\r\n-      socket.on(\"room-offer\", async ({ from, offer }) => {\r\n-        const pc = createPeerConnection(from);\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n-      });\r\n-\r\n-      socket.on(\"room-answer\", async ({ from, answer }) => {\r\n-        const pc = peerConnections.current[from]?.pc;\r\n-        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-      });\r\n-\r\n-      socket.on(\"room-ice\", ({ from, candidate }) => {\r\n-        const pc = peerConnections.current[from]?.pc;\r\n-        if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});\r\n-      });\r\n-\r\n-      socket.on(\"user-left\", ({ userId }) => {\r\n-        removePeer(userId);\r\n-        setRoom((prev) =>\r\n-          prev ? { ...prev, users: prev.users.filter((u) => u.socketId !== userId) } : prev\r\n-        );\r\n-      });\r\n-\r\n-      return () => {\r\n-        active = false;\r\n-        try {\r\n-          socket.emit(\"leave-room\", { roomId: id, userId: socket.id });\r\n-        } catch {}\r\n-        cleanupAllPeers();\r\n-        disconnectRoomSocket();\r\n-        socketRef.current = null;\r\n-      };\r\n-    })();\r\n-  }, [id]);\r\n-\r\n-  // -----------------------------\r\n-  // üß† Peer Offer Creation\r\n-  // -----------------------------\r\n-  const createOfferToPeer = async (peerId: string, name?: string) => {\r\n-    if (!localStreamRef.current || peerConnections.current[peerId]) return;\r\n-    const pc = createPeerConnection(peerId, name);\r\n-    const offer = await pc.createOffer();\r\n-    await pc.setLocalDescription(offer);\r\n-    socketRef.current?.emit(\"room-offer\", { roomId: id, offer, to: peerId });\r\n-  };\r\n-\r\n-  // -----------------------------\r\n-  // üéõ UI Actions\r\n-  // -----------------------------\r\n-  const toggleMute = () => {\r\n-    if (!localStreamRef.current) return;\r\n-    const newMuted = !muted;\r\n-    localStreamRef.current.getAudioTracks().forEach((track) => (track.enabled = !newMuted));\r\n-    setMuted(newMuted);\r\n-  };\r\n-\r\n-  const toggleCamera = () => {\r\n-    if (!localStreamRef.current) return;\r\n-    const newOff = !cameraOff;\r\n-    localStreamRef.current.getVideoTracks().forEach((track) => (track.enabled = !newOff));\r\n-    setCameraOff(newOff);\r\n-  };\r\n-\r\n-  const leaveRoom = () => {\r\n-    cleanupAllPeers();\r\n-    disconnectRoomSocket();\r\n-    router.push(\"/\");\r\n-  };\r\n-\r\n-  // -----------------------------\r\n-  // Render\r\n-  // -----------------------------\r\n-  if (!localStreamRef.current) return <p>Loading camera...</p>;\r\n-\r\n-  const userStreams = [\r\n-    ...(localStreamRef.current ? [{ id: \"local\", stream: localStreamRef.current, name: userInfo?.name || \"You\", isSpeaking: speakingPeers[\"local\"] }] : []),\r\n-    ...Object.entries(peers).map(([id, stream]) => ({\r\n-      id,\r\n-      stream,\r\n-      name: peerConnections.current[id]?.name || \"Stranger\",\r\n-      isSpeaking: speakingPeers[id],\r\n-    })),\r\n-  ];\r\n-\r\n   return (\r\n-    <div className=\"flex flex-col md:flex-row gap-4 p-4 min-h-screen\">\r\n-      {/* Video Grid */}\r\n-      <div className=\"flex-1\">\r\n-        <VideoGrid localStream={localStreamRef.current} localName={userInfo?.name || \"You\"} remoteStreams={userStreams.filter((u) => u.id !== \"local\")} />\r\n-        <div className=\"flex gap-2 mt-2 justify-end\">\r\n-          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleMute}>\r\n-            {muted ? \"Unmute\" : \"Mute\"}\r\n-          </button>\r\n-          <button className=\"bg-white dark:bg-gray-700 p-2 rounded\" onClick={toggleCamera}>\r\n-            {cameraOff ? \"Camera On\" : \"Camera Off\"}\r\n-          </button>\r\n-          <button className=\"bg-red-500 text-white p-2 rounded\" onClick={leaveRoom}>\r\n-            Leave\r\n-          </button>\r\n-        </div>\r\n+    <div className=\"p-4 grid grid-cols-3 gap-4\">\r\n+      <div className=\"col-span-2\">\r\n+        <RoomVideoGrid localStream={localStream} remoteStreams={remoteStreams} />\r\n       </div>\r\n-\r\n-      {/* Chat Box */}\r\n-      <div className=\"md:w-80 flex-shrink-0\">\r\n-        {socketRef.current && <ChatBox socket={socketRef.current} roomId={id} userName={userInfo?.name || \"You\"} />}\r\n+      <div>\r\n+        <RoomChatBox roomId={roomId} />\r\n       </div>\r\n-\r\n-      {/* Room Info */}\r\n-      {room && (\r\n-        <div className=\"md:w-64 p-4 bg-gray-100 dark:bg-neutral-800 rounded-lg shadow flex-shrink-0\">\r\n-          <h2 className=\"text-lg font-bold\">{room.name}</h2>\r\n-          <p className=\"text-sm text-gray-700 dark:text-gray-300\">{room.topic}</p>\r\n-          {room.description && <p className=\"text-sm text-gray-500 dark:text-gray-400\">{room.description}</p>}\r\n-          <p className=\"mt-2 text-sm font-medium\">Users: {room.users?.length ?? Object.keys(peers).length + 1}</p>\r\n-        </div>\r\n-      )}\r\n     </div>\r\n   );\r\n }\r\n"
                },
                {
                    "date": 1760269320877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,56 +1,68 @@\n-// src/app/rooms/[id]/page.tsx\r\n \"use client\";\r\n-import React, { useEffect, useMemo, useState } from \"react\";\r\n-import { useRouter, useParams } from \"next/navigation\";\r\n-import RoomVideoGrid from \"../../../../features/RoomChat/components/RoomVideoGrid\";\r\n-import RoomChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n-import { useRoomSocket } from \"../../../../features/RoomChat/hooks/useRoomSocket\";\r\n-import { useRoomWebRTC } from \"../../../../features/RoomChat/hooks/useRoomWebRTC\";\r\n \r\n+import React, { useEffect, useState } from \"react\";\r\n+import { useParams } from \"next/navigation\";\r\n+import RoomVideoGrid from \"../../../../features/RoomSystem/components/RoomVideoGrid\";\r\n+import RoomChatBox from \"../../../../features/RoomSystem/components/RoomChatBox\";\r\n+import { useRoomSocket } from \"../../../../features/RoomSystem/hooks/useRoomSocket\";\r\n+import { useRoomWebRTC } from \"../../../../features/RoomSystem/hooks/useRoomWebRTC\";\r\n+\r\n export default function RoomPage() {\r\n   const params = useParams();\r\n   const roomId = params?.id as string;\r\n+\r\n+  // Socket-based room management\r\n   const { joinRoom, leaveRoom } = useRoomSocket();\r\n+\r\n+  // Local media stream\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const { remoteStreams, joinRoom: joinWebRTCRoom, leaveRoom: leaveWebRTCRoom } = useRoomWebRTC(localStream);\r\n \r\n+  // WebRTC hook for multi-user video\r\n+  const { remoteStreams, joinRoom: joinWebRTCRoom, leaveRoom: leaveWebRTCRoom } =\r\n+    useRoomWebRTC(localStream);\r\n+\r\n+  // Initialize local media (camera + mic)\r\n   useEffect(() => {\r\n-    // simple getUserMedia\r\n-    const start = async () => {\r\n+    const startMedia = async () => {\r\n       try {\r\n-        const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        setLocalStream(s);\r\n-      } catch (e) {\r\n-        console.error(\"getUserMedia error\", e);\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n+        });\r\n+        setLocalStream(stream);\r\n+      } catch (err) {\r\n+        console.error(\"getUserMedia error:\", err);\r\n       }\r\n     };\r\n-    start();\r\n+    startMedia();\r\n+\r\n     return () => {\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n+      // Stop all tracks on unmount\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n     };\r\n-  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n   }, []);\r\n \r\n+  // Join room via socket + WebRTC when ready\r\n   useEffect(() => {\r\n     if (!roomId) return;\r\n+\r\n     const user = { name: \"Guest\", country: \"Unknown\", age: \"?\" };\r\n-    joinRoom(roomId, user);\r\n-    joinWebRTCRoom(roomId);\r\n+    joinRoom(roomId, user); // Socket join\r\n+    joinWebRTCRoom(roomId); // WebRTC join\r\n \r\n     return () => {\r\n-      leaveRoom(roomId);\r\n-      leaveWebRTCRoom(roomId);\r\n+      leaveRoom(roomId); // Socket leave\r\n+      leaveWebRTCRoom(); // WebRTC leave\r\n     };\r\n-  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n-  }, [roomId, localStream]);\r\n+  }, [roomId, localStream, joinRoom, leaveRoom, joinWebRTCRoom, leaveWebRTCRoom]);\r\n \r\n   return (\r\n-    <div className=\"p-4 grid grid-cols-3 gap-4\">\r\n-      <div className=\"col-span-2\">\r\n+    <div className=\"p-4 grid grid-cols-3 gap-4 h-screen\">\r\n+      <div className=\"col-span-2 flex flex-col gap-2\">\r\n         <RoomVideoGrid localStream={localStream} remoteStreams={remoteStreams} />\r\n       </div>\r\n-      <div>\r\n+      <div className=\"flex flex-col\">\r\n         <RoomChatBox roomId={roomId} />\r\n       </div>\r\n     </div>\r\n   );\r\n"
                },
                {
                    "date": 1760269376209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n \"use client\";\r\n \r\n import React, { useEffect, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n-import RoomVideoGrid from \"../../../../features/RoomSystem/components/RoomVideoGrid\";\r\n-import RoomChatBox from \"../../../../features/RoomSystem/components/RoomChatBox\";\r\n-import { useRoomSocket } from \"../../../../features/RoomSystem/hooks/useRoomSocket\";\r\n-import { useRoomWebRTC } from \"../../../../features/RoomSystem/hooks/useRoomWebRTC\";\r\n+import RoomVideoGrid from \"../../../../features/RoomChat/components/RoomVideoGrid\";\r\n+import RoomChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n+import { useRoomSocket } from \"../../../../features/RoomChat/hooks/useRoomSocket\";\r\n+import { useRoomWebRTC } from \"../../../../features/RoomChat/hooks/useRoomWebRTC\";\r\n \r\n export default function RoomPage() {\r\n   const params = useParams();\r\n   const roomId = params?.id as string;\r\n"
                },
                {
                    "date": 1760269563807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,10 @@\n import React, { useEffect, useState } from \"react\";\r\n import { useParams } from \"next/navigation\";\r\n import RoomVideoGrid from \"../../../../features/RoomChat/components/RoomVideoGrid\";\r\n import RoomChatBox from \"../../../../features/RoomChat/components/RoomChatBox\";\r\n+import RoomStatusBar from \"../../../../features/RoomChat/components/RoomStatusBar\";\r\n+import RoomParticipants from \"../../../../features/RoomChat/components/RoomParticipants\";\r\n import { useRoomSocket } from \"../../../../features/RoomChat/hooks/useRoomSocket\";\r\n import { useRoomWebRTC } from \"../../../../features/RoomChat/hooks/useRoomWebRTC\";\r\n \r\n export default function RoomPage() {\r\n@@ -56,14 +58,19 @@\n     };\r\n   }, [roomId, localStream, joinRoom, leaveRoom, joinWebRTCRoom, leaveWebRTCRoom]);\r\n \r\n   return (\r\n-    <div className=\"p-4 grid grid-cols-3 gap-4 h-screen\">\r\n+    <div className=\"p-4 h-screen grid grid-cols-3 gap-4\">\r\n+      {/* Left: Video + Status */}\r\n       <div className=\"col-span-2 flex flex-col gap-2\">\r\n+        <RoomStatusBar roomId={roomId} />\r\n         <RoomVideoGrid localStream={localStream} remoteStreams={remoteStreams} />\r\n       </div>\r\n-      <div className=\"flex flex-col\">\r\n+\r\n+      {/* Right: Chat + Participants */}\r\n+      <div className=\"flex flex-col gap-4\">\r\n         <RoomChatBox roomId={roomId} />\r\n+        <RoomParticipants roomId={roomId} />\r\n       </div>\r\n     </div>\r\n   );\r\n }\r\n"
                },
                {
                    "date": 1760276425401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,19 +12,22 @@\n export default function RoomPage() {\r\n   const params = useParams();\r\n   const roomId = params?.id as string;\r\n \r\n-  // Socket-based room management\r\n+  // Socket\r\n   const { joinRoom, leaveRoom } = useRoomSocket();\r\n \r\n-  // Local media stream\r\n+  // Local media\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n+  const [cameraEnabled, setCameraEnabled] = useState(true);\r\n+  const [micEnabled, setMicEnabled] = useState(true);\r\n+  const [mediaError, setMediaError] = useState<string | null>(null);\r\n \r\n-  // WebRTC hook for multi-user video\r\n+  // WebRTC\r\n   const { remoteStreams, joinRoom: joinWebRTCRoom, leaveRoom: leaveWebRTCRoom } =\r\n     useRoomWebRTC(localStream);\r\n \r\n-  // Initialize local media (camera + mic)\r\n+  // Initialize local media\r\n   useEffect(() => {\r\n     const startMedia = async () => {\r\n       try {\r\n         const stream = await navigator.mediaDevices.getUserMedia({\r\n@@ -33,37 +36,71 @@\n         });\r\n         setLocalStream(stream);\r\n       } catch (err) {\r\n         console.error(\"getUserMedia error:\", err);\r\n+        setMediaError(\"Camera/Microphone access denied or unavailable.\");\r\n       }\r\n     };\r\n     startMedia();\r\n \r\n     return () => {\r\n-      // Stop all tracks on unmount\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n     };\r\n   }, []);\r\n \r\n-  // Join room via socket + WebRTC when ready\r\n+  // Join room via socket + WebRTC\r\n   useEffect(() => {\r\n-    if (!roomId) return;\r\n+    if (!roomId || !localStream) return;\r\n \r\n     const user = { name: \"Guest\", country: \"Unknown\", age: \"?\" };\r\n-    joinRoom(roomId, user); // Socket join\r\n-    joinWebRTCRoom(roomId); // WebRTC join\r\n+    joinRoom(roomId, user);\r\n+    joinWebRTCRoom(roomId);\r\n \r\n     return () => {\r\n-      leaveRoom(roomId); // Socket leave\r\n-      leaveWebRTCRoom(); // WebRTC leave\r\n+      leaveRoom(roomId);\r\n+      leaveWebRTCRoom();\r\n     };\r\n   }, [roomId, localStream, joinRoom, leaveRoom, joinWebRTCRoom, leaveWebRTCRoom]);\r\n \r\n+  // Toggle camera\r\n+  const toggleCamera = () => {\r\n+    if (!localStream) return;\r\n+    localStream.getVideoTracks().forEach((track) => (track.enabled = !cameraEnabled));\r\n+    setCameraEnabled(!cameraEnabled);\r\n+  };\r\n+\r\n+  // Toggle microphone\r\n+  const toggleMic = () => {\r\n+    if (!localStream) return;\r\n+    localStream.getAudioTracks().forEach((track) => (track.enabled = !micEnabled));\r\n+    setMicEnabled(!micEnabled);\r\n+  };\r\n+\r\n+  if (mediaError)\r\n+    return (\r\n+      <div className=\"flex items-center justify-center h-screen text-red-500 font-semibold\">\r\n+        {mediaError}\r\n+      </div>\r\n+    );\r\n+\r\n+  if (!localStream)\r\n+    return (\r\n+      <div className=\"flex items-center justify-center h-screen text-gray-600 font-medium\">\r\n+        Waiting for camera/mic access...\r\n+      </div>\r\n+    );\r\n+\r\n   return (\r\n-    <div className=\"p-4 h-screen grid grid-cols-3 gap-4\">\r\n+    <div className=\"p-2 h-screen grid grid-cols-1 md:grid-cols-3 gap-4\">\r\n       {/* Left: Video + Status */}\r\n-      <div className=\"col-span-2 flex flex-col gap-2\">\r\n-        <RoomStatusBar roomId={roomId} />\r\n+      <div className=\"col-span-1 md:col-span-2 flex flex-col gap-2\">\r\n+        <RoomStatusBar\r\n+          roomId={roomId}\r\n+          cameraEnabled={cameraEnabled}\r\n+          micEnabled={micEnabled}\r\n+          onToggleCamera={toggleCamera}\r\n+          onToggleMic={toggleMic}\r\n+        />\r\n         <RoomVideoGrid localStream={localStream} remoteStreams={remoteStreams} />\r\n       </div>\r\n \r\n       {/* Right: Chat + Participants */}\r\n"
                },
                {
                    "date": 1760280251826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,15 +7,16 @@\n import RoomStatusBar from \"../../../../features/RoomChat/components/RoomStatusBar\";\r\n import RoomParticipants from \"../../../../features/RoomChat/components/RoomParticipants\";\r\n import { useRoomSocket } from \"../../../../features/RoomChat/hooks/useRoomSocket\";\r\n import { useRoomWebRTC } from \"../../../../features/RoomChat/hooks/useRoomWebRTC\";\r\n+import type { Participant } from \"../../../../features/RoomChat/utils/roomTypes\";\r\n \r\n export default function RoomPage() {\r\n   const params = useParams();\r\n   const roomId = params?.id as string;\r\n \r\n   // Socket\r\n-  const { joinRoom, leaveRoom } = useRoomSocket();\r\n+  const { joinRoom, leaveRoom, socket } = useRoomSocket();\r\n \r\n   // Local media\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const [cameraEnabled, setCameraEnabled] = useState(true);\r\n@@ -48,19 +49,28 @@\n   }, []);\r\n \r\n   // Join room via socket + WebRTC\r\n   useEffect(() => {\r\n-    if (!roomId || !localStream) return;\r\n+    if (!roomId || !localStream || !socket) return;\r\n \r\n-    const user = { name: \"Guest\", country: \"Unknown\", age: \"?\" };\r\n+    // Build participant object with socketId\r\n+    const user: Participant = {\r\n+      socketId: socket.id,\r\n+      userInfo: {\r\n+        name: \"Guest\",\r\n+        country: \"Unknown\",\r\n+        age: \"?\",\r\n+      },\r\n+    };\r\n+\r\n     joinRoom(roomId, user);\r\n     joinWebRTCRoom(roomId);\r\n \r\n     return () => {\r\n-      leaveRoom(roomId);\r\n+      leaveRoom(roomId, user);\r\n       leaveWebRTCRoom();\r\n     };\r\n-  }, [roomId, localStream, joinRoom, leaveRoom, joinWebRTCRoom, leaveWebRTCRoom]);\r\n+  }, [roomId, localStream, socket, joinRoom, leaveRoom, joinWebRTCRoom, leaveWebRTCRoom]);\r\n \r\n   // Toggle camera\r\n   const toggleCamera = () => {\r\n     if (!localStream) return;\r\n"
                },
                {
                    "date": 1760280454392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n     if (!roomId || !localStream || !socket) return;\r\n \r\n     // Build participant object with socketId\r\n     const user: Participant = {\r\n-      socketId: socket.id,\r\n+      socketId: socket.id ?? \"\",\r\n       userInfo: {\r\n         name: \"Guest\",\r\n         country: \"Unknown\",\r\n         age: \"?\",\r\n"
                }
            ],
            "date": 1758888488063,
            "name": "Commit-0",
            "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { useParams } from \"next/navigation\";\r\nimport io, { Socket } from \"socket.io-client\";\r\n\r\n// ‚ö°Ô∏è Adjust to your signaling server endpoint\r\nconst SOCKET_URL =\r\n  process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n\r\ninterface RoomInfo {\r\n  id: string;\r\n  name: string;\r\n  topic: string;\r\n  description: string;\r\n  users: string[];\r\n}\r\n\r\ninterface ChatMessage {\r\n  id: string;\r\n  user: string;\r\n  text: string;\r\n}\r\n\r\nexport default function RoomPage() {\r\n  const { id } = useParams<{ id: string }>();\r\n  const socketRef = useRef<Socket | null>(null);\r\n  const localVideoRef = useRef<HTMLVideoElement>(null);\r\n\r\n  const [room, setRoom] = useState<RoomInfo | null>(null);\r\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\r\n  const [input, setInput] = useState(\"\");\r\n  const [peers, setPeers] = useState<{ [peerId: string]: MediaStream }>({});\r\n\r\n  // üü¢ Join Room on mount\r\n  useEffect(() => {\r\n    const socket = io(SOCKET_URL);\r\n    socketRef.current = socket;\r\n\r\n    socket.emit(\"join-room\", { roomId: id });\r\n\r\n    // ‚úÖ Room info updates\r\n    socket.on(\"room-update\", (data: RoomInfo) => setRoom(data));\r\n\r\n    // ‚úÖ Chat messages\r\n    socket.on(\"room-message\", (msg: ChatMessage) =>\r\n      setMessages((prev) => [...prev, msg])\r\n    );\r\n\r\n    // ‚úÖ New user joins (start WebRTC)\r\n    socket.on(\"user-joined\", async ({ userId }: { userId: string }) => {\r\n      if (!localVideoRef.current) return;\r\n\r\n      const pc = createPeerConnection(socket, userId);\r\n\r\n      // Add local stream to connection\r\n      if (localVideoRef.current.srcObject) {\r\n        (localVideoRef.current.srcObject as MediaStream)\r\n          .getTracks()\r\n          .forEach((track) => pc.addTrack(track));\r\n      }\r\n\r\n      const offer = await pc.createOffer();\r\n      await pc.setLocalDescription(offer);\r\n      socket.emit(\"room-offer\", { roomId: id, offer, to: userId });\r\n    });\r\n\r\n    // ‚úÖ Handle incoming offer\r\n    socket.on(\r\n      \"room-offer\",\r\n      async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n        const pc = createPeerConnection(socket, from);\r\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n\r\n        if (localVideoRef.current?.srcObject) {\r\n          (localVideoRef.current.srcObject as MediaStream)\r\n            .getTracks()\r\n            .forEach((track) => pc.addTrack(track));\r\n        }\r\n\r\n        const answer = await pc.createAnswer();\r\n        await pc.setLocalDescription(answer);\r\n        socket.emit(\"room-answer\", { roomId: id, answer, to: from });\r\n      }\r\n    );\r\n\r\n    // ‚úÖ Handle answer\r\n    socket.on(\r\n      \"room-answer\",\r\n      async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n        const pc = peerConnections[from];\r\n        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n      }\r\n    );\r\n\r\n    // ‚úÖ Handle ICE candidates\r\n    socket.on(\r\n      \"room-ice\",\r\n      ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n        const pc = peerConnections[from];\r\n        if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n      }\r\n    );\r\n\r\n    // ‚úÖ User left\r\n    socket.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n      const pc = peerConnections[userId];\r\n      if (pc) pc.close();\r\n      delete peerConnections[userId];\r\n      setPeers((prev) => {\r\n        const updated = { ...prev };\r\n        delete updated[userId];\r\n        return updated;\r\n      });\r\n    });\r\n\r\n    // üî¥ Leave room on unmount\r\n    return () => {\r\n      socket.emit(\"leave-room\", { roomId: id });\r\n      socket.disconnect();\r\n      Object.values(peerConnections).forEach((pc) => pc.close());\r\n    };\r\n  }, [id]);\r\n\r\n  // üé• Start local camera\r\n  useEffect(() => {\r\n    (async () => {\r\n      try {\r\n        const stream = await navigator.mediaDevices.getUserMedia({\r\n          video: true,\r\n          audio: true,\r\n        });\r\n        if (localVideoRef.current) {\r\n          localVideoRef.current.srcObject = stream;\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Camera error\", err);\r\n      }\r\n    })();\r\n  }, []);\r\n\r\n  // üí¨ Send chat message\r\n  const sendMessage = () => {\r\n    if (!input.trim() || !socketRef.current) return;\r\n    socketRef.current.emit(\"room-message\", {\r\n      roomId: id,\r\n      text: input.trim(),\r\n    });\r\n    setInput(\"\");\r\n  };\r\n\r\n  // ======= WebRTC Helper =======\r\n  const peerConnections: { [peerId: string]: RTCPeerConnection } = {};\r\n  const createPeerConnection = (socket: Socket, peerId: string) => {\r\n    const pc = new RTCPeerConnection({\r\n      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n    });\r\n\r\n    pc.onicecandidate = (e) => {\r\n      if (e.candidate) {\r\n        socket.emit(\"room-ice\", {\r\n          roomId: id,\r\n          candidate: e.candidate,\r\n          to: peerId,\r\n        });\r\n      }\r\n    };\r\n\r\n    pc.ontrack = (e) => {\r\n      setPeers((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n    };\r\n\r\n    peerConnections[peerId] = pc;\r\n    return pc;\r\n  };\r\n\r\n  return (\r\n    <div className=\"p-4 space-y-4\">\r\n      {room ? (\r\n        <div className=\"bg-gray-100 p-4 rounded-lg shadow\">\r\n          <h1 className=\"text-2xl font-bold\">{room.name}</h1>\r\n          <p className=\"text-sm text-gray-700\">{room.topic}</p>\r\n          <p className=\"text-sm text-gray-500\">{room.description}</p>\r\n          <p className=\"mt-2 text-sm font-medium\">\r\n            Users in Room: {room.users.length}\r\n          </p>\r\n        </div>\r\n      ) : (\r\n        <p>Loading room...</p>\r\n      )}\r\n\r\n      {/* Video Grid */}\r\n      <div className=\"grid grid-cols-2 md:grid-cols-3 gap-4\">\r\n        <video\r\n          ref={localVideoRef}\r\n          autoPlay\r\n          playsInline\r\n          muted\r\n          className=\"w-full h-48 bg-black rounded-lg\"\r\n        />\r\n        {Object.entries(peers).map(([peerId, stream]) => (\r\n          <RemoteVideo key={peerId} stream={stream} />\r\n        ))}\r\n      </div>\r\n\r\n      {/* Chat */}\r\n      <div className=\"bg-white p-4 rounded-lg shadow max-w-lg\">\r\n        <div className=\"h-48 overflow-y-auto mb-2 border p-2\">\r\n          {messages.map((m) => (\r\n            <p key={m.id}>\r\n              <strong>{m.user}:</strong> {m.text}\r\n            </p>\r\n          ))}\r\n        </div>\r\n        <div className=\"flex gap-2\">\r\n          <input\r\n            className=\"flex-1 border p-2 rounded\"\r\n            placeholder=\"Type a message...\"\r\n            value={input}\r\n            onChange={(e) => setInput(e.target.value)}\r\n            onKeyDown={(e) => e.key === \"Enter\" && sendMessage()}\r\n          />\r\n          <button\r\n            onClick={sendMessage}\r\n            className=\"bg-blue-500 text-white px-4 py-2 rounded\"\r\n          >\r\n            Send\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ Component for remote streams\r\nfunction RemoteVideo({ stream }: { stream: MediaStream }) {\r\n  const ref = useRef<HTMLVideoElement>(null);\r\n  useEffect(() => {\r\n    if (ref.current) ref.current.srcObject = stream;\r\n  }, [stream]);\r\n  return (\r\n    <video\r\n      ref={ref}\r\n      autoPlay\r\n      playsInline\r\n      className=\"w-full h-48 bg-black rounded-lg\"\r\n    />\r\n  );\r\n}\r\n"
        }
    ]
}