{
    "sourceFile": "features/RoomChat/hooks/useRoomWebRTC.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1758898670717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758906633254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,84 @@\n+import { useEffect, useRef, useState } from \"react\";\r\n+import { sendRoomIce } from \"../services/roomSocketService\";\r\n+\r\n+interface PeersMap {\r\n+  [peerId: string]: RTCPeerConnection;\r\n+}\r\n+\r\n+export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n+  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const peerConnections = useRef<PeersMap>({});\r\n+\r\n+  /**\r\n+   * Create a new RTCPeerConnection for a given peer\r\n+   */\r\n+  const createPeerConnection = (peerId: string) => {\r\n+    if (!localStream) throw new Error(\"Local stream not available\");\r\n+\r\n+    const pc = new RTCPeerConnection({\r\n+      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+    });\r\n+\r\n+    // ‚úÖ Add local tracks\r\n+    localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n+\r\n+    // ‚úÖ Handle remote tracks\r\n+    pc.ontrack = (event) => {\r\n+      setRemoteStreams((prev) => ({\r\n+        ...prev,\r\n+        [peerId]: event.streams[0],\r\n+      }));\r\n+    };\r\n+\r\n+    // ‚úÖ Handle ICE candidates\r\n+    pc.onicecandidate = (event) => {\r\n+      if (event.candidate) {\r\n+        sendRoomIce(peerId, roomId, event.candidate);\r\n+      }\r\n+    };\r\n+\r\n+    peerConnections.current[peerId] = pc;\r\n+    return pc;\r\n+  };\r\n+\r\n+  /**\r\n+   * Remove a specific peer and clean up its connection\r\n+   */\r\n+  const removePeerConnection = (peerId: string) => {\r\n+    const pc = peerConnections.current[peerId];\r\n+    if (pc) {\r\n+      pc.close();\r\n+      delete peerConnections.current[peerId];\r\n+      setRemoteStreams((prev) => {\r\n+        const updated = { ...prev };\r\n+        delete updated[peerId];\r\n+        return updated;\r\n+      });\r\n+    }\r\n+  };\r\n+\r\n+  /**\r\n+   * Close all peer connections\r\n+   */\r\n+  const closeAllPeers = () => {\r\n+    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+    peerConnections.current = {};\r\n+    setRemoteStreams({});\r\n+  };\r\n+\r\n+  // ‚úÖ Automatically close connections when hook is unmounted\r\n+  useEffect(() => {\r\n+    return () => {\r\n+      closeAllPeers();\r\n+    };\r\n+    // roomId is included so peers reset if user switches rooms\r\n+  }, [roomId]);\r\n+\r\n+  return {\r\n+    remoteStreams,\r\n+    peerConnections,\r\n+    createPeerConnection,\r\n+    removePeerConnection,\r\n+    closeAllPeers,\r\n+  };\r\n+}\r\n"
                },
                {
                    "date": 1758985313463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,26 +12,26 @@\n   /**\r\n    * Create a new RTCPeerConnection for a given peer\r\n    */\r\n   const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) throw new Error(\"Local stream not available\");\r\n+    if (!localStream) return null;\r\n \r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n-    // ‚úÖ Add local tracks\r\n+    // Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // ‚úÖ Handle remote tracks\r\n+    // Handle remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // ‚úÖ Handle ICE candidates\r\n+    // Handle ICE candidates\r\n     pc.onicecandidate = (event) => {\r\n       if (event.candidate) {\r\n         sendRoomIce(peerId, roomId, event.candidate);\r\n       }\r\n@@ -41,9 +41,9 @@\n     return pc;\r\n   };\r\n \r\n   /**\r\n-   * Remove a specific peer and clean up its connection\r\n+   * Remove a peer connection\r\n    */\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n@@ -65,61 +65,17 @@\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  // ‚úÖ Automatically close connections when hook is unmounted\r\n+  // Cleanup when room changes or component unmounts\r\n   useEffect(() => {\r\n-    return () => {\r\n-      closeAllPeers();\r\n-    };\r\n-    // roomId is included so peers reset if user switches rooms\r\n+    return () => closeAllPeers();\r\n   }, [roomId]);\r\n \r\n   return {\r\n     remoteStreams,\r\n-    peerConnections,\r\n+    peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n     removePeerConnection,\r\n     closeAllPeers,\r\n   };\r\n }\r\n-import { useEffect, useRef, useState } from \"react\";\r\n-import { sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n-\r\n-interface PeersMap {\r\n-  [peerId: string]: RTCPeerConnection;\r\n-}\r\n-\r\n-export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<{ [peerId: string]: MediaStream }>({});\r\n-  const peerConnections = useRef<PeersMap>({});\r\n-\r\n-  const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) throw new Error(\"Local stream not available\");\r\n-\r\n-    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n-\r\n-    // Add local tracks\r\n-    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n-\r\n-    // Handle remote tracks\r\n-    pc.ontrack = (e) => {\r\n-      setRemoteStreams((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-    };\r\n-\r\n-    // ICE candidates\r\n-    pc.onicecandidate = (e) => {\r\n-      if (e.candidate) sendRoomIce(peerId, roomId, e.candidate);\r\n-    };\r\n-\r\n-    peerConnections.current[peerId] = pc;\r\n-    return pc;\r\n-  };\r\n-\r\n-  const closePeerConnections = () => {\r\n-    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n-    peerConnections.current = {};\r\n-    setRemoteStreams({});\r\n-  };\r\n-\r\n-  return { remoteStreams, peerConnections, createPeerConnection, closePeerConnections };\r\n-}\r\n"
                },
                {
                    "date": 1760158905026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,50 +1,50 @@\n import { useEffect, useRef, useState } from \"react\";\r\n-import { sendRoomIce } from \"../services/roomSocketService\";\r\n+import { getRoomSocket, sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n \r\n+interface RemoteStreamsMap {\r\n+  [peerId: string]: MediaStream;\r\n+}\r\n+\r\n export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsMap>({});\r\n   const peerConnections = useRef<PeersMap>({});\r\n+  const socket = getRoomSocket();\r\n \r\n-  /**\r\n-   * Create a new RTCPeerConnection for a given peer\r\n-   */\r\n+  /** ---- Create a new peer connection ---- */\r\n   const createPeerConnection = (peerId: string) => {\r\n     if (!localStream) return null;\r\n+    if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n \r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n     // Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // Handle remote tracks\r\n+    // Remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // Handle ICE candidates\r\n+    // ICE candidates\r\n     pc.onicecandidate = (event) => {\r\n-      if (event.candidate) {\r\n-        sendRoomIce(peerId, roomId, event.candidate);\r\n-      }\r\n+      if (event.candidate) sendRoomIce(peerId, roomId, event.candidate);\r\n     };\r\n \r\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n-  /**\r\n-   * Remove a peer connection\r\n-   */\r\n+  /** ---- Remove a peer connection ---- */\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n       pc.close();\r\n@@ -56,22 +56,56 @@\n       });\r\n     }\r\n   };\r\n \r\n-  /**\r\n-   * Close all peer connections\r\n-   */\r\n+  /** ---- Close all peers ---- */\r\n   const closeAllPeers = () => {\r\n     Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  // Cleanup when room changes or component unmounts\r\n+  /** ---- Socket listeners ---- */\r\n   useEffect(() => {\r\n-    return () => closeAllPeers();\r\n-  }, [roomId]);\r\n+    if (!socket || !roomId) return;\r\n \r\n+    // When a new offer is received\r\n+    const handleOffer = async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n+      const pc = createPeerConnection(from);\r\n+      if (!pc) return;\r\n+\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      sendRoomAnswer(from, roomId, answer);\r\n+    };\r\n+\r\n+    // When an answer is received\r\n+    const handleAnswer = async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (!pc) return;\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    };\r\n+\r\n+    // When ICE candidate is received\r\n+    const handleIce = async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (!pc || !candidate) return;\r\n+      await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    };\r\n+\r\n+    socket.on(\"room-offer\", handleOffer);\r\n+    socket.on(\"room-answer\", handleAnswer);\r\n+    socket.on(\"room-ice\", handleIce);\r\n+\r\n+    return () => {\r\n+      socket.off(\"room-offer\", handleOffer);\r\n+      socket.off(\"room-answer\", handleAnswer);\r\n+      socket.off(\"room-ice\", handleIce);\r\n+      closeAllPeers();\r\n+    };\r\n+  }, [socket, roomId, localStream]);\r\n+\r\n   return {\r\n     remoteStreams,\r\n     peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n"
                },
                {
                    "date": 1760191714043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,11 @@\n import { useEffect, useRef, useState } from \"react\";\r\n-import { getRoomSocket, sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n+import {\r\n+  getRoomSocket,\r\n+  sendRoomOffer,\r\n+  sendRoomAnswer,\r\n+  sendRoomIce,\r\n+} from \"../services/roomSocketService\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n@@ -13,38 +18,69 @@\n   const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsMap>({});\r\n   const peerConnections = useRef<PeersMap>({});\r\n   const socket = getRoomSocket();\r\n \r\n-  /** ---- Create a new peer connection ---- */\r\n-  const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) return null;\r\n+  // --------------------------------------------------------------------\r\n+  // üß© Helper: Create PeerConnection\r\n+  // --------------------------------------------------------------------\r\n+  const createPeerConnection = (peerId: string): RTCPeerConnection | null => {\r\n+    if (!localStream) {\r\n+      console.warn(\"‚ö†Ô∏è Cannot create PeerConnection: localStream missing\");\r\n+      return null;\r\n+    }\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n \r\n     const pc = new RTCPeerConnection({\r\n-      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+      iceServers: [\r\n+        { urls: \"stun:stun.l.google.com:19302\" },\r\n+        { urls: \"stun:stun1.l.google.com:19302\" },\r\n+      ],\r\n     });\r\n \r\n-    // Add local tracks\r\n+    // üîä Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // Remote tracks\r\n+    // üéß Handle remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // ICE candidates\r\n+    // ‚ùÑÔ∏è Handle ICE candidate generation\r\n     pc.onicecandidate = (event) => {\r\n-      if (event.candidate) sendRoomIce(peerId, roomId, event.candidate);\r\n+      if (event.candidate) {\r\n+        sendRoomIce(peerId, roomId, event.candidate);\r\n+      }\r\n     };\r\n \r\n+    // üîÅ Handle renegotiation needed\r\n+    pc.onnegotiationneeded = async () => {\r\n+      try {\r\n+        const offer = await pc.createOffer();\r\n+        await pc.setLocalDescription(offer);\r\n+        sendRoomOffer(peerId, roomId, offer);\r\n+      } catch (err) {\r\n+        console.error(\"‚ùå Renegotiation failed:\", err);\r\n+      }\r\n+    };\r\n+\r\n+    // üßπ Cleanup on connection state change\r\n+    pc.onconnectionstatechange = () => {\r\n+      if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\") {\r\n+        console.warn(`üíî Peer ${peerId} disconnected`);\r\n+        removePeerConnection(peerId);\r\n+      }\r\n+    };\r\n+\r\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n-  /** ---- Remove a peer connection ---- */\r\n+  // --------------------------------------------------------------------\r\n+  // üßπ Remove specific peer connection\r\n+  // --------------------------------------------------------------------\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n       pc.close();\r\n@@ -56,60 +92,109 @@\n       });\r\n     }\r\n   };\r\n \r\n-  /** ---- Close all peers ---- */\r\n+  // --------------------------------------------------------------------\r\n+  // üö™ Close all peer connections\r\n+  // --------------------------------------------------------------------\r\n   const closeAllPeers = () => {\r\n     Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  /** ---- Socket listeners ---- */\r\n+  // --------------------------------------------------------------------\r\n+  // üì° Socket Listeners (Offers, Answers, ICE)\r\n+  // --------------------------------------------------------------------\r\n   useEffect(() => {\r\n     if (!socket || !roomId) return;\r\n \r\n-    // When a new offer is received\r\n-    const handleOffer = async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-      const pc = createPeerConnection(from);\r\n-      if (!pc) return;\r\n-\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      const answer = await pc.createAnswer();\r\n-      await pc.setLocalDescription(answer);\r\n-      sendRoomAnswer(from, roomId, answer);\r\n+    // --- Handle incoming offer ---\r\n+    const handleOffer = async ({\r\n+      from,\r\n+      offer,\r\n+    }: {\r\n+      from: string;\r\n+      offer: RTCSessionDescriptionInit;\r\n+    }) => {\r\n+      try {\r\n+        const pc = createPeerConnection(from);\r\n+        if (!pc) return;\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        sendRoomAnswer(from, roomId, answer);\r\n+      } catch (err) {\r\n+        console.error(\"‚ùå Error handling offer:\", err);\r\n+      }\r\n     };\r\n \r\n-    // When an answer is received\r\n-    const handleAnswer = async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-      const pc = peerConnections.current[from];\r\n-      if (!pc) return;\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    // --- Handle incoming answer ---\r\n+    const handleAnswer = async ({\r\n+      from,\r\n+      answer,\r\n+    }: {\r\n+      from: string;\r\n+      answer: RTCSessionDescriptionInit;\r\n+    }) => {\r\n+      try {\r\n+        const pc = peerConnections.current[from];\r\n+        if (!pc) return;\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+      } catch (err) {\r\n+        console.error(\"‚ùå Error setting remote description (answer):\", err);\r\n+      }\r\n     };\r\n \r\n-    // When ICE candidate is received\r\n-    const handleIce = async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-      const pc = peerConnections.current[from];\r\n-      if (!pc || !candidate) return;\r\n-      await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    // --- Handle incoming ICE candidates ---\r\n+    const handleIce = async ({\r\n+      from,\r\n+      candidate,\r\n+    }: {\r\n+      from: string;\r\n+      candidate: RTCIceCandidateInit;\r\n+    }) => {\r\n+      try {\r\n+        const pc = peerConnections.current[from];\r\n+        if (pc && candidate) {\r\n+          await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+        }\r\n+      } catch (err) {\r\n+        console.error(\"‚ùå Error adding ICE candidate:\", err);\r\n+      }\r\n     };\r\n \r\n+    // ‚úÖ Attach socket listeners\r\n     socket.on(\"room-offer\", handleOffer);\r\n     socket.on(\"room-answer\", handleAnswer);\r\n     socket.on(\"room-ice\", handleIce);\r\n \r\n+    // üßπ Cleanup on unmount or room change\r\n     return () => {\r\n       socket.off(\"room-offer\", handleOffer);\r\n       socket.off(\"room-answer\", handleAnswer);\r\n       socket.off(\"room-ice\", handleIce);\r\n       closeAllPeers();\r\n     };\r\n   }, [socket, roomId, localStream]);\r\n \r\n+  // --------------------------------------------------------------------\r\n+  // üéôÔ∏è Control utilities\r\n+  // --------------------------------------------------------------------\r\n+  const toggleAudio = (enabled: boolean) => {\r\n+    localStream?.getAudioTracks().forEach((track) => (track.enabled = enabled));\r\n+  };\r\n+\r\n+  const toggleVideo = (enabled: boolean) => {\r\n+    localStream?.getVideoTracks().forEach((track) => (track.enabled = enabled));\r\n+  };\r\n+\r\n   return {\r\n     remoteStreams,\r\n     peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n     removePeerConnection,\r\n     closeAllPeers,\r\n+    toggleAudio,\r\n+    toggleVideo,\r\n   };\r\n }\r\n"
                },
                {
                    "date": 1760246329995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,16 +53,21 @@\n         sendRoomIce(peerId, roomId, event.candidate);\r\n       }\r\n     };\r\n \r\n-    // üîÅ Handle renegotiation needed\r\n+    // üîÅ Handle renegotiation needed (debounced)\r\n+    let makingOffer = false;\r\n     pc.onnegotiationneeded = async () => {\r\n       try {\r\n+        if (makingOffer) return;\r\n+        makingOffer = true;\r\n         const offer = await pc.createOffer();\r\n         await pc.setLocalDescription(offer);\r\n         sendRoomOffer(peerId, roomId, offer);\r\n       } catch (err) {\r\n         console.error(\"‚ùå Renegotiation failed:\", err);\r\n+      } finally {\r\n+        makingOffer = false;\r\n       }\r\n     };\r\n \r\n     // üßπ Cleanup on connection state change\r\n"
                }
            ],
            "date": 1758898670716,
            "name": "Commit-0",
            "content": "import { useEffect, useRef, useState } from \"react\";\r\nimport { sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n\r\ninterface PeersMap {\r\n  [peerId: string]: RTCPeerConnection;\r\n}\r\n\r\nexport default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n  const [remoteStreams, setRemoteStreams] = useState<{ [peerId: string]: MediaStream }>({});\r\n  const peerConnections = useRef<PeersMap>({});\r\n\r\n  const createPeerConnection = (peerId: string) => {\r\n    if (!localStream) throw new Error(\"Local stream not available\");\r\n\r\n    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n\r\n    // Add local tracks\r\n    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n\r\n    // Handle remote tracks\r\n    pc.ontrack = (e) => {\r\n      setRemoteStreams((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n    };\r\n\r\n    // ICE candidates\r\n    pc.onicecandidate = (e) => {\r\n      if (e.candidate) sendRoomIce(peerId, roomId, e.candidate);\r\n    };\r\n\r\n    peerConnections.current[peerId] = pc;\r\n    return pc;\r\n  };\r\n\r\n  const closePeerConnections = () => {\r\n    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n    peerConnections.current = {};\r\n    setRemoteStreams({});\r\n  };\r\n\r\n  return { remoteStreams, peerConnections, createPeerConnection, closePeerConnections };\r\n}\r\n"
        }
    ]
}