{
    "sourceFile": "features/RoomChat/hooks/useRoomWebRTC.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1758898670717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758906633254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,84 @@\n+import { useEffect, useRef, useState } from \"react\";\r\n+import { sendRoomIce } from \"../services/roomSocketService\";\r\n+\r\n+interface PeersMap {\r\n+  [peerId: string]: RTCPeerConnection;\r\n+}\r\n+\r\n+export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n+  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const peerConnections = useRef<PeersMap>({});\r\n+\r\n+  /**\r\n+   * Create a new RTCPeerConnection for a given peer\r\n+   */\r\n+  const createPeerConnection = (peerId: string) => {\r\n+    if (!localStream) throw new Error(\"Local stream not available\");\r\n+\r\n+    const pc = new RTCPeerConnection({\r\n+      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+    });\r\n+\r\n+    // ✅ Add local tracks\r\n+    localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n+\r\n+    // ✅ Handle remote tracks\r\n+    pc.ontrack = (event) => {\r\n+      setRemoteStreams((prev) => ({\r\n+        ...prev,\r\n+        [peerId]: event.streams[0],\r\n+      }));\r\n+    };\r\n+\r\n+    // ✅ Handle ICE candidates\r\n+    pc.onicecandidate = (event) => {\r\n+      if (event.candidate) {\r\n+        sendRoomIce(peerId, roomId, event.candidate);\r\n+      }\r\n+    };\r\n+\r\n+    peerConnections.current[peerId] = pc;\r\n+    return pc;\r\n+  };\r\n+\r\n+  /**\r\n+   * Remove a specific peer and clean up its connection\r\n+   */\r\n+  const removePeerConnection = (peerId: string) => {\r\n+    const pc = peerConnections.current[peerId];\r\n+    if (pc) {\r\n+      pc.close();\r\n+      delete peerConnections.current[peerId];\r\n+      setRemoteStreams((prev) => {\r\n+        const updated = { ...prev };\r\n+        delete updated[peerId];\r\n+        return updated;\r\n+      });\r\n+    }\r\n+  };\r\n+\r\n+  /**\r\n+   * Close all peer connections\r\n+   */\r\n+  const closeAllPeers = () => {\r\n+    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+    peerConnections.current = {};\r\n+    setRemoteStreams({});\r\n+  };\r\n+\r\n+  // ✅ Automatically close connections when hook is unmounted\r\n+  useEffect(() => {\r\n+    return () => {\r\n+      closeAllPeers();\r\n+    };\r\n+    // roomId is included so peers reset if user switches rooms\r\n+  }, [roomId]);\r\n+\r\n+  return {\r\n+    remoteStreams,\r\n+    peerConnections,\r\n+    createPeerConnection,\r\n+    removePeerConnection,\r\n+    closeAllPeers,\r\n+  };\r\n+}\r\n"
                },
                {
                    "date": 1758985313463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,26 +12,26 @@\n   /**\r\n    * Create a new RTCPeerConnection for a given peer\r\n    */\r\n   const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) throw new Error(\"Local stream not available\");\r\n+    if (!localStream) return null;\r\n \r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n-    // ✅ Add local tracks\r\n+    // Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // ✅ Handle remote tracks\r\n+    // Handle remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // ✅ Handle ICE candidates\r\n+    // Handle ICE candidates\r\n     pc.onicecandidate = (event) => {\r\n       if (event.candidate) {\r\n         sendRoomIce(peerId, roomId, event.candidate);\r\n       }\r\n@@ -41,9 +41,9 @@\n     return pc;\r\n   };\r\n \r\n   /**\r\n-   * Remove a specific peer and clean up its connection\r\n+   * Remove a peer connection\r\n    */\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n@@ -65,61 +65,17 @@\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  // ✅ Automatically close connections when hook is unmounted\r\n+  // Cleanup when room changes or component unmounts\r\n   useEffect(() => {\r\n-    return () => {\r\n-      closeAllPeers();\r\n-    };\r\n-    // roomId is included so peers reset if user switches rooms\r\n+    return () => closeAllPeers();\r\n   }, [roomId]);\r\n \r\n   return {\r\n     remoteStreams,\r\n-    peerConnections,\r\n+    peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n     removePeerConnection,\r\n     closeAllPeers,\r\n   };\r\n }\r\n-import { useEffect, useRef, useState } from \"react\";\r\n-import { sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n-\r\n-interface PeersMap {\r\n-  [peerId: string]: RTCPeerConnection;\r\n-}\r\n-\r\n-export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<{ [peerId: string]: MediaStream }>({});\r\n-  const peerConnections = useRef<PeersMap>({});\r\n-\r\n-  const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) throw new Error(\"Local stream not available\");\r\n-\r\n-    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n-\r\n-    // Add local tracks\r\n-    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n-\r\n-    // Handle remote tracks\r\n-    pc.ontrack = (e) => {\r\n-      setRemoteStreams((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-    };\r\n-\r\n-    // ICE candidates\r\n-    pc.onicecandidate = (e) => {\r\n-      if (e.candidate) sendRoomIce(peerId, roomId, e.candidate);\r\n-    };\r\n-\r\n-    peerConnections.current[peerId] = pc;\r\n-    return pc;\r\n-  };\r\n-\r\n-  const closePeerConnections = () => {\r\n-    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n-    peerConnections.current = {};\r\n-    setRemoteStreams({});\r\n-  };\r\n-\r\n-  return { remoteStreams, peerConnections, createPeerConnection, closePeerConnections };\r\n-}\r\n"
                },
                {
                    "date": 1760158905026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,50 +1,50 @@\n import { useEffect, useRef, useState } from \"react\";\r\n-import { sendRoomIce } from \"../services/roomSocketService\";\r\n+import { getRoomSocket, sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n \r\n+interface RemoteStreamsMap {\r\n+  [peerId: string]: MediaStream;\r\n+}\r\n+\r\n export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsMap>({});\r\n   const peerConnections = useRef<PeersMap>({});\r\n+  const socket = getRoomSocket();\r\n \r\n-  /**\r\n-   * Create a new RTCPeerConnection for a given peer\r\n-   */\r\n+  /** ---- Create a new peer connection ---- */\r\n   const createPeerConnection = (peerId: string) => {\r\n     if (!localStream) return null;\r\n+    if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n \r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n     // Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // Handle remote tracks\r\n+    // Remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // Handle ICE candidates\r\n+    // ICE candidates\r\n     pc.onicecandidate = (event) => {\r\n-      if (event.candidate) {\r\n-        sendRoomIce(peerId, roomId, event.candidate);\r\n-      }\r\n+      if (event.candidate) sendRoomIce(peerId, roomId, event.candidate);\r\n     };\r\n \r\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n-  /**\r\n-   * Remove a peer connection\r\n-   */\r\n+  /** ---- Remove a peer connection ---- */\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n       pc.close();\r\n@@ -56,22 +56,56 @@\n       });\r\n     }\r\n   };\r\n \r\n-  /**\r\n-   * Close all peer connections\r\n-   */\r\n+  /** ---- Close all peers ---- */\r\n   const closeAllPeers = () => {\r\n     Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  // Cleanup when room changes or component unmounts\r\n+  /** ---- Socket listeners ---- */\r\n   useEffect(() => {\r\n-    return () => closeAllPeers();\r\n-  }, [roomId]);\r\n+    if (!socket || !roomId) return;\r\n \r\n+    // When a new offer is received\r\n+    const handleOffer = async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n+      const pc = createPeerConnection(from);\r\n+      if (!pc) return;\r\n+\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      sendRoomAnswer(from, roomId, answer);\r\n+    };\r\n+\r\n+    // When an answer is received\r\n+    const handleAnswer = async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (!pc) return;\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    };\r\n+\r\n+    // When ICE candidate is received\r\n+    const handleIce = async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (!pc || !candidate) return;\r\n+      await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    };\r\n+\r\n+    socket.on(\"room-offer\", handleOffer);\r\n+    socket.on(\"room-answer\", handleAnswer);\r\n+    socket.on(\"room-ice\", handleIce);\r\n+\r\n+    return () => {\r\n+      socket.off(\"room-offer\", handleOffer);\r\n+      socket.off(\"room-answer\", handleAnswer);\r\n+      socket.off(\"room-ice\", handleIce);\r\n+      closeAllPeers();\r\n+    };\r\n+  }, [socket, roomId, localStream]);\r\n+\r\n   return {\r\n     remoteStreams,\r\n     peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n"
                }
            ],
            "date": 1758898670716,
            "name": "Commit-0",
            "content": "import { useEffect, useRef, useState } from \"react\";\r\nimport { sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n\r\ninterface PeersMap {\r\n  [peerId: string]: RTCPeerConnection;\r\n}\r\n\r\nexport default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n  const [remoteStreams, setRemoteStreams] = useState<{ [peerId: string]: MediaStream }>({});\r\n  const peerConnections = useRef<PeersMap>({});\r\n\r\n  const createPeerConnection = (peerId: string) => {\r\n    if (!localStream) throw new Error(\"Local stream not available\");\r\n\r\n    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n\r\n    // Add local tracks\r\n    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n\r\n    // Handle remote tracks\r\n    pc.ontrack = (e) => {\r\n      setRemoteStreams((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n    };\r\n\r\n    // ICE candidates\r\n    pc.onicecandidate = (e) => {\r\n      if (e.candidate) sendRoomIce(peerId, roomId, e.candidate);\r\n    };\r\n\r\n    peerConnections.current[peerId] = pc;\r\n    return pc;\r\n  };\r\n\r\n  const closePeerConnections = () => {\r\n    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n    peerConnections.current = {};\r\n    setRemoteStreams({});\r\n  };\r\n\r\n  return { remoteStreams, peerConnections, createPeerConnection, closePeerConnections };\r\n}\r\n"
        }
    ]
}