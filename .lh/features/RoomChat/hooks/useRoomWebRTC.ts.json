{
    "sourceFile": "features/RoomChat/hooks/useRoomWebRTC.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1758898670717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758906633254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,84 @@\n+import { useEffect, useRef, useState } from \"react\";\r\n+import { sendRoomIce } from \"../services/roomSocketService\";\r\n+\r\n+interface PeersMap {\r\n+  [peerId: string]: RTCPeerConnection;\r\n+}\r\n+\r\n+export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n+  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const peerConnections = useRef<PeersMap>({});\r\n+\r\n+  /**\r\n+   * Create a new RTCPeerConnection for a given peer\r\n+   */\r\n+  const createPeerConnection = (peerId: string) => {\r\n+    if (!localStream) throw new Error(\"Local stream not available\");\r\n+\r\n+    const pc = new RTCPeerConnection({\r\n+      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+    });\r\n+\r\n+    // ✅ Add local tracks\r\n+    localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n+\r\n+    // ✅ Handle remote tracks\r\n+    pc.ontrack = (event) => {\r\n+      setRemoteStreams((prev) => ({\r\n+        ...prev,\r\n+        [peerId]: event.streams[0],\r\n+      }));\r\n+    };\r\n+\r\n+    // ✅ Handle ICE candidates\r\n+    pc.onicecandidate = (event) => {\r\n+      if (event.candidate) {\r\n+        sendRoomIce(peerId, roomId, event.candidate);\r\n+      }\r\n+    };\r\n+\r\n+    peerConnections.current[peerId] = pc;\r\n+    return pc;\r\n+  };\r\n+\r\n+  /**\r\n+   * Remove a specific peer and clean up its connection\r\n+   */\r\n+  const removePeerConnection = (peerId: string) => {\r\n+    const pc = peerConnections.current[peerId];\r\n+    if (pc) {\r\n+      pc.close();\r\n+      delete peerConnections.current[peerId];\r\n+      setRemoteStreams((prev) => {\r\n+        const updated = { ...prev };\r\n+        delete updated[peerId];\r\n+        return updated;\r\n+      });\r\n+    }\r\n+  };\r\n+\r\n+  /**\r\n+   * Close all peer connections\r\n+   */\r\n+  const closeAllPeers = () => {\r\n+    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+    peerConnections.current = {};\r\n+    setRemoteStreams({});\r\n+  };\r\n+\r\n+  // ✅ Automatically close connections when hook is unmounted\r\n+  useEffect(() => {\r\n+    return () => {\r\n+      closeAllPeers();\r\n+    };\r\n+    // roomId is included so peers reset if user switches rooms\r\n+  }, [roomId]);\r\n+\r\n+  return {\r\n+    remoteStreams,\r\n+    peerConnections,\r\n+    createPeerConnection,\r\n+    removePeerConnection,\r\n+    closeAllPeers,\r\n+  };\r\n+}\r\n"
                },
                {
                    "date": 1758985313463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,26 +12,26 @@\n   /**\r\n    * Create a new RTCPeerConnection for a given peer\r\n    */\r\n   const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) throw new Error(\"Local stream not available\");\r\n+    if (!localStream) return null;\r\n \r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n-    // ✅ Add local tracks\r\n+    // Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // ✅ Handle remote tracks\r\n+    // Handle remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // ✅ Handle ICE candidates\r\n+    // Handle ICE candidates\r\n     pc.onicecandidate = (event) => {\r\n       if (event.candidate) {\r\n         sendRoomIce(peerId, roomId, event.candidate);\r\n       }\r\n@@ -41,9 +41,9 @@\n     return pc;\r\n   };\r\n \r\n   /**\r\n-   * Remove a specific peer and clean up its connection\r\n+   * Remove a peer connection\r\n    */\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n@@ -65,61 +65,17 @@\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  // ✅ Automatically close connections when hook is unmounted\r\n+  // Cleanup when room changes or component unmounts\r\n   useEffect(() => {\r\n-    return () => {\r\n-      closeAllPeers();\r\n-    };\r\n-    // roomId is included so peers reset if user switches rooms\r\n+    return () => closeAllPeers();\r\n   }, [roomId]);\r\n \r\n   return {\r\n     remoteStreams,\r\n-    peerConnections,\r\n+    peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n     removePeerConnection,\r\n     closeAllPeers,\r\n   };\r\n }\r\n-import { useEffect, useRef, useState } from \"react\";\r\n-import { sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n-\r\n-interface PeersMap {\r\n-  [peerId: string]: RTCPeerConnection;\r\n-}\r\n-\r\n-export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<{ [peerId: string]: MediaStream }>({});\r\n-  const peerConnections = useRef<PeersMap>({});\r\n-\r\n-  const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) throw new Error(\"Local stream not available\");\r\n-\r\n-    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n-\r\n-    // Add local tracks\r\n-    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n-\r\n-    // Handle remote tracks\r\n-    pc.ontrack = (e) => {\r\n-      setRemoteStreams((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n-    };\r\n-\r\n-    // ICE candidates\r\n-    pc.onicecandidate = (e) => {\r\n-      if (e.candidate) sendRoomIce(peerId, roomId, e.candidate);\r\n-    };\r\n-\r\n-    peerConnections.current[peerId] = pc;\r\n-    return pc;\r\n-  };\r\n-\r\n-  const closePeerConnections = () => {\r\n-    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n-    peerConnections.current = {};\r\n-    setRemoteStreams({});\r\n-  };\r\n-\r\n-  return { remoteStreams, peerConnections, createPeerConnection, closePeerConnections };\r\n-}\r\n"
                },
                {
                    "date": 1760158905026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,50 +1,50 @@\n import { useEffect, useRef, useState } from \"react\";\r\n-import { sendRoomIce } from \"../services/roomSocketService\";\r\n+import { getRoomSocket, sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n \r\n+interface RemoteStreamsMap {\r\n+  [peerId: string]: MediaStream;\r\n+}\r\n+\r\n export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsMap>({});\r\n   const peerConnections = useRef<PeersMap>({});\r\n+  const socket = getRoomSocket();\r\n \r\n-  /**\r\n-   * Create a new RTCPeerConnection for a given peer\r\n-   */\r\n+  /** ---- Create a new peer connection ---- */\r\n   const createPeerConnection = (peerId: string) => {\r\n     if (!localStream) return null;\r\n+    if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n \r\n     const pc = new RTCPeerConnection({\r\n       iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n     });\r\n \r\n     // Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // Handle remote tracks\r\n+    // Remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // Handle ICE candidates\r\n+    // ICE candidates\r\n     pc.onicecandidate = (event) => {\r\n-      if (event.candidate) {\r\n-        sendRoomIce(peerId, roomId, event.candidate);\r\n-      }\r\n+      if (event.candidate) sendRoomIce(peerId, roomId, event.candidate);\r\n     };\r\n \r\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n-  /**\r\n-   * Remove a peer connection\r\n-   */\r\n+  /** ---- Remove a peer connection ---- */\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n       pc.close();\r\n@@ -56,22 +56,56 @@\n       });\r\n     }\r\n   };\r\n \r\n-  /**\r\n-   * Close all peer connections\r\n-   */\r\n+  /** ---- Close all peers ---- */\r\n   const closeAllPeers = () => {\r\n     Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  // Cleanup when room changes or component unmounts\r\n+  /** ---- Socket listeners ---- */\r\n   useEffect(() => {\r\n-    return () => closeAllPeers();\r\n-  }, [roomId]);\r\n+    if (!socket || !roomId) return;\r\n \r\n+    // When a new offer is received\r\n+    const handleOffer = async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n+      const pc = createPeerConnection(from);\r\n+      if (!pc) return;\r\n+\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      sendRoomAnswer(from, roomId, answer);\r\n+    };\r\n+\r\n+    // When an answer is received\r\n+    const handleAnswer = async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (!pc) return;\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    };\r\n+\r\n+    // When ICE candidate is received\r\n+    const handleIce = async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+      const pc = peerConnections.current[from];\r\n+      if (!pc || !candidate) return;\r\n+      await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    };\r\n+\r\n+    socket.on(\"room-offer\", handleOffer);\r\n+    socket.on(\"room-answer\", handleAnswer);\r\n+    socket.on(\"room-ice\", handleIce);\r\n+\r\n+    return () => {\r\n+      socket.off(\"room-offer\", handleOffer);\r\n+      socket.off(\"room-answer\", handleAnswer);\r\n+      socket.off(\"room-ice\", handleIce);\r\n+      closeAllPeers();\r\n+    };\r\n+  }, [socket, roomId, localStream]);\r\n+\r\n   return {\r\n     remoteStreams,\r\n     peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n"
                },
                {
                    "date": 1760191714043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,11 @@\n import { useEffect, useRef, useState } from \"react\";\r\n-import { getRoomSocket, sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n+import {\r\n+  getRoomSocket,\r\n+  sendRoomOffer,\r\n+  sendRoomAnswer,\r\n+  sendRoomIce,\r\n+} from \"../services/roomSocketService\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n@@ -13,38 +18,69 @@\n   const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsMap>({});\r\n   const peerConnections = useRef<PeersMap>({});\r\n   const socket = getRoomSocket();\r\n \r\n-  /** ---- Create a new peer connection ---- */\r\n-  const createPeerConnection = (peerId: string) => {\r\n-    if (!localStream) return null;\r\n+  // --------------------------------------------------------------------\r\n+  // 🧩 Helper: Create PeerConnection\r\n+  // --------------------------------------------------------------------\r\n+  const createPeerConnection = (peerId: string): RTCPeerConnection | null => {\r\n+    if (!localStream) {\r\n+      console.warn(\"⚠️ Cannot create PeerConnection: localStream missing\");\r\n+      return null;\r\n+    }\r\n     if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n \r\n     const pc = new RTCPeerConnection({\r\n-      iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\r\n+      iceServers: [\r\n+        { urls: \"stun:stun.l.google.com:19302\" },\r\n+        { urls: \"stun:stun1.l.google.com:19302\" },\r\n+      ],\r\n     });\r\n \r\n-    // Add local tracks\r\n+    // 🔊 Add local tracks\r\n     localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-    // Remote tracks\r\n+    // 🎧 Handle remote tracks\r\n     pc.ontrack = (event) => {\r\n       setRemoteStreams((prev) => ({\r\n         ...prev,\r\n         [peerId]: event.streams[0],\r\n       }));\r\n     };\r\n \r\n-    // ICE candidates\r\n+    // ❄️ Handle ICE candidate generation\r\n     pc.onicecandidate = (event) => {\r\n-      if (event.candidate) sendRoomIce(peerId, roomId, event.candidate);\r\n+      if (event.candidate) {\r\n+        sendRoomIce(peerId, roomId, event.candidate);\r\n+      }\r\n     };\r\n \r\n+    // 🔁 Handle renegotiation needed\r\n+    pc.onnegotiationneeded = async () => {\r\n+      try {\r\n+        const offer = await pc.createOffer();\r\n+        await pc.setLocalDescription(offer);\r\n+        sendRoomOffer(peerId, roomId, offer);\r\n+      } catch (err) {\r\n+        console.error(\"❌ Renegotiation failed:\", err);\r\n+      }\r\n+    };\r\n+\r\n+    // 🧹 Cleanup on connection state change\r\n+    pc.onconnectionstatechange = () => {\r\n+      if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\") {\r\n+        console.warn(`💔 Peer ${peerId} disconnected`);\r\n+        removePeerConnection(peerId);\r\n+      }\r\n+    };\r\n+\r\n     peerConnections.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n-  /** ---- Remove a peer connection ---- */\r\n+  // --------------------------------------------------------------------\r\n+  // 🧹 Remove specific peer connection\r\n+  // --------------------------------------------------------------------\r\n   const removePeerConnection = (peerId: string) => {\r\n     const pc = peerConnections.current[peerId];\r\n     if (pc) {\r\n       pc.close();\r\n@@ -56,60 +92,109 @@\n       });\r\n     }\r\n   };\r\n \r\n-  /** ---- Close all peers ---- */\r\n+  // --------------------------------------------------------------------\r\n+  // 🚪 Close all peer connections\r\n+  // --------------------------------------------------------------------\r\n   const closeAllPeers = () => {\r\n     Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n     peerConnections.current = {};\r\n     setRemoteStreams({});\r\n   };\r\n \r\n-  /** ---- Socket listeners ---- */\r\n+  // --------------------------------------------------------------------\r\n+  // 📡 Socket Listeners (Offers, Answers, ICE)\r\n+  // --------------------------------------------------------------------\r\n   useEffect(() => {\r\n     if (!socket || !roomId) return;\r\n \r\n-    // When a new offer is received\r\n-    const handleOffer = async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-      const pc = createPeerConnection(from);\r\n-      if (!pc) return;\r\n-\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-      const answer = await pc.createAnswer();\r\n-      await pc.setLocalDescription(answer);\r\n-      sendRoomAnswer(from, roomId, answer);\r\n+    // --- Handle incoming offer ---\r\n+    const handleOffer = async ({\r\n+      from,\r\n+      offer,\r\n+    }: {\r\n+      from: string;\r\n+      offer: RTCSessionDescriptionInit;\r\n+    }) => {\r\n+      try {\r\n+        const pc = createPeerConnection(from);\r\n+        if (!pc) return;\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        sendRoomAnswer(from, roomId, answer);\r\n+      } catch (err) {\r\n+        console.error(\"❌ Error handling offer:\", err);\r\n+      }\r\n     };\r\n \r\n-    // When an answer is received\r\n-    const handleAnswer = async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-      const pc = peerConnections.current[from];\r\n-      if (!pc) return;\r\n-      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+    // --- Handle incoming answer ---\r\n+    const handleAnswer = async ({\r\n+      from,\r\n+      answer,\r\n+    }: {\r\n+      from: string;\r\n+      answer: RTCSessionDescriptionInit;\r\n+    }) => {\r\n+      try {\r\n+        const pc = peerConnections.current[from];\r\n+        if (!pc) return;\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+      } catch (err) {\r\n+        console.error(\"❌ Error setting remote description (answer):\", err);\r\n+      }\r\n     };\r\n \r\n-    // When ICE candidate is received\r\n-    const handleIce = async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-      const pc = peerConnections.current[from];\r\n-      if (!pc || !candidate) return;\r\n-      await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+    // --- Handle incoming ICE candidates ---\r\n+    const handleIce = async ({\r\n+      from,\r\n+      candidate,\r\n+    }: {\r\n+      from: string;\r\n+      candidate: RTCIceCandidateInit;\r\n+    }) => {\r\n+      try {\r\n+        const pc = peerConnections.current[from];\r\n+        if (pc && candidate) {\r\n+          await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+        }\r\n+      } catch (err) {\r\n+        console.error(\"❌ Error adding ICE candidate:\", err);\r\n+      }\r\n     };\r\n \r\n+    // ✅ Attach socket listeners\r\n     socket.on(\"room-offer\", handleOffer);\r\n     socket.on(\"room-answer\", handleAnswer);\r\n     socket.on(\"room-ice\", handleIce);\r\n \r\n+    // 🧹 Cleanup on unmount or room change\r\n     return () => {\r\n       socket.off(\"room-offer\", handleOffer);\r\n       socket.off(\"room-answer\", handleAnswer);\r\n       socket.off(\"room-ice\", handleIce);\r\n       closeAllPeers();\r\n     };\r\n   }, [socket, roomId, localStream]);\r\n \r\n+  // --------------------------------------------------------------------\r\n+  // 🎙️ Control utilities\r\n+  // --------------------------------------------------------------------\r\n+  const toggleAudio = (enabled: boolean) => {\r\n+    localStream?.getAudioTracks().forEach((track) => (track.enabled = enabled));\r\n+  };\r\n+\r\n+  const toggleVideo = (enabled: boolean) => {\r\n+    localStream?.getVideoTracks().forEach((track) => (track.enabled = enabled));\r\n+  };\r\n+\r\n   return {\r\n     remoteStreams,\r\n     peerConnections: peerConnections.current,\r\n     createPeerConnection,\r\n     removePeerConnection,\r\n     closeAllPeers,\r\n+    toggleAudio,\r\n+    toggleVideo,\r\n   };\r\n }\r\n"
                },
                {
                    "date": 1760246329995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,16 +53,21 @@\n         sendRoomIce(peerId, roomId, event.candidate);\r\n       }\r\n     };\r\n \r\n-    // 🔁 Handle renegotiation needed\r\n+    // 🔁 Handle renegotiation needed (debounced)\r\n+    let makingOffer = false;\r\n     pc.onnegotiationneeded = async () => {\r\n       try {\r\n+        if (makingOffer) return;\r\n+        makingOffer = true;\r\n         const offer = await pc.createOffer();\r\n         await pc.setLocalDescription(offer);\r\n         sendRoomOffer(peerId, roomId, offer);\r\n       } catch (err) {\r\n         console.error(\"❌ Renegotiation failed:\", err);\r\n+      } finally {\r\n+        makingOffer = false;\r\n       }\r\n     };\r\n \r\n     // 🧹 Cleanup on connection state change\r\n"
                },
                {
                    "date": 1760262896533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   getRoomSocket,\r\n   sendRoomOffer,\r\n   sendRoomAnswer,\r\n   sendRoomIce,\r\n-} from \"../services/roomSocketService\";\r\n+} from \"../../RoomChat/\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n"
                },
                {
                    "date": 1760262942720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   getRoomSocket,\r\n   sendRoomOffer,\r\n   sendRoomAnswer,\r\n   sendRoomIce,\r\n-} from \"../../RoomChat/\";\r\n+} from \"../services/roomSocketService\";\r\n \r\n interface PeersMap {\r\n   [peerId: string]: RTCPeerConnection;\r\n }\r\n"
                },
                {
                    "date": 1760267405956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,204 +1,121 @@\n+// features/RoomSystem/hooks/useRoomWebRTC.ts\r\n import { useEffect, useRef, useState } from \"react\";\r\n-import {\r\n-  getRoomSocket,\r\n-  sendRoomOffer,\r\n-  sendRoomAnswer,\r\n-  sendRoomIce,\r\n-} from \"../../../features/RoomChat/services/roomSocketService\";\r\n-interface PeersMap {\r\n-  [peerId: string]: RTCPeerConnection;\r\n-}\r\n+import type { Participant } from \"../utils/roomTypes\";\r\n+import { useRoomSocket } from \"./useRoomSocket\";\r\n \r\n-interface RemoteStreamsMap {\r\n-  [peerId: string]: MediaStream;\r\n-}\r\n+type PeerMap = Record<string, RTCPeerConnection>;\r\n \r\n-export default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsMap>({});\r\n-  const peerConnections = useRef<PeersMap>({});\r\n-  const socket = getRoomSocket();\r\n+const ICE_CONFIG: RTCConfiguration = {\r\n+  iceServers: [\r\n+    { urls: \"stun:stun.l.google.com:19302\" },\r\n+    // Add your TURN servers here if you have them\r\n+  ],\r\n+};\r\n \r\n-  // --------------------------------------------------------------------\r\n-  // 🧩 Helper: Create PeerConnection\r\n-  // --------------------------------------------------------------------\r\n-  const createPeerConnection = (peerId: string): RTCPeerConnection | null => {\r\n-    if (!localStream) {\r\n-      console.warn(\"⚠️ Cannot create PeerConnection: localStream missing\");\r\n-      return null;\r\n-    }\r\n-    if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n+export function useRoomWebRTC(localStream: MediaStream | null) {\r\n+  const { socket } = useRoomSocket();\r\n+  const peersRef = useRef<PeerMap>({});\r\n+  const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n \r\n-    const pc = new RTCPeerConnection({\r\n-      iceServers: [\r\n-        { urls: \"stun:stun.l.google.com:19302\" },\r\n-        { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      ],\r\n-    });\r\n+  useEffect(() => {\r\n+    if (!socket) return;\r\n \r\n-    // 🔊 Add local tracks\r\n-    localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n-\r\n-    // 🎧 Handle remote tracks\r\n-    pc.ontrack = (event) => {\r\n-      setRemoteStreams((prev) => ({\r\n-        ...prev,\r\n-        [peerId]: event.streams[0],\r\n-      }));\r\n-    };\r\n-\r\n-    // ❄️ Handle ICE candidate generation\r\n-    pc.onicecandidate = (event) => {\r\n-      if (event.candidate) {\r\n-        sendRoomIce(peerId, roomId, event.candidate);\r\n+    const onOffer = async ({ offer, sender }: { offer: any; sender: string }) => {\r\n+      const pc = createPeerConnection(sender);\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+      if (localStream) {\r\n+        localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n       }\r\n+      const answer = await pc.createAnswer();\r\n+      await pc.setLocalDescription(answer);\r\n+      socket.emit(\"answer\", { answer, roomId: currentRoomIdRef.current });\r\n     };\r\n \r\n-    // 🔁 Handle renegotiation needed (debounced)\r\n-    let makingOffer = false;\r\n-    pc.onnegotiationneeded = async () => {\r\n-      try {\r\n-        if (makingOffer) return;\r\n-        makingOffer = true;\r\n-        const offer = await pc.createOffer();\r\n-        await pc.setLocalDescription(offer);\r\n-        sendRoomOffer(peerId, roomId, offer);\r\n-      } catch (err) {\r\n-        console.error(\"❌ Renegotiation failed:\", err);\r\n-      } finally {\r\n-        makingOffer = false;\r\n-      }\r\n+    const onAnswer = async ({ answer, sender }: { answer: any; sender: string }) => {\r\n+      const pc = peersRef.current[sender];\r\n+      if (!pc) return;\r\n+      await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     };\r\n \r\n-    // 🧹 Cleanup on connection state change\r\n-    pc.onconnectionstatechange = () => {\r\n-      if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\") {\r\n-        console.warn(`💔 Peer ${peerId} disconnected`);\r\n-        removePeerConnection(peerId);\r\n-      }\r\n+    const onIce = ({ candidate, sender }: { candidate: any; sender: string }) => {\r\n+      const pc = peersRef.current[sender];\r\n+      if (!pc) return;\r\n+      pc.addIceCandidate(new RTCIceCandidate(candidate)).catch((e) => console.warn(\"addIce err:\", e));\r\n     };\r\n \r\n-    peerConnections.current[peerId] = pc;\r\n-    return pc;\r\n-  };\r\n+    socket.on(\"offer\", onOffer);\r\n+    socket.on(\"answer\", onAnswer);\r\n+    socket.on(\"ice-candidate\", onIce);\r\n \r\n-  // --------------------------------------------------------------------\r\n-  // 🧹 Remove specific peer connection\r\n-  // --------------------------------------------------------------------\r\n-  const removePeerConnection = (peerId: string) => {\r\n-    const pc = peerConnections.current[peerId];\r\n-    if (pc) {\r\n-      pc.close();\r\n-      delete peerConnections.current[peerId];\r\n-      setRemoteStreams((prev) => {\r\n-        const updated = { ...prev };\r\n-        delete updated[peerId];\r\n-        return updated;\r\n-      });\r\n-    }\r\n-  };\r\n+    return () => {\r\n+      socket.off(\"offer\", onOffer);\r\n+      socket.off(\"answer\", onAnswer);\r\n+      socket.off(\"ice-candidate\", onIce);\r\n+    };\r\n+  }, [socket, localStream]);\r\n \r\n-  // --------------------------------------------------------------------\r\n-  // 🚪 Close all peer connections\r\n-  // --------------------------------------------------------------------\r\n-  const closeAllPeers = () => {\r\n-    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n-    peerConnections.current = {};\r\n-    setRemoteStreams({});\r\n-  };\r\n+  const currentRoomIdRef = useRef<string | null>(null);\r\n \r\n-  // --------------------------------------------------------------------\r\n-  // 📡 Socket Listeners (Offers, Answers, ICE)\r\n-  // --------------------------------------------------------------------\r\n-  useEffect(() => {\r\n-    if (!socket || !roomId) return;\r\n+  const createPeerConnection = (peerId: string) => {\r\n+    const pc = new RTCPeerConnection(ICE_CONFIG);\r\n \r\n-    // --- Handle incoming offer ---\r\n-    const handleOffer = async ({\r\n-      from,\r\n-      offer,\r\n-    }: {\r\n-      from: string;\r\n-      offer: RTCSessionDescriptionInit;\r\n-    }) => {\r\n-      try {\r\n-        const pc = createPeerConnection(from);\r\n-        if (!pc) return;\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        sendRoomAnswer(from, roomId, answer);\r\n-      } catch (err) {\r\n-        console.error(\"❌ Error handling offer:\", err);\r\n+    pc.onicecandidate = (ev) => {\r\n+      if (ev.candidate && socket && currentRoomIdRef.current) {\r\n+        socket.emit(\"ice-candidate\", { candidate: ev.candidate, roomId: currentRoomIdRef.current });\r\n       }\r\n     };\r\n \r\n-    // --- Handle incoming answer ---\r\n-    const handleAnswer = async ({\r\n-      from,\r\n-      answer,\r\n-    }: {\r\n-      from: string;\r\n-      answer: RTCSessionDescriptionInit;\r\n-    }) => {\r\n-      try {\r\n-        const pc = peerConnections.current[from];\r\n-        if (!pc) return;\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-      } catch (err) {\r\n-        console.error(\"❌ Error setting remote description (answer):\", err);\r\n-      }\r\n+    pc.ontrack = (ev) => {\r\n+      setRemoteStreams((s) => ({ ...s, [peerId]: ev.streams[0] }));\r\n     };\r\n \r\n-    // --- Handle incoming ICE candidates ---\r\n-    const handleIce = async ({\r\n-      from,\r\n-      candidate,\r\n-    }: {\r\n-      from: string;\r\n-      candidate: RTCIceCandidateInit;\r\n-    }) => {\r\n-      try {\r\n-        const pc = peerConnections.current[from];\r\n-        if (pc && candidate) {\r\n-          await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n-        }\r\n-      } catch (err) {\r\n-        console.error(\"❌ Error adding ICE candidate:\", err);\r\n+    pc.onconnectionstatechange = () => {\r\n+      if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\" || pc.connectionState === \"closed\") {\r\n+        delete peersRef.current[peerId];\r\n+        setRemoteStreams((s) => {\r\n+          const next = { ...s };\r\n+          delete next[peerId];\r\n+          return next;\r\n+        });\r\n       }\r\n     };\r\n \r\n-    // ✅ Attach socket listeners\r\n-    socket.on(\"room-offer\", handleOffer);\r\n-    socket.on(\"room-answer\", handleAnswer);\r\n-    socket.on(\"room-ice\", handleIce);\r\n+    peersRef.current[peerId] = pc;\r\n+    return pc;\r\n+  };\r\n \r\n-    // 🧹 Cleanup on unmount or room change\r\n-    return () => {\r\n-      socket.off(\"room-offer\", handleOffer);\r\n-      socket.off(\"room-answer\", handleAnswer);\r\n-      socket.off(\"room-ice\", handleIce);\r\n-      closeAllPeers();\r\n-    };\r\n-  }, [socket, roomId, localStream]);\r\n+  const joinRoom = async (roomId: string) => {\r\n+    currentRoomIdRef.current = roomId;\r\n+    if (!socket) throw new Error(\"Socket not connected\");\r\n \r\n-  // --------------------------------------------------------------------\r\n-  // 🎙️ Control utilities\r\n-  // --------------------------------------------------------------------\r\n-  const toggleAudio = (enabled: boolean) => {\r\n-    localStream?.getAudioTracks().forEach((track) => (track.enabled = enabled));\r\n+    // announce joining room for server to add user list\r\n+    socket.emit(\"join-room\", roomId);\r\n+\r\n+    // Optionally: server could send current users then we create offers to them\r\n+    // We'll rely on 'user-joined' events (socket) to trigger offer creation.\r\n+    socket.on(\"user-joined\", async ({ socketId }: { socketId: string }) => {\r\n+      if (!socket) return;\r\n+      const pc = createPeerConnection(socketId);\r\n+      if (localStream) {\r\n+        localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n+      }\r\n+      const offer = await pc.createOffer();\r\n+      await pc.setLocalDescription(offer);\r\n+      socket.emit(\"offer\", { offer, roomId });\r\n+    });\r\n   };\r\n \r\n-  const toggleVideo = (enabled: boolean) => {\r\n-    localStream?.getVideoTracks().forEach((track) => (track.enabled = enabled));\r\n+  const leaveRoom = (roomId: string) => {\r\n+    currentRoomIdRef.current = null;\r\n+    Object.values(peersRef.current).forEach((pc) => pc.close());\r\n+    peersRef.current = {};\r\n+    setRemoteStreams({});\r\n+    socket?.emit(\"leave-room\", { roomId });\r\n   };\r\n \r\n   return {\r\n     remoteStreams,\r\n-    peerConnections: peerConnections.current,\r\n-    createPeerConnection,\r\n-    removePeerConnection,\r\n-    closeAllPeers,\r\n-    toggleAudio,\r\n-    toggleVideo,\r\n+    joinRoom,\r\n+    leaveRoom,\r\n   };\r\n }\r\n"
                },
                {
                    "date": 1760268591749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n // features/RoomSystem/hooks/useRoomWebRTC.ts\r\n import { useEffect, useRef, useState } from \"react\";\r\n-import type { Participant } from \"../utils/roomTypes\";\r\n import { useRoomSocket } from \"./useRoomSocket\";\r\n \r\n type PeerMap = Record<string, RTCPeerConnection>;\r\n \r\n@@ -12,69 +11,70 @@\n   ],\r\n };\r\n \r\n export function useRoomWebRTC(localStream: MediaStream | null) {\r\n-  const { socket } = useRoomSocket();\r\n+  const { socket } = useRoomSocket(); // socket might be null initially\r\n   const peersRef = useRef<PeerMap>({});\r\n   const [remoteStreams, setRemoteStreams] = useState<Record<string, MediaStream>>({});\r\n+  const currentRoomIdRef = useRef<string | null>(null);\r\n \r\n   useEffect(() => {\r\n     if (!socket) return;\r\n \r\n-    const onOffer = async ({ offer, sender }: { offer: any; sender: string }) => {\r\n+    const handleOffer = async ({ offer, sender }: { offer: RTCSessionDescriptionInit; sender: string }) => {\r\n       const pc = createPeerConnection(sender);\r\n       await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n       if (localStream) {\r\n-        localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n+        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n       }\r\n       const answer = await pc.createAnswer();\r\n       await pc.setLocalDescription(answer);\r\n-      socket.emit(\"answer\", { answer, roomId: currentRoomIdRef.current });\r\n+      if (currentRoomIdRef.current) {\r\n+        socket.emit(\"answer\", { answer, roomId: currentRoomIdRef.current });\r\n+      }\r\n     };\r\n \r\n-    const onAnswer = async ({ answer, sender }: { answer: any; sender: string }) => {\r\n+    const handleAnswer = async ({ answer, sender }: { answer: RTCSessionDescriptionInit; sender: string }) => {\r\n       const pc = peersRef.current[sender];\r\n       if (!pc) return;\r\n       await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n     };\r\n \r\n-    const onIce = ({ candidate, sender }: { candidate: any; sender: string }) => {\r\n+    const handleIce = ({ candidate, sender }: { candidate: RTCIceCandidateInit; sender: string }) => {\r\n       const pc = peersRef.current[sender];\r\n       if (!pc) return;\r\n       pc.addIceCandidate(new RTCIceCandidate(candidate)).catch((e) => console.warn(\"addIce err:\", e));\r\n     };\r\n \r\n-    socket.on(\"offer\", onOffer);\r\n-    socket.on(\"answer\", onAnswer);\r\n-    socket.on(\"ice-candidate\", onIce);\r\n+    socket.on(\"offer\", handleOffer);\r\n+    socket.on(\"answer\", handleAnswer);\r\n+    socket.on(\"ice-candidate\", handleIce);\r\n \r\n     return () => {\r\n-      socket.off(\"offer\", onOffer);\r\n-      socket.off(\"answer\", onAnswer);\r\n-      socket.off(\"ice-candidate\", onIce);\r\n+      socket.off(\"offer\", handleOffer);\r\n+      socket.off(\"answer\", handleAnswer);\r\n+      socket.off(\"ice-candidate\", handleIce);\r\n     };\r\n   }, [socket, localStream]);\r\n \r\n-  const currentRoomIdRef = useRef<string | null>(null);\r\n-\r\n   const createPeerConnection = (peerId: string) => {\r\n     const pc = new RTCPeerConnection(ICE_CONFIG);\r\n \r\n-    pc.onicecandidate = (ev) => {\r\n-      if (ev.candidate && socket && currentRoomIdRef.current) {\r\n-        socket.emit(\"ice-candidate\", { candidate: ev.candidate, roomId: currentRoomIdRef.current });\r\n+    pc.onicecandidate = (event) => {\r\n+      if (event.candidate && socket && currentRoomIdRef.current) {\r\n+        socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId: currentRoomIdRef.current });\r\n       }\r\n     };\r\n \r\n-    pc.ontrack = (ev) => {\r\n-      setRemoteStreams((s) => ({ ...s, [peerId]: ev.streams[0] }));\r\n+    pc.ontrack = (event) => {\r\n+      setRemoteStreams((prev) => ({ ...prev, [peerId]: event.streams[0] }));\r\n     };\r\n \r\n     pc.onconnectionstatechange = () => {\r\n       if (pc.connectionState === \"failed\" || pc.connectionState === \"disconnected\" || pc.connectionState === \"closed\") {\r\n         delete peersRef.current[peerId];\r\n-        setRemoteStreams((s) => {\r\n-          const next = { ...s };\r\n+        setRemoteStreams((prev) => {\r\n+          const next = { ...prev };\r\n           delete next[peerId];\r\n           return next;\r\n         });\r\n       }\r\n@@ -83,35 +83,33 @@\n     peersRef.current[peerId] = pc;\r\n     return pc;\r\n   };\r\n \r\n-  const joinRoom = async (roomId: string) => {\r\n+  const joinRoom = (roomId: string) => {\r\n     currentRoomIdRef.current = roomId;\r\n-    if (!socket) throw new Error(\"Socket not connected\");\r\n+    if (!socket) return; // socket may not be ready yet\r\n \r\n-    // announce joining room for server to add user list\r\n-    socket.emit(\"join-room\", roomId);\r\n+    socket.emit(\"join-room\", { roomId });\r\n \r\n-    // Optionally: server could send current users then we create offers to them\r\n-    // We'll rely on 'user-joined' events (socket) to trigger offer creation.\r\n+    // listen for new users joining\r\n     socket.on(\"user-joined\", async ({ socketId }: { socketId: string }) => {\r\n       if (!socket) return;\r\n       const pc = createPeerConnection(socketId);\r\n       if (localStream) {\r\n-        localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n+        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n       }\r\n       const offer = await pc.createOffer();\r\n       await pc.setLocalDescription(offer);\r\n       socket.emit(\"offer\", { offer, roomId });\r\n     });\r\n   };\r\n \r\n-  const leaveRoom = (roomId: string) => {\r\n+  const leaveRoom = () => {\r\n     currentRoomIdRef.current = null;\r\n     Object.values(peersRef.current).forEach((pc) => pc.close());\r\n     peersRef.current = {};\r\n     setRemoteStreams({});\r\n-    socket?.emit(\"leave-room\", { roomId });\r\n+    if (socket) socket.emit(\"leave-room\", { roomId: currentRoomIdRef.current });\r\n   };\r\n \r\n   return {\r\n     remoteStreams,\r\n"
                }
            ],
            "date": 1758898670716,
            "name": "Commit-0",
            "content": "import { useEffect, useRef, useState } from \"react\";\r\nimport { sendRoomOffer, sendRoomAnswer, sendRoomIce } from \"../services/roomSocketService\";\r\n\r\ninterface PeersMap {\r\n  [peerId: string]: RTCPeerConnection;\r\n}\r\n\r\nexport default function useRoomWebRTC(localStream: MediaStream | null, roomId: string) {\r\n  const [remoteStreams, setRemoteStreams] = useState<{ [peerId: string]: MediaStream }>({});\r\n  const peerConnections = useRef<PeersMap>({});\r\n\r\n  const createPeerConnection = (peerId: string) => {\r\n    if (!localStream) throw new Error(\"Local stream not available\");\r\n\r\n    const pc = new RTCPeerConnection({ iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] });\r\n\r\n    // Add local tracks\r\n    localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\r\n\r\n    // Handle remote tracks\r\n    pc.ontrack = (e) => {\r\n      setRemoteStreams((prev) => ({ ...prev, [peerId]: e.streams[0] }));\r\n    };\r\n\r\n    // ICE candidates\r\n    pc.onicecandidate = (e) => {\r\n      if (e.candidate) sendRoomIce(peerId, roomId, e.candidate);\r\n    };\r\n\r\n    peerConnections.current[peerId] = pc;\r\n    return pc;\r\n  };\r\n\r\n  const closePeerConnections = () => {\r\n    Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n    peerConnections.current = {};\r\n    setRemoteStreams({});\r\n  };\r\n\r\n  return { remoteStreams, peerConnections, createPeerConnection, closePeerConnections };\r\n}\r\n"
        }
    ]
}