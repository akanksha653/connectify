{
    "sourceFile": "features/anonymousChat/hooks/useWebRTC.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 33,
            "patches": [
                {
                    "date": 1752230051942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752239716786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n \r\n export default function useWebRTC(roomId: string) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n-  const localStreamRef = useRef<MediaStream | null>(null);\r\n+  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n@@ -19,56 +19,67 @@\n   };\r\n \r\n   useEffect(() => {\r\n     const init = async () => {\r\n-      socketRef.current = io(SOCKET_URL);\r\n-      localStreamRef.current = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+      // Connect to signaling server\r\n+      socketRef.current = io(SOCKET_URL, {\r\n+        transports: [\"websocket\"], // Ensures stability with Railway/production\r\n+      });\r\n \r\n+      // Get local media stream\r\n+      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+      setLocalStream(stream);\r\n+\r\n+      // Join room\r\n       socketRef.current.emit(\"join-room\", roomId);\r\n \r\n+      // Create peer connection\r\n       peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n-      // Add local tracks\r\n-      localStreamRef.current.getTracks().forEach((track) => {\r\n-        peerConnectionRef.current?.addTrack(track, localStreamRef.current as MediaStream);\r\n+      // Add local tracks to peer connection\r\n+      stream.getTracks().forEach((track) => {\r\n+        peerConnectionRef.current?.addTrack(track, stream);\r\n       });\r\n \r\n       // Handle remote stream\r\n       peerConnectionRef.current.ontrack = (event) => {\r\n         setRemoteStream(event.streams[0]);\r\n       };\r\n \r\n-      // ICE candidates\r\n+      // Handle ICE candidates generated locally\r\n       peerConnectionRef.current.onicecandidate = (event) => {\r\n         if (event.candidate) {\r\n-          socketRef.current?.emit(\"ice-candidate\", event.candidate, roomId);\r\n+          socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n         }\r\n       };\r\n \r\n-      socketRef.current.on(\"offer\", async (offer: RTCSessionDescriptionInit) => {\r\n+      // Listen for offer\r\n+      socketRef.current.on(\"offer\", async ({ offer }) => {\r\n         await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n         const answer = await peerConnectionRef.current?.createAnswer();\r\n         await peerConnectionRef.current?.setLocalDescription(answer);\r\n-        socketRef.current?.emit(\"answer\", answer, roomId);\r\n+        socketRef.current?.emit(\"answer\", { answer, roomId });\r\n       });\r\n \r\n-      socketRef.current.on(\"answer\", async (answer: RTCSessionDescriptionInit) => {\r\n+      // Listen for answer\r\n+      socketRef.current.on(\"answer\", async ({ answer }) => {\r\n         await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n       });\r\n \r\n-      socketRef.current.on(\"ice-candidate\", async (candidate: RTCIceCandidateInit) => {\r\n+      // Listen for ICE candidates from remote peer\r\n+      socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n         try {\r\n           await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n         } catch (error) {\r\n           console.error(\"Error adding received ice candidate\", error);\r\n         }\r\n       });\r\n \r\n-      // Create offer if second user joins\r\n+      // If a user joins, create an offer\r\n       socketRef.current.on(\"user-joined\", async () => {\r\n         const offer = await peerConnectionRef.current?.createOffer();\r\n         await peerConnectionRef.current?.setLocalDescription(offer);\r\n-        socketRef.current?.emit(\"offer\", offer, roomId);\r\n+        socketRef.current?.emit(\"offer\", { offer, roomId });\r\n       });\r\n     };\r\n \r\n     init();\r\n@@ -78,6 +89,6 @@\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId]);\r\n \r\n-  return { localStream: localStreamRef.current, remoteStream };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1752240989128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n \r\n import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n-const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n+const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n export default function useWebRTC(roomId: string) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n"
                },
                {
                    "date": 1752241446632,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,74 +19,85 @@\n   };\r\n \r\n   useEffect(() => {\r\n     const init = async () => {\r\n-      // Connect to signaling server\r\n-      socketRef.current = io(SOCKET_URL, {\r\n-        transports: [\"websocket\"], // Ensures stability with Railway/production\r\n-      });\r\n+      if (!SOCKET_URL) {\r\n+        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+        return;\r\n+      }\r\n \r\n-      // Get local media stream\r\n-      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-      setLocalStream(stream);\r\n+      try {\r\n+        // Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n-      // Join room\r\n-      socketRef.current.emit(\"join-room\", roomId);\r\n+        // Get local media stream\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        setLocalStream(stream);\r\n \r\n-      // Create peer connection\r\n-      peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        // Join room\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-      // Add local tracks to peer connection\r\n-      stream.getTracks().forEach((track) => {\r\n-        peerConnectionRef.current?.addTrack(track, stream);\r\n-      });\r\n+        // Create peer connection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n-      // Handle remote stream\r\n-      peerConnectionRef.current.ontrack = (event) => {\r\n-        setRemoteStream(event.streams[0]);\r\n-      };\r\n+        // Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n+        });\r\n \r\n-      // Handle ICE candidates generated locally\r\n-      peerConnectionRef.current.onicecandidate = (event) => {\r\n-        if (event.candidate) {\r\n-          socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-        }\r\n-      };\r\n+        // Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n \r\n-      // Listen for offer\r\n-      socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-        await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        const answer = await peerConnectionRef.current?.createAnswer();\r\n-        await peerConnectionRef.current?.setLocalDescription(answer);\r\n-        socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-      });\r\n+        // Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          }\r\n+        };\r\n \r\n-      // Listen for answer\r\n-      socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-        await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n-      });\r\n+        // Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current?.createAnswer();\r\n+          await peerConnectionRef.current?.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+        });\r\n \r\n-      // Listen for ICE candidates from remote peer\r\n-      socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-        try {\r\n-          await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n-        } catch (error) {\r\n-          console.error(\"Error adding received ice candidate\", error);\r\n-        }\r\n-      });\r\n+        // Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        });\r\n \r\n-      // If a user joins, create an offer\r\n-      socketRef.current.on(\"user-joined\", async () => {\r\n-        const offer = await peerConnectionRef.current?.createOffer();\r\n-        await peerConnectionRef.current?.setLocalDescription(offer);\r\n-        socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-      });\r\n+        // Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          try {\r\n+            await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"Error adding received ice candidate\", error);\r\n+          }\r\n+        });\r\n+\r\n+        // If a user joins, create an offer\r\n+        socketRef.current.on(\"user-joined\", async () => {\r\n+          const offer = await peerConnectionRef.current?.createOffer();\r\n+          await peerConnectionRef.current?.setLocalDescription(offer);\r\n+          socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+        });\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+      }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n+      // Cleanup\r\n       peerConnectionRef.current?.close();\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId]);\r\n \r\n"
                },
                {
                    "date": 1752259008837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string) {\r\n+export default function useWebRTC(roomId: string | null) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n@@ -18,8 +18,13 @@\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n+    if (!roomId) {\r\n+      console.log(\"â³ Waiting for server-assigned roomId...\");\r\n+      return;\r\n+    }\r\n+\r\n     const init = async () => {\r\n       if (!SOCKET_URL) {\r\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n@@ -34,11 +39,8 @@\n         // Get local media stream\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n \r\n-        // Join room\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n-\r\n         // Create peer connection\r\n         peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n         // Add local tracks to peer connection\r\n@@ -57,8 +59,11 @@\n             socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n+        // Join room after connecting socket and setting up handlers\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n+\r\n         // Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n           const answer = await peerConnectionRef.current?.createAnswer();\r\n@@ -98,8 +103,8 @@\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n-  }, [roomId]);\r\n+  }, [roomId, SOCKET_URL]);\r\n \r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1752259979797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,13 +4,22 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null) {\r\n+interface MatchedPayload {\r\n+  roomId: string;\r\n+  partnerId: string;\r\n+  isOfferer: boolean;\r\n+}\r\n+\r\n+export default function useWebRTC(\r\n+  roomId: string | null,\r\n+  isOfferer: boolean | null,\r\n+  socket: Socket | null\r\n+) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n-  const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n@@ -18,80 +27,85 @@\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId) {\r\n-      console.log(\"â³ Waiting for server-assigned roomId...\");\r\n+    if (!roomId || !socket) {\r\n+      console.log(\"â³ Waiting for roomId and socket...\");\r\n       return;\r\n     }\r\n \r\n     const init = async () => {\r\n-      if (!SOCKET_URL) {\r\n-        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-        return;\r\n-      }\r\n-\r\n       try {\r\n-        // Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n+        // Get local media stream\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n         });\r\n-\r\n-        // Get local media stream\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n+        console.log(\"ðŸŽ¥ Local stream obtained\");\r\n \r\n         // Create peer connection\r\n         peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n-        // Add local tracks to peer connection\r\n+        // Add local tracks\r\n         stream.getTracks().forEach((track) => {\r\n           peerConnectionRef.current?.addTrack(track, stream);\r\n         });\r\n \r\n         // Handle remote stream\r\n         peerConnectionRef.current.ontrack = (event) => {\r\n           setRemoteStream(event.streams[0]);\r\n+          console.log(\"ðŸ“¡ Remote stream received\");\r\n         };\r\n \r\n-        // Handle ICE candidates generated locally\r\n+        // Handle local ICE candidates\r\n         peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            console.log(\"â„ï¸ Sent local ICE candidate\");\r\n           }\r\n         };\r\n \r\n-        // Join room after connecting socket and setting up handlers\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n-\r\n         // Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        socket.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“¨ Received offer\");\r\n+          await peerConnectionRef.current?.setRemoteDescription(\r\n+            new RTCSessionDescription(offer)\r\n+          );\r\n           const answer = await peerConnectionRef.current?.createAnswer();\r\n           await peerConnectionRef.current?.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          socket.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"âœ… Sent answer\");\r\n         });\r\n \r\n         // Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        socket.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“¨ Received answer\");\r\n+          await peerConnectionRef.current?.setRemoteDescription(\r\n+            new RTCSessionDescription(answer)\r\n+          );\r\n         });\r\n \r\n-        // Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+        // Listen for ICE candidates from remote\r\n+        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n-            await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n+            await peerConnectionRef.current?.addIceCandidate(\r\n+              new RTCIceCandidate(candidate)\r\n+            );\r\n+            console.log(\"â„ï¸ Added remote ICE candidate\");\r\n           } catch (error) {\r\n-            console.error(\"Error adding received ice candidate\", error);\r\n+            console.error(\"âš ï¸ Error adding received ice candidate\", error);\r\n           }\r\n         });\r\n \r\n-        // If a user joins, create an offer\r\n-        socketRef.current.on(\"user-joined\", async () => {\r\n+        // If this client is offerer, create offer after joining\r\n+        if (isOfferer) {\r\n+          console.log(\"ðŸŽ¬ Acting as offerer, creating offer\");\r\n           const offer = await peerConnectionRef.current?.createOffer();\r\n           await peerConnectionRef.current?.setLocalDescription(offer);\r\n-          socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-        });\r\n+          socket.emit(\"offer\", { offer, roomId });\r\n+        }\r\n+\r\n       } catch (error) {\r\n         console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n       }\r\n     };\r\n@@ -99,12 +113,15 @@\n     init();\r\n \r\n     return () => {\r\n       // Cleanup\r\n+      console.log(\"â™»ï¸ Cleaning up WebRTC resources\");\r\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n-      socketRef.current?.disconnect();\r\n+      socket.off(\"offer\");\r\n+      socket.off(\"answer\");\r\n+      socket.off(\"ice-candidate\");\r\n     };\r\n-  }, [roomId, SOCKET_URL]);\r\n+  }, [roomId, socket, isOfferer]);\r\n \r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1752261655350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,22 +4,13 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-interface MatchedPayload {\r\n-  roomId: string;\r\n-  partnerId: string;\r\n-  isOfferer: boolean;\r\n-}\r\n-\r\n-export default function useWebRTC(\r\n-  roomId: string | null,\r\n-  isOfferer: boolean | null,\r\n-  socket: Socket | null\r\n-) {\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n+  const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n@@ -27,22 +18,28 @@\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || !socket) {\r\n-      console.log(\"â³ Waiting for roomId and socket...\");\r\n+    if (!roomId) {\r\n+      console.log(\"â³ Waiting for server-assigned roomId...\");\r\n       return;\r\n     }\r\n \r\n     const init = async () => {\r\n+      if (!SOCKET_URL) {\r\n+        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+        return;\r\n+      }\r\n+\r\n       try {\r\n+        // Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n+\r\n         // Get local media stream\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n-        console.log(\"ðŸŽ¥ Local stream obtained\");\r\n \r\n         // Create peer connection\r\n         peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n@@ -53,75 +50,61 @@\n \r\n         // Handle remote stream\r\n         peerConnectionRef.current.ontrack = (event) => {\r\n           setRemoteStream(event.streams[0]);\r\n-          console.log(\"ðŸ“¡ Remote stream received\");\r\n         };\r\n \r\n-        // Handle local ICE candidates\r\n+        // Handle ICE candidates generated locally\r\n         peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-            console.log(\"â„ï¸ Sent local ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n+        // Join room\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n+\r\n+        // If I am offerer, create offer immediately\r\n+        if (isOfferer) {\r\n+          const offer = await peerConnectionRef.current.createOffer();\r\n+          await peerConnectionRef.current.setLocalDescription(offer);\r\n+          socketRef.current.emit(\"offer\", { offer, roomId });\r\n+        }\r\n+\r\n         // Listen for offer\r\n-        socket.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“¨ Received offer\");\r\n-          await peerConnectionRef.current?.setRemoteDescription(\r\n-            new RTCSessionDescription(offer)\r\n-          );\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n           const answer = await peerConnectionRef.current?.createAnswer();\r\n           await peerConnectionRef.current?.setLocalDescription(answer);\r\n-          socket.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"âœ… Sent answer\");\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n         });\r\n \r\n         // Listen for answer\r\n-        socket.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“¨ Received answer\");\r\n-          await peerConnectionRef.current?.setRemoteDescription(\r\n-            new RTCSessionDescription(answer)\r\n-          );\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n-        // Listen for ICE candidates from remote\r\n-        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n+        // Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n-            await peerConnectionRef.current?.addIceCandidate(\r\n-              new RTCIceCandidate(candidate)\r\n-            );\r\n-            console.log(\"â„ï¸ Added remote ICE candidate\");\r\n+            await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n-            console.error(\"âš ï¸ Error adding received ice candidate\", error);\r\n+            console.error(\"Error adding received ice candidate\", error);\r\n           }\r\n         });\r\n \r\n-        // If this client is offerer, create offer after joining\r\n-        if (isOfferer) {\r\n-          console.log(\"ðŸŽ¬ Acting as offerer, creating offer\");\r\n-          const offer = await peerConnectionRef.current?.createOffer();\r\n-          await peerConnectionRef.current?.setLocalDescription(offer);\r\n-          socket.emit(\"offer\", { offer, roomId });\r\n-        }\r\n-\r\n       } catch (error) {\r\n         console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      // Cleanup\r\n-      console.log(\"â™»ï¸ Cleaning up WebRTC resources\");\r\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n-      socket.off(\"offer\");\r\n-      socket.off(\"answer\");\r\n-      socket.off(\"ice-candidate\");\r\n+      socketRef.current?.disconnect();\r\n     };\r\n-  }, [roomId, socket, isOfferer]);\r\n+  }, [roomId, isOfferer]);\r\n \r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1752261934582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean) {\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n@@ -18,10 +18,10 @@\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId) {\r\n-      console.log(\"â³ Waiting for server-assigned roomId...\");\r\n+    if (!roomId || isOfferer === null) {\r\n+      console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n       return;\r\n     }\r\n \r\n     const init = async () => {\r\n@@ -30,61 +30,50 @@\n         return;\r\n       }\r\n \r\n       try {\r\n-        // Connect to signaling server\r\n         socketRef.current = io(SOCKET_URL, {\r\n           transports: [\"websocket\"],\r\n         });\r\n \r\n-        // Get local media stream\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n \r\n-        // Create peer connection\r\n         peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n-        // Add local tracks\r\n         stream.getTracks().forEach((track) => {\r\n           peerConnectionRef.current?.addTrack(track, stream);\r\n         });\r\n \r\n-        // Handle remote stream\r\n         peerConnectionRef.current.ontrack = (event) => {\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // Handle ICE candidates generated locally\r\n         peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n             socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // Join room\r\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // If I am offerer, create offer immediately\r\n         if (isOfferer) {\r\n           const offer = await peerConnectionRef.current.createOffer();\r\n           await peerConnectionRef.current.setLocalDescription(offer);\r\n           socketRef.current.emit(\"offer\", { offer, roomId });\r\n         }\r\n \r\n-        // Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n           const answer = await peerConnectionRef.current?.createAnswer();\r\n           await peerConnectionRef.current?.setLocalDescription(answer);\r\n           socketRef.current?.emit(\"answer\", { answer, roomId });\r\n         });\r\n \r\n-        // Listen for answer\r\n         socketRef.current.on(\"answer\", async ({ answer }) => {\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n-        // Listen for ICE candidates from remote peer\r\n         socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n             await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n"
                },
                {
                    "date": 1752262332881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,55 +30,66 @@\n         return;\r\n       }\r\n \r\n       try {\r\n+        // âœ… Connect to signaling server\r\n         socketRef.current = io(SOCKET_URL, {\r\n           transports: [\"websocket\"],\r\n         });\r\n \r\n+        // âœ… Get local media stream\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n \r\n+        // âœ… Create RTCPeerConnection\r\n         peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n \r\n+        // âœ… Add local tracks to peer connection\r\n         stream.getTracks().forEach((track) => {\r\n           peerConnectionRef.current?.addTrack(track, stream);\r\n         });\r\n \r\n+        // âœ… Handle remote stream\r\n         peerConnectionRef.current.ontrack = (event) => {\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n+        // âœ… Handle ICE candidates generated locally\r\n         peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n             socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n+        // âœ… Join room after setting up handlers\r\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n+        // âœ… Offerer creates offer\r\n         if (isOfferer) {\r\n           const offer = await peerConnectionRef.current.createOffer();\r\n           await peerConnectionRef.current.setLocalDescription(offer);\r\n           socketRef.current.emit(\"offer\", { offer, roomId });\r\n         }\r\n \r\n+        // âœ… Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n           const answer = await peerConnectionRef.current?.createAnswer();\r\n           await peerConnectionRef.current?.setLocalDescription(answer);\r\n           socketRef.current?.emit(\"answer\", { answer, roomId });\r\n         });\r\n \r\n+        // âœ… Listen for answer\r\n         socketRef.current.on(\"answer\", async ({ answer }) => {\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n+        // âœ… Listen for ICE candidates from remote peer\r\n         socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n             await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n-            console.error(\"Error adding received ice candidate\", error);\r\n+            console.error(\"Error adding received ICE candidate:\", error);\r\n           }\r\n         });\r\n \r\n       } catch (error) {\r\n@@ -88,8 +99,9 @@\n \r\n     init();\r\n \r\n     return () => {\r\n+      // âœ… Cleanup\r\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n"
                },
                {
                    "date": 1752289302288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,9 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n+      // âœ… Add TURN here for production if needed\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n@@ -35,28 +36,41 @@\n         socketRef.current = io(SOCKET_URL, {\r\n           transports: [\"websocket\"],\r\n         });\r\n \r\n+        socketRef.current.on(\"connect\", () => {\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        });\r\n+\r\n         // âœ… Get local media stream\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n         // âœ… Create RTCPeerConnection\r\n         peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n         // âœ… Add local tracks to peer connection\r\n         stream.getTracks().forEach((track) => {\r\n           peerConnectionRef.current?.addTrack(track, stream);\r\n         });\r\n \r\n         // âœ… Handle remote stream\r\n         peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n+        // âœ… Connection state monitoring\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n+\r\n         // âœ… Handle ICE candidates generated locally\r\n         peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n             socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n@@ -64,32 +78,38 @@\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n         // âœ… Offerer creates offer\r\n         if (isOfferer) {\r\n+          console.log(\"ðŸ“ž Creating offer...\");\r\n           const offer = await peerConnectionRef.current.createOffer();\r\n           await peerConnectionRef.current.setLocalDescription(offer);\r\n           socketRef.current.emit(\"offer\", { offer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n         }\r\n \r\n         // âœ… Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n           const answer = await peerConnectionRef.current?.createAnswer();\r\n           await peerConnectionRef.current?.setLocalDescription(answer);\r\n           socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n         });\r\n \r\n         // âœ… Listen for answer\r\n         socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n           await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n         // âœ… Listen for ICE candidates from remote peer\r\n         socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n           try {\r\n             await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n-            console.error(\"Error adding received ICE candidate:\", error);\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n         });\r\n \r\n       } catch (error) {\r\n@@ -100,8 +120,9 @@\n     init();\r\n \r\n     return () => {\r\n       // âœ… Cleanup\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n"
                },
                {
                    "date": 1752298167157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // âœ… Add TURN here for production if needed\r\n+      // ðŸ”’ Add TURN servers here for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n@@ -40,8 +40,13 @@\n         socketRef.current.on(\"connect\", () => {\r\n           console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n         });\r\n \r\n+        // âœ… Confirm joined room\r\n+        socketRef.current.on(\"joined-room\", (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+        });\r\n+\r\n         // âœ… Get local media stream\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n         console.log(\"ðŸ“· Obtained local media stream\");\r\n@@ -60,9 +65,9 @@\n           console.log(\"ðŸ“¡ Received remote stream track\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // âœ… Connection state monitoring\r\n+        // âœ… Monitor connection state\r\n         peerConnectionRef.current.onconnectionstatechange = () => {\r\n           console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n         };\r\n \r\n@@ -76,9 +81,9 @@\n \r\n         // âœ… Join room after setting up handlers\r\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // âœ… Offerer creates offer\r\n+        // âœ… Offerer creates offer after joining room\r\n         if (isOfferer) {\r\n           console.log(\"ðŸ“ž Creating offer...\");\r\n           const offer = await peerConnectionRef.current.createOffer();\r\n           await peerConnectionRef.current.setLocalDescription(offer);\r\n@@ -119,9 +124,9 @@\n \r\n     init();\r\n \r\n     return () => {\r\n-      // âœ… Cleanup\r\n+      // âœ… Cleanup resources\r\n       console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n"
                },
                {
                    "date": 1752298872630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers here for production behind NAT/firewalls\r\n+      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n@@ -40,14 +40,9 @@\n         socketRef.current.on(\"connect\", () => {\r\n           console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n         });\r\n \r\n-        // âœ… Confirm joined room\r\n-        socketRef.current.on(\"joined-room\", (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n-        });\r\n-\r\n-        // âœ… Get local media stream\r\n+        // âœ… Get local media stream immediately\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n         console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n@@ -78,41 +73,44 @@\n             socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // âœ… Join room after setting up handlers\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // âœ… Offerer creates offer after joining room\r\n-        if (isOfferer) {\r\n-          console.log(\"ðŸ“ž Creating offer...\");\r\n-          const offer = await peerConnectionRef.current.createOffer();\r\n-          await peerConnectionRef.current.setLocalDescription(offer);\r\n-          socketRef.current.emit(\"offer\", { offer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n-        }\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n+          if (isOfferer) {\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+          }\r\n+        });\r\n+\r\n         // âœ… Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n           console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current?.createAnswer();\r\n-          await peerConnectionRef.current?.setLocalDescription(answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n           socketRef.current?.emit(\"answer\", { answer, roomId });\r\n           console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n         });\r\n \r\n         // âœ… Listen for answer\r\n         socketRef.current.on(\"answer\", async ({ answer }) => {\r\n           console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n         // âœ… Listen for ICE candidates from remote peer\r\n         socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n           console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n           try {\r\n-            await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n             console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n         });\r\n@@ -124,9 +122,8 @@\n \r\n     init();\r\n \r\n     return () => {\r\n-      // âœ… Cleanup resources\r\n       console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n"
                },
                {
                    "date": 1752300859892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,149 @@\n+import { useEffect, useRef, useState, useCallback } from \"react\";\r\n+import { io, Socket } from \"socket.io-client\";\r\n+\r\n+const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n+\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null) {\r\n+  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n+  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n+  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n+  const socketRef = useRef<Socket | null>(null);\r\n+\r\n+  const iceServers = {\r\n+    iceServers: [\r\n+      { urls: \"stun:stun.l.google.com:19302\" },\r\n+      { urls: \"stun:stun1.l.google.com:19302\" },\r\n+      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n+    ],\r\n+  };\r\n+\r\n+  /**\r\n+   * âœ… Cleanup function to close connections and stop media tracks\r\n+   */\r\n+  const stopWebRTC = useCallback(() => {\r\n+    console.log(\"ðŸ›‘ Stopping WebRTC and socket connections\");\r\n+    // Close peer connection\r\n+    peerConnectionRef.current?.close();\r\n+    peerConnectionRef.current = null;\r\n+\r\n+    // Stop local media tracks\r\n+    localStream?.getTracks().forEach((track) => track.stop());\r\n+    setLocalStream(null);\r\n+\r\n+    // Clear remote stream\r\n+    setRemoteStream(null);\r\n+\r\n+    // Disconnect socket\r\n+    socketRef.current?.disconnect();\r\n+    socketRef.current = null;\r\n+  }, [localStream]);\r\n+\r\n+  useEffect(() => {\r\n+    if (!roomId || isOfferer === null) {\r\n+      console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n+      return;\r\n+    }\r\n+\r\n+    const init = async () => {\r\n+      if (!SOCKET_URL) {\r\n+        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+        return;\r\n+      }\r\n+\r\n+      try {\r\n+        // âœ… Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n+\r\n+        socketRef.current.on(\"connect\", () => {\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        });\r\n+\r\n+        // âœ… Get local media stream immediately\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n+\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n+        });\r\n+\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n+\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n+\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          }\r\n+        };\r\n+\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n+\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+\r\n+          if (isOfferer) {\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+          }\r\n+        });\r\n+\r\n+        // âœ… Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        });\r\n+\r\n+        // âœ… Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        });\r\n+\r\n+        // âœ… Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+          try {\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+          }\r\n+        });\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+      }\r\n+    };\r\n+\r\n+    init();\r\n+\r\n+    return () => {\r\n+      stopWebRTC();\r\n+    };\r\n+  }, [roomId, isOfferer, stopWebRTC]);\r\n+\r\n+  return { localStream, remoteStream, stopWebRTC };\r\n+}\r\n"
                },
                {
                    "date": 1752301382921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,27 +16,21 @@\n       // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n-  /**\r\n-   * âœ… Cleanup function to close connections and stop media tracks\r\n-   */\r\n   const stopWebRTC = useCallback(() => {\r\n-    console.log(\"ðŸ›‘ Stopping WebRTC and socket connections\");\r\n-    // Close peer connection\r\n+    console.log(\"ðŸ›‘ Manually stopping WebRTC and socket connections\");\r\n+\r\n     peerConnectionRef.current?.close();\r\n     peerConnectionRef.current = null;\r\n \r\n-    // Stop local media tracks\r\n     localStream?.getTracks().forEach((track) => track.stop());\r\n     setLocalStream(null);\r\n \r\n-    // Clear remote stream\r\n-    setRemoteStream(null);\r\n-\r\n-    // Disconnect socket\r\n     socketRef.current?.disconnect();\r\n     socketRef.current = null;\r\n+\r\n+    setRemoteStream(null);\r\n   }, [localStream]);\r\n \r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null) {\r\n@@ -50,90 +44,87 @@\n         return;\r\n       }\r\n \r\n       try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n+        // âœ… Connect to signaling server if not connected\r\n+        if (!socketRef.current) {\r\n+          socketRef.current = io(SOCKET_URL, {\r\n+            transports: [\"websocket\"],\r\n+          });\r\n \r\n-        socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-        });\r\n+          socketRef.current.on(\"connect\", () => {\r\n+            console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+          });\r\n+        }\r\n \r\n-        // âœ… Get local media stream immediately\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n+        // âœ… Get local media stream only if not already obtained\r\n+        if (!localStream) {\r\n+          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+          setLocalStream(stream);\r\n+          console.log(\"ðŸ“· Obtained local media stream\");\r\n+        }\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        // âœ… Create RTCPeerConnection only if not existing\r\n+        if (!peerConnectionRef.current) {\r\n+          peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+          console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n-        });\r\n+          // âœ… Add local tracks\r\n+          localStream?.getTracks().forEach((track) => {\r\n+            peerConnectionRef.current?.addTrack(track, localStream);\r\n+          });\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n+          // âœ… Handle remote stream\r\n+          peerConnectionRef.current.ontrack = (event) => {\r\n+            console.log(\"ðŸ“¡ Received remote stream track\");\r\n+            setRemoteStream(event.streams[0]);\r\n+          };\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n+          // âœ… ICE candidates\r\n+          peerConnectionRef.current.onicecandidate = (event) => {\r\n+            if (event.candidate) {\r\n+              console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+              socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            }\r\n+          };\r\n+        }\r\n \r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-          }\r\n-        };\r\n-\r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n+        // âœ… Join room and handle offer/answer flow\r\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+        socketRef.current.on(\"joined-room\", async () => {\r\n+          console.log(\"ðŸ  Joined room:\", roomId);\r\n \r\n-          if (isOfferer) {\r\n+          if (isOfferer && peerConnectionRef.current) {\r\n             console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            const offer = await peerConnectionRef.current.createOffer();\r\n+            await peerConnectionRef.current.setLocalDescription(offer);\r\n             socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n           }\r\n         });\r\n \r\n-        // âœ… Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n           console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current?.createAnswer();\r\n+          await peerConnectionRef.current?.setLocalDescription(answer);\r\n           socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n         });\r\n \r\n-        // âœ… Listen for answer\r\n         socketRef.current.on(\"answer\", async ({ answer }) => {\r\n           console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n         socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n           console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n           try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+            await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n             console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n         });\r\n+\r\n       } catch (error) {\r\n         console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n       }\r\n     };\r\n@@ -142,142 +133,8 @@\n \r\n     return () => {\r\n       stopWebRTC();\r\n     };\r\n-  }, [roomId, isOfferer, stopWebRTC]);\r\n+  }, [roomId, isOfferer, localStream, stopWebRTC]);\r\n \r\n   return { localStream, remoteStream, stopWebRTC };\r\n }\r\n-// features/anonymousChat/hooks/useWebRTC.ts\r\n-\r\n-import { useEffect, useRef, useState } from \"react\";\r\n-import { io, Socket } from \"socket.io-client\";\r\n-\r\n-const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n-\r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null) {\r\n-  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n-  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n-  const socketRef = useRef<Socket | null>(null);\r\n-\r\n-  const iceServers = {\r\n-    iceServers: [\r\n-      { urls: \"stun:stun.l.google.com:19302\" },\r\n-      { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n-    ],\r\n-  };\r\n-\r\n-  useEffect(() => {\r\n-    if (!roomId || isOfferer === null) {\r\n-      console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n-      return;\r\n-    }\r\n-\r\n-    const init = async () => {\r\n-      if (!SOCKET_URL) {\r\n-        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-        return;\r\n-      }\r\n-\r\n-      try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n-\r\n-        socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-        });\r\n-\r\n-        // âœ… Get local media stream immediately\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n-\r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n-\r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n-        });\r\n-\r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n-\r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n-\r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-          }\r\n-        };\r\n-\r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n-\r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n-\r\n-          if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n-          }\r\n-        });\r\n-\r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n-        });\r\n-\r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n-        });\r\n-\r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n-          try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n-          }\r\n-        });\r\n-\r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n-      }\r\n-    };\r\n-\r\n-    init();\r\n-\r\n-    return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n-      peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n-      socketRef.current?.disconnect();\r\n-    };\r\n-  }, [roomId, isOfferer]);\r\n-\r\n-  return { localStream, remoteStream };\r\n-}\r\n"
                },
                {
                    "date": 1752301548912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,7 @@\n-import { useEffect, useRef, useState, useCallback } from \"react\";\r\n+// features/anonymousChat/hooks/useWebRTC.ts\r\n+\r\n+import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n@@ -16,23 +18,8 @@\n       // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n-  const stopWebRTC = useCallback(() => {\r\n-    console.log(\"ðŸ›‘ Manually stopping WebRTC and socket connections\");\r\n-\r\n-    peerConnectionRef.current?.close();\r\n-    peerConnectionRef.current = null;\r\n-\r\n-    localStream?.getTracks().forEach((track) => track.stop());\r\n-    setLocalStream(null);\r\n-\r\n-    socketRef.current?.disconnect();\r\n-    socketRef.current = null;\r\n-\r\n-    setRemoteStream(null);\r\n-  }, [localStream]);\r\n-\r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null) {\r\n       console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n       return;\r\n@@ -44,82 +31,86 @@\n         return;\r\n       }\r\n \r\n       try {\r\n-        // âœ… Connect to signaling server if not connected\r\n-        if (!socketRef.current) {\r\n-          socketRef.current = io(SOCKET_URL, {\r\n-            transports: [\"websocket\"],\r\n-          });\r\n+        // âœ… Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n-          socketRef.current.on(\"connect\", () => {\r\n-            console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-          });\r\n-        }\r\n+        socketRef.current.on(\"connect\", () => {\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        });\r\n \r\n-        // âœ… Get local media stream only if not already obtained\r\n-        if (!localStream) {\r\n-          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-          setLocalStream(stream);\r\n-          console.log(\"ðŸ“· Obtained local media stream\");\r\n-        }\r\n+        // âœ… Get local media stream immediately\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // âœ… Create RTCPeerConnection only if not existing\r\n-        if (!peerConnectionRef.current) {\r\n-          peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-          console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-          // âœ… Add local tracks\r\n-          localStream?.getTracks().forEach((track) => {\r\n-            peerConnectionRef.current?.addTrack(track, localStream);\r\n-          });\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n+        });\r\n \r\n-          // âœ… Handle remote stream\r\n-          peerConnectionRef.current.ontrack = (event) => {\r\n-            console.log(\"ðŸ“¡ Received remote stream track\");\r\n-            setRemoteStream(event.streams[0]);\r\n-          };\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n \r\n-          // âœ… ICE candidates\r\n-          peerConnectionRef.current.onicecandidate = (event) => {\r\n-            if (event.candidate) {\r\n-              console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-              socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-            }\r\n-          };\r\n-        }\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n \r\n-        // âœ… Join room and handle offer/answer flow\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          }\r\n+        };\r\n+\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n         socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        socketRef.current.on(\"joined-room\", async () => {\r\n-          console.log(\"ðŸ  Joined room:\", roomId);\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n-          if (isOfferer && peerConnectionRef.current) {\r\n+          if (isOfferer) {\r\n             console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current.createOffer();\r\n-            await peerConnectionRef.current.setLocalDescription(offer);\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n             socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n           }\r\n         });\r\n \r\n+        // âœ… Listen for offer\r\n         socketRef.current.on(\"offer\", async ({ offer }) => {\r\n           console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current?.createAnswer();\r\n-          await peerConnectionRef.current?.setLocalDescription(answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n           socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n         });\r\n \r\n+        // âœ… Listen for answer\r\n         socketRef.current.on(\"answer\", async ({ answer }) => {\r\n           console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n+        // âœ… Listen for ICE candidates from remote peer\r\n         socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n           console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n           try {\r\n-            await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (error) {\r\n             console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n         });\r\n@@ -131,10 +122,13 @@\n \r\n     init();\r\n \r\n     return () => {\r\n-      stopWebRTC();\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n+      peerConnectionRef.current?.close();\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n+      socketRef.current?.disconnect();\r\n     };\r\n-  }, [roomId, isOfferer, localStream, stopWebRTC]);\r\n+  }, [roomId, isOfferer]);\r\n \r\n-  return { localStream, remoteStream, stopWebRTC };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1752307135219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n // features/anonymousChat/hooks/useWebRTC.ts\r\n \r\n-import { useEffect, useRef, useState } from \"react\";\r\n+import { useEffect, useRef, useState, useCallback } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n@@ -18,117 +18,139 @@\n       // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n-  useEffect(() => {\r\n+  const initWebRTC = useCallback(async () => {\r\n     if (!roomId || isOfferer === null) {\r\n       console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n       return;\r\n     }\r\n \r\n-    const init = async () => {\r\n-      if (!SOCKET_URL) {\r\n-        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-        return;\r\n-      }\r\n+    if (!SOCKET_URL) {\r\n+      console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+      return;\r\n+    }\r\n \r\n-      try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n+    try {\r\n+      // âœ… Connect to signaling server\r\n+      socketRef.current = io(SOCKET_URL, {\r\n+        transports: [\"websocket\"],\r\n+      });\r\n \r\n-        socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-        });\r\n+      socketRef.current.on(\"connect\", () => {\r\n+        console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+      });\r\n \r\n-        // âœ… Get local media stream immediately\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n+      // âœ… Get local media stream immediately\r\n+      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+      setLocalStream(stream);\r\n+      console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+      // âœ… Create RTCPeerConnection\r\n+      peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+      console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n-        });\r\n+      // âœ… Add local tracks to peer connection\r\n+      stream.getTracks().forEach((track) => {\r\n+        peerConnectionRef.current?.addTrack(track, stream);\r\n+      });\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n+      // âœ… Handle remote stream\r\n+      peerConnectionRef.current.ontrack = (event) => {\r\n+        console.log(\"ðŸ“¡ Received remote stream track\");\r\n+        setRemoteStream(event.streams[0]);\r\n+      };\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n+      // âœ… Monitor connection state\r\n+      peerConnectionRef.current.onconnectionstatechange = () => {\r\n+        console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+      };\r\n \r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-          }\r\n-        };\r\n+      // âœ… Handle ICE candidates generated locally\r\n+      peerConnectionRef.current.onicecandidate = (event) => {\r\n+        if (event.candidate) {\r\n+          console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+          socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+        }\r\n+      };\r\n \r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+      // âœ… Join room and wait for confirmation before offer creation\r\n+      socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+      socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+        console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n-          if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n-          }\r\n-        });\r\n+        if (isOfferer) {\r\n+          console.log(\"ðŸ“ž Creating offer...\");\r\n+          const offer = await peerConnectionRef.current!.createOffer();\r\n+          await peerConnectionRef.current!.setLocalDescription(offer);\r\n+          socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+        }\r\n+      });\r\n \r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n-        });\r\n+      // âœ… Listen for offer\r\n+      socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+        console.log(\"ðŸ“© Received offer:\", offer);\r\n+        await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        const answer = await peerConnectionRef.current!.createAnswer();\r\n+        await peerConnectionRef.current!.setLocalDescription(answer);\r\n+        socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+        console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+      });\r\n \r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n-        });\r\n+      // âœ… Listen for answer\r\n+      socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+        console.log(\"ðŸ“© Received answer:\", answer);\r\n+        await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+      });\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n-          try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n-          }\r\n-        });\r\n+      // âœ… Listen for ICE candidates from remote peer\r\n+      socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+        console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+        try {\r\n+          await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+        } catch (error) {\r\n+          console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+        }\r\n+      });\r\n+    } catch (error) {\r\n+      console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+    }\r\n+  }, [roomId, isOfferer]);\r\n \r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n-      }\r\n-    };\r\n+  const stopWebRTC = useCallback(() => {\r\n+    console.log(\"ðŸ›‘ Manually stopping WebRTC and socket connections\");\r\n \r\n-    init();\r\n+    // âœ… Close peer connection\r\n+    if (peerConnectionRef.current) {\r\n+      peerConnectionRef.current.close();\r\n+      peerConnectionRef.current = null;\r\n+    }\r\n \r\n+    // âœ… Stop local media tracks\r\n+    if (localStream) {\r\n+      localStream.getTracks().forEach((track) => track.stop());\r\n+      setLocalStream(null);\r\n+    }\r\n+\r\n+    // âœ… Disconnect socket\r\n+    if (socketRef.current) {\r\n+      socketRef.current.disconnect();\r\n+      socketRef.current = null;\r\n+    }\r\n+\r\n+    // âœ… Clear remote stream\r\n+    setRemoteStream(null);\r\n+  }, [localStream]);\r\n+\r\n+  // âœ… Initialize when roomId and isOfferer change\r\n+  useEffect(() => {\r\n+    initWebRTC();\r\n+\r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n-      peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n-      socketRef.current?.disconnect();\r\n+      stopWebRTC();\r\n     };\r\n-  }, [roomId, isOfferer]);\r\n+  }, [initWebRTC, stopWebRTC]);\r\n \r\n-  return { localStream, remoteStream };\r\n+  return { localStream, remoteStream, stopWebRTC };\r\n }\r\n"
                },
                {
                    "date": 1752307458264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n // features/anonymousChat/hooks/useWebRTC.ts\r\n \r\n-import { useEffect, useRef, useState, useCallback } from \"react\";\r\n+import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n@@ -18,139 +18,117 @@\n       // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n-  const initWebRTC = useCallback(async () => {\r\n+  useEffect(() => {\r\n     if (!roomId || isOfferer === null) {\r\n       console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n       return;\r\n     }\r\n \r\n-    if (!SOCKET_URL) {\r\n-      console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-      return;\r\n-    }\r\n+    const init = async () => {\r\n+      if (!SOCKET_URL) {\r\n+        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+        return;\r\n+      }\r\n \r\n-    try {\r\n-      // âœ… Connect to signaling server\r\n-      socketRef.current = io(SOCKET_URL, {\r\n-        transports: [\"websocket\"],\r\n-      });\r\n+      try {\r\n+        // âœ… Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n-      socketRef.current.on(\"connect\", () => {\r\n-        console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-      });\r\n+        socketRef.current.on(\"connect\", () => {\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        });\r\n \r\n-      // âœ… Get local media stream immediately\r\n-      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-      setLocalStream(stream);\r\n-      console.log(\"ðŸ“· Obtained local media stream\");\r\n+        // âœ… Get local media stream immediately\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-      // âœ… Create RTCPeerConnection\r\n-      peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-      console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-      // âœ… Add local tracks to peer connection\r\n-      stream.getTracks().forEach((track) => {\r\n-        peerConnectionRef.current?.addTrack(track, stream);\r\n-      });\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n+        });\r\n \r\n-      // âœ… Handle remote stream\r\n-      peerConnectionRef.current.ontrack = (event) => {\r\n-        console.log(\"ðŸ“¡ Received remote stream track\");\r\n-        setRemoteStream(event.streams[0]);\r\n-      };\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n \r\n-      // âœ… Monitor connection state\r\n-      peerConnectionRef.current.onconnectionstatechange = () => {\r\n-        console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-      };\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n \r\n-      // âœ… Handle ICE candidates generated locally\r\n-      peerConnectionRef.current.onicecandidate = (event) => {\r\n-        if (event.candidate) {\r\n-          console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-          socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-        }\r\n-      };\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          }\r\n+        };\r\n \r\n-      // âœ… Join room and wait for confirmation before offer creation\r\n-      socketRef.current.emit(\"join-room\", roomId);\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-      socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-        console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n-        if (isOfferer) {\r\n-          console.log(\"ðŸ“ž Creating offer...\");\r\n-          const offer = await peerConnectionRef.current!.createOffer();\r\n-          await peerConnectionRef.current!.setLocalDescription(offer);\r\n-          socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n-        }\r\n-      });\r\n+          if (isOfferer) {\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+          }\r\n+        });\r\n \r\n-      // âœ… Listen for offer\r\n-      socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-        console.log(\"ðŸ“© Received offer:\", offer);\r\n-        await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        const answer = await peerConnectionRef.current!.createAnswer();\r\n-        await peerConnectionRef.current!.setLocalDescription(answer);\r\n-        socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-        console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n-      });\r\n+        // âœ… Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        });\r\n \r\n-      // âœ… Listen for answer\r\n-      socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-        console.log(\"ðŸ“© Received answer:\", answer);\r\n-        await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n-      });\r\n+        // âœ… Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        });\r\n \r\n-      // âœ… Listen for ICE candidates from remote peer\r\n-      socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-        console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n-        try {\r\n-          await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-        } catch (error) {\r\n-          console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n-        }\r\n-      });\r\n-    } catch (error) {\r\n-      console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n-    }\r\n-  }, [roomId, isOfferer]);\r\n+        // âœ… Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+          try {\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+          }\r\n+        });\r\n \r\n-  const stopWebRTC = useCallback(() => {\r\n-    console.log(\"ðŸ›‘ Manually stopping WebRTC and socket connections\");\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+      }\r\n+    };\r\n \r\n-    // âœ… Close peer connection\r\n-    if (peerConnectionRef.current) {\r\n-      peerConnectionRef.current.close();\r\n-      peerConnectionRef.current = null;\r\n-    }\r\n+    init();\r\n \r\n-    // âœ… Stop local media tracks\r\n-    if (localStream) {\r\n-      localStream.getTracks().forEach((track) => track.stop());\r\n-      setLocalStream(null);\r\n-    }\r\n-\r\n-    // âœ… Disconnect socket\r\n-    if (socketRef.current) {\r\n-      socketRef.current.disconnect();\r\n-      socketRef.current = null;\r\n-    }\r\n-\r\n-    // âœ… Clear remote stream\r\n-    setRemoteStream(null);\r\n-  }, [localStream]);\r\n-\r\n-  // âœ… Initialize when roomId and isOfferer change\r\n-  useEffect(() => {\r\n-    initWebRTC();\r\n-\r\n     return () => {\r\n-      stopWebRTC();\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n+      peerConnectionRef.current?.close();\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n+      socketRef.current?.disconnect();\r\n     };\r\n-  }, [initWebRTC, stopWebRTC]);\r\n+  }, [roomId, isOfferer]);\r\n \r\n-  return { localStream, remoteStream, stopWebRTC };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1752311536461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,10 @@\n-// features/anonymousChat/hooks/useWebRTC.ts\r\n-\r\n import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null) {\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n@@ -19,10 +17,10 @@\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null) {\r\n-      console.log(\"â³ Waiting for server-assigned roomId and role...\");\r\n+    if (!roomId || isOfferer === null || !isStarted) {\r\n+      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n       return;\r\n     }\r\n \r\n     const init = async () => {\r\n@@ -40,9 +38,9 @@\n         socketRef.current.on(\"connect\", () => {\r\n           console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n         });\r\n \r\n-        // âœ… Get local media stream immediately\r\n+        // âœ… Get local media stream AFTER user clicks Start\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n         console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n@@ -127,8 +125,8 @@\n       peerConnectionRef.current?.close();\r\n       localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n-  }, [roomId, isOfferer]);\r\n+  }, [roomId, isOfferer, isStarted]);\r\n \r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1758889157968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,25 +2,41 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n-  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n+/**\r\n+ * useWebRTC\r\n+ * - Supports anonymous 1-1 calls (legacy)\r\n+ * - Supports group rooms (new)\r\n+ *\r\n+ * @param roomId       room id (uuid or custom)\r\n+ * @param isOfferer    true if this peer should create the first offer (1-1 only)\r\n+ * @param isStarted    start flag to delay camera/mic access until user clicks Start\r\n+ * @param isGroup      true => group room mode, false => 1-1 mode\r\n+ */\r\n+export default function useWebRTC(\r\n+  roomId: string | null,\r\n+  isOfferer: boolean | null,\r\n+  isStarted: boolean,\r\n+  isGroup: boolean = false\r\n+) {\r\n+  const [remoteStreams, setRemoteStreams] = useState<MediaStream[]>([]);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n+\r\n   const socketRef = useRef<Socket | null>(null);\r\n+  const peersRef = useRef<Map<string, RTCPeerConnection>>(new Map());\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n+      // ðŸ”’ Add TURN servers in production for NAT traversal\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted) {\r\n-      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n+    if (!roomId || !isStarted || (isOfferer === null && !isGroup)) {\r\n+      console.log(\"â³ Waiting for required parametersâ€¦\");\r\n       return;\r\n     }\r\n \r\n     const init = async () => {\r\n@@ -28,105 +44,134 @@\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n       }\r\n \r\n-      try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n+      // 1ï¸âƒ£ Connect to signaling server\r\n+      const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n+      socketRef.current = socket;\r\n \r\n-        socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-        });\r\n+      socket.on(\"connect\", () =>\r\n+        console.log(\"âœ… Connected to signaling server:\", socket.id)\r\n+      );\r\n \r\n-        // âœ… Get local media stream AFTER user clicks Start\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n-        setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n+      // 2ï¸âƒ£ Get local media stream\r\n+      const stream = await navigator.mediaDevices.getUserMedia({\r\n+        video: true,\r\n+        audio: true,\r\n+      });\r\n+      setLocalStream(stream);\r\n+      console.log(\"ðŸ“· Local media stream ready\");\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+      // Helper to create & store a peer connection for a remote user\r\n+      const createPeer = (peerId: string, isInitiator: boolean) => {\r\n+        const pc = new RTCPeerConnection(iceServers);\r\n+        peersRef.current.set(peerId, pc);\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n-        });\r\n+        // Add local tracks\r\n+        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n-          setRemoteStream(event.streams[0]);\r\n+        // Remote stream handler\r\n+        pc.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Remote track from\", peerId);\r\n+          setRemoteStreams((prev) => {\r\n+            // avoid duplicates\r\n+            if (prev.find((s) => s.id === event.streams[0].id)) return prev;\r\n+            return [...prev, event.streams[0]];\r\n+          });\r\n         };\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n-\r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n+        // ICE candidates\r\n+        pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            socket.emit(\"ice-candidate\", {\r\n+              candidate: event.candidate,\r\n+              roomId,\r\n+              target: peerId,\r\n+            });\r\n           }\r\n         };\r\n \r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // Create offer if needed\r\n+        if (isInitiator) {\r\n+          pc.createOffer()\r\n+            .then((offer) => pc.setLocalDescription(offer).then(() => offer))\r\n+            .then((offer) => {\r\n+              socket.emit(\"offer\", { offer, roomId, target: peerId });\r\n+            });\r\n+        }\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+        return pc;\r\n+      };\r\n \r\n+      // 3ï¸âƒ£ Join the room\r\n+      if (isGroup) {\r\n+        socket.emit(\"room:join\", { roomId });\r\n+\r\n+        // Receive list of existing peers to connect to\r\n+        socket.on(\"room:peers\", ({ peers }) => {\r\n+          peers.forEach((peerId: string) => createPeer(peerId, true));\r\n+        });\r\n+\r\n+        // New peer joined\r\n+        socket.on(\"room:new-peer\", ({ peerId }) => {\r\n+          createPeer(peerId, true);\r\n+        });\r\n+      } else {\r\n+        // legacy 1-1 flow\r\n+        socket.emit(\"join-room\", roomId);\r\n+        socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+            const pc = createPeer(\"single\", true);\r\n+            peersRef.current.set(\"single\", pc);\r\n           }\r\n         });\r\n+      }\r\n \r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n-        });\r\n+      // 4ï¸âƒ£ Signaling handlers\r\n+      socket.on(\"offer\", async ({ offer, sender }) => {\r\n+        const pc = createPeer(sender, false);\r\n+        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+        const answer = await pc.createAnswer();\r\n+        await pc.setLocalDescription(answer);\r\n+        socket.emit(\"answer\", { answer, roomId, target: sender });\r\n+      });\r\n \r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n-        });\r\n+      socket.on(\"answer\", async ({ answer, sender }) => {\r\n+        const pc = peersRef.current.get(sender);\r\n+        if (pc) {\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        }\r\n+      });\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+      socket.on(\"ice-candidate\", async ({ candidate, sender }) => {\r\n+        const pc = peersRef.current.get(sender);\r\n+        if (pc) {\r\n           try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (err) {\r\n+            console.error(\"âŒ Error adding ICE candidate:\", err);\r\n           }\r\n-        });\r\n+        }\r\n+      });\r\n \r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n-      }\r\n+      socket.on(\"peer-left\", ({ peerId }) => {\r\n+        console.log(\"ðŸ‘‹ Peer left:\", peerId);\r\n+        const pc = peersRef.current.get(peerId);\r\n+        if (pc) pc.close();\r\n+        peersRef.current.delete(peerId);\r\n+        setRemoteStreams((prev) => prev.filter((s) => s.id !== peerId));\r\n+      });\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n-      peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC\");\r\n+      peersRef.current.forEach((pc) => pc.close());\r\n+      peersRef.current.clear();\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n-  }, [roomId, isOfferer, isStarted]);\r\n+  }, [roomId, isOfferer, isStarted, isGroup]);\r\n \r\n-  return { localStream, remoteStream };\r\n+  return { localStream, remoteStreams };\r\n }\r\n"
                },
                {
                    "date": 1758889227561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,41 +2,25 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-/**\r\n- * useWebRTC\r\n- * - Supports anonymous 1-1 calls (legacy)\r\n- * - Supports group rooms (new)\r\n- *\r\n- * @param roomId       room id (uuid or custom)\r\n- * @param isOfferer    true if this peer should create the first offer (1-1 only)\r\n- * @param isStarted    start flag to delay camera/mic access until user clicks Start\r\n- * @param isGroup      true => group room mode, false => 1-1 mode\r\n- */\r\n-export default function useWebRTC(\r\n-  roomId: string | null,\r\n-  isOfferer: boolean | null,\r\n-  isStarted: boolean,\r\n-  isGroup: boolean = false\r\n-) {\r\n-  const [remoteStreams, setRemoteStreams] = useState<MediaStream[]>([]);\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n+  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-\r\n+  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n-  const peersRef = useRef<Map<string, RTCPeerConnection>>(new Map());\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers in production for NAT traversal\r\n+      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || !isStarted || (isOfferer === null && !isGroup)) {\r\n-      console.log(\"â³ Waiting for required parametersâ€¦\");\r\n+    if (!roomId || isOfferer === null || !isStarted) {\r\n+      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n       return;\r\n     }\r\n \r\n     const init = async () => {\r\n@@ -44,134 +28,105 @@\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n       }\r\n \r\n-      // 1ï¸âƒ£ Connect to signaling server\r\n-      const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n-      socketRef.current = socket;\r\n+      try {\r\n+        // âœ… Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n-      socket.on(\"connect\", () =>\r\n-        console.log(\"âœ… Connected to signaling server:\", socket.id)\r\n-      );\r\n+        socketRef.current.on(\"connect\", () => {\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        });\r\n \r\n-      // 2ï¸âƒ£ Get local media stream\r\n-      const stream = await navigator.mediaDevices.getUserMedia({\r\n-        video: true,\r\n-        audio: true,\r\n-      });\r\n-      setLocalStream(stream);\r\n-      console.log(\"ðŸ“· Local media stream ready\");\r\n+        // âœ… Get local media stream AFTER user clicks Start\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-      // Helper to create & store a peer connection for a remote user\r\n-      const createPeer = (peerId: string, isInitiator: boolean) => {\r\n-        const pc = new RTCPeerConnection(iceServers);\r\n-        peersRef.current.set(peerId, pc);\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-        // Add local tracks\r\n-        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n+        });\r\n \r\n-        // Remote stream handler\r\n-        pc.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Remote track from\", peerId);\r\n-          setRemoteStreams((prev) => {\r\n-            // avoid duplicates\r\n-            if (prev.find((s) => s.id === event.streams[0].id)) return prev;\r\n-            return [...prev, event.streams[0]];\r\n-          });\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+          setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // ICE candidates\r\n-        pc.onicecandidate = (event) => {\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n+\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            socket.emit(\"ice-candidate\", {\r\n-              candidate: event.candidate,\r\n-              roomId,\r\n-              target: peerId,\r\n-            });\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // Create offer if needed\r\n-        if (isInitiator) {\r\n-          pc.createOffer()\r\n-            .then((offer) => pc.setLocalDescription(offer).then(() => offer))\r\n-            .then((offer) => {\r\n-              socket.emit(\"offer\", { offer, roomId, target: peerId });\r\n-            });\r\n-        }\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        return pc;\r\n-      };\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n-      // 3ï¸âƒ£ Join the room\r\n-      if (isGroup) {\r\n-        socket.emit(\"room:join\", { roomId });\r\n-\r\n-        // Receive list of existing peers to connect to\r\n-        socket.on(\"room:peers\", ({ peers }) => {\r\n-          peers.forEach((peerId: string) => createPeer(peerId, true));\r\n-        });\r\n-\r\n-        // New peer joined\r\n-        socket.on(\"room:new-peer\", ({ peerId }) => {\r\n-          createPeer(peerId, true);\r\n-        });\r\n-      } else {\r\n-        // legacy 1-1 flow\r\n-        socket.emit(\"join-room\", roomId);\r\n-        socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n-            const pc = createPeer(\"single\", true);\r\n-            peersRef.current.set(\"single\", pc);\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n           }\r\n         });\r\n-      }\r\n \r\n-      // 4ï¸âƒ£ Signaling handlers\r\n-      socket.on(\"offer\", async ({ offer, sender }) => {\r\n-        const pc = createPeer(sender, false);\r\n-        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-        const answer = await pc.createAnswer();\r\n-        await pc.setLocalDescription(answer);\r\n-        socket.emit(\"answer\", { answer, roomId, target: sender });\r\n-      });\r\n+        // âœ… Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        });\r\n \r\n-      socket.on(\"answer\", async ({ answer, sender }) => {\r\n-        const pc = peersRef.current.get(sender);\r\n-        if (pc) {\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-        }\r\n-      });\r\n+        // âœ… Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        });\r\n \r\n-      socket.on(\"ice-candidate\", async ({ candidate, sender }) => {\r\n-        const pc = peersRef.current.get(sender);\r\n-        if (pc) {\r\n+        // âœ… Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n           try {\r\n-            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (err) {\r\n-            console.error(\"âŒ Error adding ICE candidate:\", err);\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n-        }\r\n-      });\r\n+        });\r\n \r\n-      socket.on(\"peer-left\", ({ peerId }) => {\r\n-        console.log(\"ðŸ‘‹ Peer left:\", peerId);\r\n-        const pc = peersRef.current.get(peerId);\r\n-        if (pc) pc.close();\r\n-        peersRef.current.delete(peerId);\r\n-        setRemoteStreams((prev) => prev.filter((s) => s.id !== peerId));\r\n-      });\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+      }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC\");\r\n-      peersRef.current.forEach((pc) => pc.close());\r\n-      peersRef.current.clear();\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n+      peerConnectionRef.current?.close();\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n-  }, [roomId, isOfferer, isStarted, isGroup]);\r\n+  }, [roomId, isOfferer, isStarted]);\r\n \r\n-  return { localStream, remoteStreams };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1758889257364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,131 +2,142 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n+/**\r\n+ * Hook for WebRTC 1-1 & Room calls\r\n+ *\r\n+ * @param roomId - room id assigned by server\r\n+ * @param isOfferer - true if this client creates the offer\r\n+ * @param isStarted - true after user clicks Start/Join\r\n+ */\r\n+export default function useWebRTC(\r\n+  roomId: string | null,\r\n+  isOfferer: boolean | null,\r\n+  isStarted: boolean\r\n+) {\r\n+  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n-  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n+\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n-  const iceServers = {\r\n+  const iceServers: RTCConfiguration = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n+      // âš ï¸ add TURN for production if needed\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null || !isStarted) {\r\n-      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n+      console.log(\"â³ Waiting for Start + roomId + role...\");\r\n       return;\r\n     }\r\n \r\n+    if (!SOCKET_URL) {\r\n+      console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+      return;\r\n+    }\r\n+\r\n+    let isMounted = true;\r\n+\r\n     const init = async () => {\r\n-      if (!SOCKET_URL) {\r\n-        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-        return;\r\n-      }\r\n-\r\n       try {\r\n         // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n+        const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n+        socketRef.current = socket;\r\n \r\n-        socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        socket.on(\"connect\", () =>\r\n+          console.log(\"âœ… Connected to socket:\", socket.id)\r\n+        );\r\n+\r\n+        // âœ… Get local camera/mic\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n         });\r\n-\r\n-        // âœ… Get local media stream AFTER user clicks Start\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        if (!isMounted) return;\r\n         setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n+        console.log(\"ðŸ“· Local stream ready\");\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        // âœ… Create PeerConnection\r\n+        const pc = new RTCPeerConnection(iceServers);\r\n+        peerConnectionRef.current = pc;\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n-        });\r\n+        // Add local tracks\r\n+        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+        // Remote stream\r\n+        pc.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Remote track received\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n+        pc.onconnectionstatechange = () =>\r\n+          console.log(\"ðŸ”— Connection:\", pc.connectionState);\r\n \r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n+        // Local ICE candidates\r\n+        pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // âœ… Join room\r\n+        socket.emit(\"join-room\", roomId);\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n-\r\n+        socket.on(\"joined-room\", async () => {\r\n+          console.log(\"ðŸ  Joined room:\", roomId);\r\n           if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+            const offer = await pc.createOffer();\r\n+            await pc.setLocalDescription(offer);\r\n+            socket.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer\");\r\n           }\r\n         });\r\n \r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        // âœ… Handle offer\r\n+        socket.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Got offer\");\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await pc.createAnswer();\r\n+          await pc.setLocalDescription(answer);\r\n+          socket.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer\");\r\n         });\r\n \r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        // âœ… Handle answer\r\n+        socket.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Got answer\");\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+        // âœ… Handle ICE candidate\r\n+        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+            console.log(\"ðŸ“© Added remote ICE candidate\");\r\n+          } catch (err) {\r\n+            console.error(\"âŒ ICE error:\", err);\r\n           }\r\n         });\r\n-\r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+      } catch (err) {\r\n+        console.error(\"âŒ WebRTC init failed:\", err);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n+      isMounted = false;\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC + socket\");\r\n       peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId, isOfferer, isStarted]);\r\n \r\n+  // âœ… Always return object (safe destructuring)\r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1758891684884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,142 +2,131 @@\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-/**\r\n- * Hook for WebRTC 1-1 & Room calls\r\n- *\r\n- * @param roomId - room id assigned by server\r\n- * @param isOfferer - true if this client creates the offer\r\n- * @param isStarted - true after user clicks Start/Join\r\n- */\r\n-export default function useWebRTC(\r\n-  roomId: string | null,\r\n-  isOfferer: boolean | null,\r\n-  isStarted: boolean\r\n-) {\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n+  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n-\r\n   const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n-  const iceServers: RTCConfiguration = {\r\n+  const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // âš ï¸ add TURN for production if needed\r\n+      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null || !isStarted) {\r\n-      console.log(\"â³ Waiting for Start + roomId + role...\");\r\n+      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n       return;\r\n     }\r\n \r\n-    if (!SOCKET_URL) {\r\n-      console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-      return;\r\n-    }\r\n+    const init = async () => {\r\n+      if (!SOCKET_URL) {\r\n+        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n+        return;\r\n+      }\r\n \r\n-    let isMounted = true;\r\n-\r\n-    const init = async () => {\r\n       try {\r\n         // âœ… Connect to signaling server\r\n-        const socket = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n-        socketRef.current = socket;\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n-        socket.on(\"connect\", () =>\r\n-          console.log(\"âœ… Connected to socket:\", socket.id)\r\n-        );\r\n+        socketRef.current.on(\"connect\", () => {\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+        });\r\n \r\n-        // âœ… Get local camera/mic\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n-        if (!isMounted) return;\r\n+        // âœ… Get local media stream AFTER user clicks Start\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Local stream ready\");\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // âœ… Create PeerConnection\r\n-        const pc = new RTCPeerConnection(iceServers);\r\n-        peerConnectionRef.current = pc;\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-        // Add local tracks\r\n-        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n+        });\r\n \r\n-        // Remote stream\r\n-        pc.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Remote track received\");\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        pc.onconnectionstatechange = () =>\r\n-          console.log(\"ðŸ”— Connection:\", pc.connectionState);\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n \r\n-        // Local ICE candidates\r\n-        pc.onicecandidate = (event) => {\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // âœ… Join room\r\n-        socket.emit(\"join-room\", roomId);\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        socket.on(\"joined-room\", async () => {\r\n-          console.log(\"ðŸ  Joined room:\", roomId);\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+\r\n           if (isOfferer) {\r\n-            const offer = await pc.createOffer();\r\n-            await pc.setLocalDescription(offer);\r\n-            socket.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer\");\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n           }\r\n         });\r\n \r\n-        // âœ… Handle offer\r\n-        socket.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Got offer\");\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await pc.createAnswer();\r\n-          await pc.setLocalDescription(answer);\r\n-          socket.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer\");\r\n+        // âœ… Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n         });\r\n \r\n-        // âœ… Handle answer\r\n-        socket.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Got answer\");\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        // âœ… Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n-        // âœ… Handle ICE candidate\r\n-        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n+        // âœ… Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n           try {\r\n-            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n-            console.log(\"ðŸ“© Added remote ICE candidate\");\r\n-          } catch (err) {\r\n-            console.error(\"âŒ ICE error:\", err);\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n         });\r\n-      } catch (err) {\r\n-        console.error(\"âŒ WebRTC init failed:\", err);\r\n+\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      isMounted = false;\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC + socket\");\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n       peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId, isOfferer, isStarted]);\r\n \r\n-  // âœ… Always return object (safe destructuring)\r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1758893800317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,132 +1,153 @@\n+// features/anonymousChat/hooks/useWebRTC.ts\r\n import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n-  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n+interface PeerStreams {\r\n+  [peerId: string]: MediaStream;\r\n+}\r\n+\r\n+export default function useWebRTC(\r\n+  roomId: string | null,\r\n+  isOfferer: boolean | null,\r\n+  isStarted: boolean\r\n+) {\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n+  const [remoteStreams, setRemoteStreams] = useState<PeerStreams>({});\r\n+  const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n+      // ðŸ”’ Add TURN servers for production\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted) {\r\n-      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n-      return;\r\n-    }\r\n+    if (!roomId || isOfferer === null || !isStarted) return;\r\n \r\n     const init = async () => {\r\n       if (!SOCKET_URL) {\r\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n       }\r\n \r\n       try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n+        socketRef.current = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n \r\n         socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+          console.log(\"âœ… Connected to signaling server:\", socketRef.current?.id);\r\n         });\r\n \r\n-        // âœ… Get local media stream AFTER user clicks Start\r\n+        // --- Local Media ---\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        // --- Join Room ---\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n+        // --- Handle New Users Joining the Room ---\r\n+        socketRef.current.on(\"user-joined\", ({ userId }: { userId: string }) => {\r\n+          console.log(\"ðŸ‘¥ User joined:\", userId);\r\n+          createPeer(userId, true);\r\n         });\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n+        // --- Handle Offers from Other Peers ---\r\n+        socketRef.current.on(\r\n+          \"room-offer\",\r\n+          async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n+            const pc = createPeer(from, false);\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+            const answer = await pc.createAnswer();\r\n+            await pc.setLocalDescription(answer);\r\n+            socketRef.current?.emit(\"room-answer\", { roomId, answer, to: from });\r\n+          }\r\n+        );\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n+        // --- Handle Answers from Other Peers ---\r\n+        socketRef.current.on(\r\n+          \"room-answer\",\r\n+          async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+            const pc = peerConnections.current[from];\r\n+            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          }\r\n+        );\r\n \r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+        // --- Handle ICE Candidates ---\r\n+        socketRef.current.on(\r\n+          \"room-ice\",\r\n+          async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+            const pc = peerConnections.current[from];\r\n+            if (pc) await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n           }\r\n-        };\r\n+        );\r\n \r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // --- Handle User Leaving ---\r\n+        socketRef.current.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n+          console.log(\"âŒ User left:\", userId);\r\n+          const pc = peerConnections.current[userId];\r\n+          if (pc) pc.close();\r\n+          delete peerConnections.current[userId];\r\n+          setRemoteStreams((prev) => {\r\n+            const updated = { ...prev };\r\n+            delete updated[userId];\r\n+            return updated;\r\n+          });\r\n+        });\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+        // --- Create Peer Connection ---\r\n+        const createPeer = (peerId: string, offer: boolean) => {\r\n+          if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n+          const pc = new RTCPeerConnection(iceServers);\r\n \r\n-          if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n-          }\r\n-        });\r\n+          // Add local tracks\r\n+          localStream?.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n-        });\r\n+          // On remote track\r\n+          pc.ontrack = (event) => {\r\n+            setRemoteStreams((prev) => ({ ...prev, [peerId]: event.streams[0] }));\r\n+          };\r\n \r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n-        });\r\n+          // On ICE candidate\r\n+          pc.onicecandidate = (event) => {\r\n+            if (event.candidate) {\r\n+              socketRef.current?.emit(\"room-ice\", {\r\n+                roomId,\r\n+                candidate: event.candidate,\r\n+                to: peerId,\r\n+              });\r\n+            }\r\n+          };\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n-          try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+          peerConnections.current[peerId] = pc;\r\n+\r\n+          if (offer) {\r\n+            // Create and send offer\r\n+            pc.createOffer()\r\n+              .then((o) => pc.setLocalDescription(o))\r\n+              .then(() => {\r\n+                socketRef.current?.emit(\"room-offer\", { roomId, offer: pc.localDescription, to: peerId });\r\n+              });\r\n           }\r\n-        });\r\n \r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+          return pc;\r\n+        };\r\n+      } catch (err) {\r\n+        console.error(\"âŒ WebRTC init failed:\", err);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n-      peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n+      Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId, isOfferer, isStarted]);\r\n \r\n-  return { localStream, remoteStream };\r\n+  return { localStream, remoteStreams };\r\n }\r\n"
                },
                {
                    "date": 1758893814428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,153 +1,132 @@\n-// features/anonymousChat/hooks/useWebRTC.ts\r\n import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-interface PeerStreams {\r\n-  [peerId: string]: MediaStream;\r\n-}\r\n-\r\n-export default function useWebRTC(\r\n-  roomId: string | null,\r\n-  isOfferer: boolean | null,\r\n-  isStarted: boolean\r\n-) {\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n+  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const [remoteStreams, setRemoteStreams] = useState<PeerStreams>({});\r\n-  const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n+  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production\r\n+      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted) return;\r\n+    if (!roomId || isOfferer === null || !isStarted) {\r\n+      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n+      return;\r\n+    }\r\n \r\n     const init = async () => {\r\n       if (!SOCKET_URL) {\r\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n       }\r\n \r\n       try {\r\n-        socketRef.current = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n+        // âœ… Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n         socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to signaling server:\", socketRef.current?.id);\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n         });\r\n \r\n-        // --- Local Media ---\r\n+        // âœ… Get local media stream AFTER user clicks Start\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // --- Join Room ---\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-        // --- Handle New Users Joining the Room ---\r\n-        socketRef.current.on(\"user-joined\", ({ userId }: { userId: string }) => {\r\n-          console.log(\"ðŸ‘¥ User joined:\", userId);\r\n-          createPeer(userId, true);\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n         });\r\n \r\n-        // --- Handle Offers from Other Peers ---\r\n-        socketRef.current.on(\r\n-          \"room-offer\",\r\n-          async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-            const pc = createPeer(from, false);\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-            const answer = await pc.createAnswer();\r\n-            await pc.setLocalDescription(answer);\r\n-            socketRef.current?.emit(\"room-answer\", { roomId, answer, to: from });\r\n-          }\r\n-        );\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n \r\n-        // --- Handle Answers from Other Peers ---\r\n-        socketRef.current.on(\r\n-          \"room-answer\",\r\n-          async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-            const pc = peerConnections.current[from];\r\n-            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-          }\r\n-        );\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n \r\n-        // --- Handle ICE Candidates ---\r\n-        socketRef.current.on(\r\n-          \"room-ice\",\r\n-          async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-            const pc = peerConnections.current[from];\r\n-            if (pc) await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n-        );\r\n+        };\r\n \r\n-        // --- Handle User Leaving ---\r\n-        socketRef.current.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n-          console.log(\"âŒ User left:\", userId);\r\n-          const pc = peerConnections.current[userId];\r\n-          if (pc) pc.close();\r\n-          delete peerConnections.current[userId];\r\n-          setRemoteStreams((prev) => {\r\n-            const updated = { ...prev };\r\n-            delete updated[userId];\r\n-            return updated;\r\n-          });\r\n-        });\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // --- Create Peer Connection ---\r\n-        const createPeer = (peerId: string, offer: boolean) => {\r\n-          if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n-          const pc = new RTCPeerConnection(iceServers);\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n-          // Add local tracks\r\n-          localStream?.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n+          if (isOfferer) {\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+          }\r\n+        });\r\n \r\n-          // On remote track\r\n-          pc.ontrack = (event) => {\r\n-            setRemoteStreams((prev) => ({ ...prev, [peerId]: event.streams[0] }));\r\n-          };\r\n+        // âœ… Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        });\r\n \r\n-          // On ICE candidate\r\n-          pc.onicecandidate = (event) => {\r\n-            if (event.candidate) {\r\n-              socketRef.current?.emit(\"room-ice\", {\r\n-                roomId,\r\n-                candidate: event.candidate,\r\n-                to: peerId,\r\n-              });\r\n-            }\r\n-          };\r\n+        // âœ… Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        });\r\n \r\n-          peerConnections.current[peerId] = pc;\r\n-\r\n-          if (offer) {\r\n-            // Create and send offer\r\n-            pc.createOffer()\r\n-              .then((o) => pc.setLocalDescription(o))\r\n-              .then(() => {\r\n-                socketRef.current?.emit(\"room-offer\", { roomId, offer: pc.localDescription, to: peerId });\r\n-              });\r\n+        // âœ… Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+          try {\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n+        });\r\n \r\n-          return pc;\r\n-        };\r\n-      } catch (err) {\r\n-        console.error(\"âŒ WebRTC init failed:\", err);\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n+      peerConnectionRef.current?.close();\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId, isOfferer, isStarted]);\r\n \r\n-  return { localStream, remoteStreams };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1758893840048,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,132 +1,153 @@\n+// features/anonymousChat/hooks/useWebRTC.ts\r\n import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n-  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n+interface PeerStreams {\r\n+  [peerId: string]: MediaStream;\r\n+}\r\n+\r\n+export default function useWebRTC(\r\n+  roomId: string | null,\r\n+  isOfferer: boolean | null,\r\n+  isStarted: boolean\r\n+) {\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n+  const [remoteStreams, setRemoteStreams] = useState<PeerStreams>({});\r\n+  const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n+      // ðŸ”’ Add TURN servers for production\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted) {\r\n-      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n-      return;\r\n-    }\r\n+    if (!roomId || isOfferer === null || !isStarted) return;\r\n \r\n     const init = async () => {\r\n       if (!SOCKET_URL) {\r\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n       }\r\n \r\n       try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n+        socketRef.current = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n \r\n         socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n+          console.log(\"âœ… Connected to signaling server:\", socketRef.current?.id);\r\n         });\r\n \r\n-        // âœ… Get local media stream AFTER user clicks Start\r\n+        // --- Local Media ---\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        // --- Join Room ---\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n+        // --- Handle New Users Joining the Room ---\r\n+        socketRef.current.on(\"user-joined\", ({ userId }: { userId: string }) => {\r\n+          console.log(\"ðŸ‘¥ User joined:\", userId);\r\n+          createPeer(userId, true);\r\n         });\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n+        // --- Handle Offers from Other Peers ---\r\n+        socketRef.current.on(\r\n+          \"room-offer\",\r\n+          async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n+            const pc = createPeer(from, false);\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+            const answer = await pc.createAnswer();\r\n+            await pc.setLocalDescription(answer);\r\n+            socketRef.current?.emit(\"room-answer\", { roomId, answer, to: from });\r\n+          }\r\n+        );\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n+        // --- Handle Answers from Other Peers ---\r\n+        socketRef.current.on(\r\n+          \"room-answer\",\r\n+          async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n+            const pc = peerConnections.current[from];\r\n+            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          }\r\n+        );\r\n \r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+        // --- Handle ICE Candidates ---\r\n+        socketRef.current.on(\r\n+          \"room-ice\",\r\n+          async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n+            const pc = peerConnections.current[from];\r\n+            if (pc) await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n           }\r\n-        };\r\n+        );\r\n \r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // --- Handle User Leaving ---\r\n+        socketRef.current.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n+          console.log(\"âŒ User left:\", userId);\r\n+          const pc = peerConnections.current[userId];\r\n+          if (pc) pc.close();\r\n+          delete peerConnections.current[userId];\r\n+          setRemoteStreams((prev) => {\r\n+            const updated = { ...prev };\r\n+            delete updated[userId];\r\n+            return updated;\r\n+          });\r\n+        });\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n+        // --- Create Peer Connection ---\r\n+        const createPeer = (peerId: string, offer: boolean) => {\r\n+          if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n+          const pc = new RTCPeerConnection(iceServers);\r\n \r\n-          if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n-          }\r\n-        });\r\n+          // Add local tracks\r\n+          localStream?.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n \r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n-        });\r\n+          // On remote track\r\n+          pc.ontrack = (event) => {\r\n+            setRemoteStreams((prev) => ({ ...prev, [peerId]: event.streams[0] }));\r\n+          };\r\n \r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n-        });\r\n+          // On ICE candidate\r\n+          pc.onicecandidate = (event) => {\r\n+            if (event.candidate) {\r\n+              socketRef.current?.emit(\"room-ice\", {\r\n+                roomId,\r\n+                candidate: event.candidate,\r\n+                to: peerId,\r\n+              });\r\n+            }\r\n+          };\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n-          try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+          peerConnections.current[peerId] = pc;\r\n+\r\n+          if (offer) {\r\n+            // Create and send offer\r\n+            pc.createOffer()\r\n+              .then((o) => pc.setLocalDescription(o))\r\n+              .then(() => {\r\n+                socketRef.current?.emit(\"room-offer\", { roomId, offer: pc.localDescription, to: peerId });\r\n+              });\r\n           }\r\n-        });\r\n \r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+          return pc;\r\n+        };\r\n+      } catch (err) {\r\n+        console.error(\"âŒ WebRTC init failed:\", err);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n-      peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n+      Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId, isOfferer, isStarted]);\r\n \r\n-  return { localStream, remoteStream };\r\n+  return { localStream, remoteStreams };\r\n }\r\n"
                },
                {
                    "date": 1758897479541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,153 +1,132 @@\n-// features/anonymousChat/hooks/useWebRTC.ts\r\n import { useEffect, useRef, useState } from \"react\";\r\n import { io, Socket } from \"socket.io-client\";\r\n \r\n const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n \r\n-interface PeerStreams {\r\n-  [peerId: string]: MediaStream;\r\n-}\r\n-\r\n-export default function useWebRTC(\r\n-  roomId: string | null,\r\n-  isOfferer: boolean | null,\r\n-  isStarted: boolean\r\n-) {\r\n+export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n+  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const [remoteStreams, setRemoteStreams] = useState<PeerStreams>({});\r\n-  const peerConnections = useRef<{ [peerId: string]: RTCPeerConnection }>({});\r\n+  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n   const socketRef = useRef<Socket | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production\r\n+      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted) return;\r\n+    if (!roomId || isOfferer === null || !isStarted) {\r\n+      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n+      return;\r\n+    }\r\n \r\n     const init = async () => {\r\n       if (!SOCKET_URL) {\r\n         console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n         return;\r\n       }\r\n \r\n       try {\r\n-        socketRef.current = io(SOCKET_URL, { transports: [\"websocket\"] });\r\n+        // âœ… Connect to signaling server\r\n+        socketRef.current = io(SOCKET_URL, {\r\n+          transports: [\"websocket\"],\r\n+        });\r\n \r\n         socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to signaling server:\", socketRef.current?.id);\r\n+          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n         });\r\n \r\n-        // --- Local Media ---\r\n+        // âœ… Get local media stream AFTER user clicks Start\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         setLocalStream(stream);\r\n+        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n-        // --- Join Room ---\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // âœ… Create RTCPeerConnection\r\n+        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n+        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n \r\n-        // --- Handle New Users Joining the Room ---\r\n-        socketRef.current.on(\"user-joined\", ({ userId }: { userId: string }) => {\r\n-          console.log(\"ðŸ‘¥ User joined:\", userId);\r\n-          createPeer(userId, true);\r\n+        // âœ… Add local tracks to peer connection\r\n+        stream.getTracks().forEach((track) => {\r\n+          peerConnectionRef.current?.addTrack(track, stream);\r\n         });\r\n \r\n-        // --- Handle Offers from Other Peers ---\r\n-        socketRef.current.on(\r\n-          \"room-offer\",\r\n-          async ({ from, offer }: { from: string; offer: RTCSessionDescriptionInit }) => {\r\n-            const pc = createPeer(from, false);\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-            const answer = await pc.createAnswer();\r\n-            await pc.setLocalDescription(answer);\r\n-            socketRef.current?.emit(\"room-answer\", { roomId, answer, to: from });\r\n-          }\r\n-        );\r\n+        // âœ… Handle remote stream\r\n+        peerConnectionRef.current.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n \r\n-        // --- Handle Answers from Other Peers ---\r\n-        socketRef.current.on(\r\n-          \"room-answer\",\r\n-          async ({ from, answer }: { from: string; answer: RTCSessionDescriptionInit }) => {\r\n-            const pc = peerConnections.current[from];\r\n-            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-          }\r\n-        );\r\n+        // âœ… Monitor connection state\r\n+        peerConnectionRef.current.onconnectionstatechange = () => {\r\n+          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n+        };\r\n \r\n-        // --- Handle ICE Candidates ---\r\n-        socketRef.current.on(\r\n-          \"room-ice\",\r\n-          async ({ from, candidate }: { from: string; candidate: RTCIceCandidateInit }) => {\r\n-            const pc = peerConnections.current[from];\r\n-            if (pc) await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+        // âœ… Handle ICE candidates generated locally\r\n+        peerConnectionRef.current.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n+            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n-        );\r\n+        };\r\n \r\n-        // --- Handle User Leaving ---\r\n-        socketRef.current.on(\"user-left\", ({ userId }: { userId: string }) => {\r\n-          console.log(\"âŒ User left:\", userId);\r\n-          const pc = peerConnections.current[userId];\r\n-          if (pc) pc.close();\r\n-          delete peerConnections.current[userId];\r\n-          setRemoteStreams((prev) => {\r\n-            const updated = { ...prev };\r\n-            delete updated[userId];\r\n-            return updated;\r\n-          });\r\n-        });\r\n+        // âœ… Join room and wait for confirmation before offer creation\r\n+        socketRef.current.emit(\"join-room\", roomId);\r\n \r\n-        // --- Create Peer Connection ---\r\n-        const createPeer = (peerId: string, offer: boolean) => {\r\n-          if (peerConnections.current[peerId]) return peerConnections.current[peerId];\r\n-          const pc = new RTCPeerConnection(iceServers);\r\n+        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n+          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n \r\n-          // Add local tracks\r\n-          localStream?.getTracks().forEach((track) => pc.addTrack(track, localStream));\r\n+          if (isOfferer) {\r\n+            console.log(\"ðŸ“ž Creating offer...\");\r\n+            const offer = await peerConnectionRef.current!.createOffer();\r\n+            await peerConnectionRef.current!.setLocalDescription(offer);\r\n+            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n+            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+          }\r\n+        });\r\n \r\n-          // On remote track\r\n-          pc.ontrack = (event) => {\r\n-            setRemoteStreams((prev) => ({ ...prev, [peerId]: event.streams[0] }));\r\n-          };\r\n+        // âœ… Listen for offer\r\n+        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n+          console.log(\"ðŸ“© Received offer:\", offer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await peerConnectionRef.current!.createAnswer();\r\n+          await peerConnectionRef.current!.setLocalDescription(answer);\r\n+          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n+          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        });\r\n \r\n-          // On ICE candidate\r\n-          pc.onicecandidate = (event) => {\r\n-            if (event.candidate) {\r\n-              socketRef.current?.emit(\"room-ice\", {\r\n-                roomId,\r\n-                candidate: event.candidate,\r\n-                to: peerId,\r\n-              });\r\n-            }\r\n-          };\r\n+        // âœ… Listen for answer\r\n+        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n+          console.log(\"ðŸ“© Received answer:\", answer);\r\n+          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        });\r\n \r\n-          peerConnections.current[peerId] = pc;\r\n-\r\n-          if (offer) {\r\n-            // Create and send offer\r\n-            pc.createOffer()\r\n-              .then((o) => pc.setLocalDescription(o))\r\n-              .then(() => {\r\n-                socketRef.current?.emit(\"room-offer\", { roomId, offer: pc.localDescription, to: peerId });\r\n-              });\r\n+        // âœ… Listen for ICE candidates from remote peer\r\n+        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+          try {\r\n+            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (error) {\r\n+            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n           }\r\n+        });\r\n \r\n-          return pc;\r\n-        };\r\n-      } catch (err) {\r\n-        console.error(\"âŒ WebRTC init failed:\", err);\r\n+      } catch (error) {\r\n+        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      Object.values(peerConnections.current).forEach((pc) => pc.close());\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n+      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n+      peerConnectionRef.current?.close();\r\n+      localStream?.getTracks().forEach((track) => track.stop());\r\n       socketRef.current?.disconnect();\r\n     };\r\n   }, [roomId, isOfferer, isStarted]);\r\n \r\n-  return { localStream, remoteStreams };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1758996146553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,132 +1,106 @@\n import { useEffect, useRef, useState } from \"react\";\r\n-import { io, Socket } from \"socket.io-client\";\r\n+import { Socket } from \"socket.io-client\";\r\n \r\n-const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL;\r\n+interface UseWebRTCProps {\r\n+  roomId: string | null;\r\n+  isOfferer: boolean | null;\r\n+  isStarted: boolean;\r\n+  socket: Socket | null; // Reuse the socket from useSocket\r\n+}\r\n \r\n-export default function useWebRTC(roomId: string | null, isOfferer: boolean | null, isStarted: boolean) {\r\n+export default function useWebRTC({\r\n+  roomId,\r\n+  isOfferer,\r\n+  isStarted,\r\n+  socket,\r\n+}: UseWebRTCProps) {\r\n+  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n-  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n-  const socketRef = useRef<Socket | null>(null);\r\n+  const peerRef = useRef<RTCPeerConnection | null>(null);\r\n \r\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // ðŸ”’ Add TURN servers for production behind NAT/firewalls\r\n+      // Add TURN server for production\r\n     ],\r\n   };\r\n \r\n   useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted) {\r\n-      console.log(\"â³ Waiting for Start button click + server-assigned roomId + role...\");\r\n-      return;\r\n-    }\r\n+    if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n \r\n+    let isMounted = true;\r\n+\r\n     const init = async () => {\r\n-      if (!SOCKET_URL) {\r\n-        console.error(\"âŒ NEXT_PUBLIC_SOCKET_URL is not defined\");\r\n-        return;\r\n-      }\r\n-\r\n       try {\r\n-        // âœ… Connect to signaling server\r\n-        socketRef.current = io(SOCKET_URL, {\r\n-          transports: [\"websocket\"],\r\n-        });\r\n-\r\n-        socketRef.current.on(\"connect\", () => {\r\n-          console.log(\"âœ… Connected to socket server:\", socketRef.current?.id);\r\n-        });\r\n-\r\n-        // âœ… Get local media stream AFTER user clicks Start\r\n+        // âœ… Get local media\r\n         const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        if (!isMounted) return;\r\n         setLocalStream(stream);\r\n-        console.log(\"ðŸ“· Obtained local media stream\");\r\n \r\n         // âœ… Create RTCPeerConnection\r\n-        peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n-        console.log(\"ðŸ”§ Created RTCPeerConnection\");\r\n+        const pc = new RTCPeerConnection(iceServers);\r\n+        peerRef.current = pc;\r\n \r\n-        // âœ… Add local tracks to peer connection\r\n-        stream.getTracks().forEach((track) => {\r\n-          peerConnectionRef.current?.addTrack(track, stream);\r\n-        });\r\n+        // Add local tracks\r\n+        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n-        // âœ… Handle remote stream\r\n-        peerConnectionRef.current.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Received remote stream track\");\r\n+        // Receive remote tracks\r\n+        pc.ontrack = (event) => {\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // âœ… Monitor connection state\r\n-        peerConnectionRef.current.onconnectionstatechange = () => {\r\n-          console.log(\"ðŸ”— Connection state:\", peerConnectionRef.current?.connectionState);\r\n-        };\r\n-\r\n-        // âœ… Handle ICE candidates generated locally\r\n-        peerConnectionRef.current.onicecandidate = (event) => {\r\n+        // Send ICE candidates\r\n+        pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n-            console.log(\"ðŸ“¤ Sending ICE candidate\");\r\n-            socketRef.current?.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // âœ… Join room and wait for confirmation before offer creation\r\n-        socketRef.current.emit(\"join-room\", roomId);\r\n+        // Join room and handle offer/answer\r\n+        socket.emit(\"join-room\", roomId);\r\n \r\n-        socketRef.current.on(\"joined-room\", async (joinedRoomId) => {\r\n-          console.log(\"ðŸ  Successfully joined room:\", joinedRoomId);\r\n-\r\n+        socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n-            console.log(\"ðŸ“ž Creating offer...\");\r\n-            const offer = await peerConnectionRef.current!.createOffer();\r\n-            await peerConnectionRef.current!.setLocalDescription(offer);\r\n-            socketRef.current?.emit(\"offer\", { offer, roomId });\r\n-            console.log(\"ðŸ“¤ Sent offer:\", offer);\r\n+            const offer = await pc.createOffer();\r\n+            await pc.setLocalDescription(offer);\r\n+            socket.emit(\"offer\", { offer, roomId });\r\n           }\r\n         });\r\n \r\n-        // âœ… Listen for offer\r\n-        socketRef.current.on(\"offer\", async ({ offer }) => {\r\n-          console.log(\"ðŸ“© Received offer:\", offer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await peerConnectionRef.current!.createAnswer();\r\n-          await peerConnectionRef.current!.setLocalDescription(answer);\r\n-          socketRef.current?.emit(\"answer\", { answer, roomId });\r\n-          console.log(\"ðŸ“¤ Sent answer:\", answer);\r\n+        socket.on(\"offer\", async ({ offer }) => {\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await pc.createAnswer();\r\n+          await pc.setLocalDescription(answer);\r\n+          socket.emit(\"answer\", { answer, roomId });\r\n         });\r\n \r\n-        // âœ… Listen for answer\r\n-        socketRef.current.on(\"answer\", async ({ answer }) => {\r\n-          console.log(\"ðŸ“© Received answer:\", answer);\r\n-          await peerConnectionRef.current!.setRemoteDescription(new RTCSessionDescription(answer));\r\n+        socket.on(\"answer\", async ({ answer }) => {\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n-        // âœ… Listen for ICE candidates from remote peer\r\n-        socketRef.current.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          console.log(\"ðŸ“© Received ICE candidate:\", candidate);\r\n+        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n-            await peerConnectionRef.current!.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (error) {\r\n-            console.error(\"âŒ Error adding received ICE candidate:\", error);\r\n+            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (err) {\r\n+            console.error(\"Failed to add ICE candidate:\", err);\r\n           }\r\n         });\r\n \r\n-      } catch (error) {\r\n-        console.error(\"âŒ Failed to initialize WebRTC:\", error);\r\n+      } catch (err) {\r\n+        console.error(\"âŒ WebRTC init error:\", err);\r\n       }\r\n     };\r\n \r\n     init();\r\n \r\n     return () => {\r\n-      console.log(\"ðŸ§¹ Cleaning up WebRTC and socket connections\");\r\n-      peerConnectionRef.current?.close();\r\n-      localStream?.getTracks().forEach((track) => track.stop());\r\n-      socketRef.current?.disconnect();\r\n+      isMounted = false;\r\n+      peerRef.current?.close();\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n+      peerRef.current = null;\r\n     };\r\n-  }, [roomId, isOfferer, isStarted]);\r\n+  }, [roomId, isOfferer, isStarted, socket]);\r\n \r\n   return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1760104496707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n-import { useEffect, useRef, useState } from \"react\";\r\n+import { useEffect, useRef, useState, useCallback } from \"react\";\r\n import { Socket } from \"socket.io-client\";\r\n \r\n interface UseWebRTCProps {\r\n   roomId: string | null;\r\n   isOfferer: boolean | null;\r\n   isStarted: boolean;\r\n-  socket: Socket | null; // Reuse the socket from useSocket\r\n+  socket: Socket | null;\r\n }\r\n \r\n export default function useWebRTC({\r\n   roomId,\r\n@@ -21,46 +21,81 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // Add TURN server for production\r\n+      // You can add a TURN server for production if needed\r\n     ],\r\n   };\r\n \r\n+  /**\r\n+   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n+   */\r\n+  const cleanup = useCallback(() => {\r\n+    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n+\r\n+    try {\r\n+      peerRef.current?.getSenders()?.forEach((sender) => {\r\n+        if (sender.track) sender.track.stop();\r\n+      });\r\n+\r\n+      peerRef.current?.close();\r\n+      peerRef.current = null;\r\n+\r\n+      if (localStream) {\r\n+        localStream.getTracks().forEach((track) => track.stop());\r\n+        setLocalStream(null);\r\n+      }\r\n+\r\n+      if (remoteStream) {\r\n+        remoteStream.getTracks().forEach((track) => track.stop());\r\n+        setRemoteStream(null);\r\n+      }\r\n+    } catch (err) {\r\n+      console.error(\"Cleanup error:\", err);\r\n+    }\r\n+  }, [localStream, remoteStream]);\r\n+\r\n+  /**\r\n+   * ðŸŽ¥ Initialize WebRTC\r\n+   */\r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n \r\n     let isMounted = true;\r\n \r\n     const init = async () => {\r\n       try {\r\n-        // âœ… Get local media\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        console.log(\"ðŸŽ¬ Initializing WebRTC...\");\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n+        });\r\n         if (!isMounted) return;\r\n         setLocalStream(stream);\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n         const pc = new RTCPeerConnection(iceServers);\r\n         peerRef.current = pc;\r\n \r\n         // Add local tracks\r\n         stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n         // Receive remote tracks\r\n         pc.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Remote stream received\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // Send ICE candidates\r\n+        // Handle ICE candidates\r\n         pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n             socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // Join room and handle offer/answer\r\n+        // Join room\r\n         socket.emit(\"join-room\", roomId);\r\n \r\n+        // Handle signaling events\r\n         socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n             const offer = await pc.createOffer();\r\n             await pc.setLocalDescription(offer);\r\n@@ -68,26 +103,29 @@\n           }\r\n         });\r\n \r\n         socket.on(\"offer\", async ({ offer }) => {\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await pc.createAnswer();\r\n-          await pc.setLocalDescription(answer);\r\n-          socket.emit(\"answer\", { answer, roomId });\r\n+          if (!pc.currentRemoteDescription) {\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+            const answer = await pc.createAnswer();\r\n+            await pc.setLocalDescription(answer);\r\n+            socket.emit(\"answer\", { answer, roomId });\r\n+          }\r\n         });\r\n \r\n         socket.on(\"answer\", async ({ answer }) => {\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          if (!pc.currentRemoteDescription) {\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          }\r\n         });\r\n \r\n         socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n             await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (err) {\r\n-            console.error(\"Failed to add ICE candidate:\", err);\r\n+            console.error(\"âŒ Failed to add ICE candidate:\", err);\r\n           }\r\n         });\r\n-\r\n       } catch (err) {\r\n         console.error(\"âŒ WebRTC init error:\", err);\r\n       }\r\n     };\r\n@@ -95,12 +133,10 @@\n     init();\r\n \r\n     return () => {\r\n       isMounted = false;\r\n-      peerRef.current?.close();\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n-      peerRef.current = null;\r\n+      cleanup();\r\n     };\r\n-  }, [roomId, isOfferer, isStarted, socket]);\r\n+  }, [roomId, isOfferer, isStarted, socket, cleanup]);\r\n \r\n-  return { localStream, remoteStream };\r\n+  return { localStream, remoteStream, cleanup };\r\n }\r\n"
                },
                {
                    "date": 1760112506766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,162 @@\n+import { useEffect, useRef, useState, useCallback } from \"react\";\r\n+import { Socket } from \"socket.io-client\";\r\n+\r\n+interface UseWebRTCProps {\r\n+  roomId: string | null;\r\n+  isOfferer: boolean | null;\r\n+  isStarted: boolean;\r\n+  socket: Socket | null;\r\n+  muted?: boolean; // âœ… Added optional muted prop\r\n+}\r\n+\r\n+export default function useWebRTC({\r\n+  roomId,\r\n+  isOfferer,\r\n+  isStarted,\r\n+  socket,\r\n+  muted = false,\r\n+}: UseWebRTCProps) {\r\n+  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n+  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n+  const peerRef = useRef<RTCPeerConnection | null>(null);\r\n+\r\n+  const iceServers = {\r\n+    iceServers: [\r\n+      { urls: \"stun:stun.l.google.com:19302\" },\r\n+      { urls: \"stun:stun1.l.google.com:19302\" },\r\n+      // Add TURN server for production if needed\r\n+    ],\r\n+  };\r\n+\r\n+  /**\r\n+   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n+   */\r\n+  const cleanup = useCallback(() => {\r\n+    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n+\r\n+    try {\r\n+      peerRef.current?.getSenders()?.forEach((sender) => {\r\n+        if (sender.track) sender.track.stop();\r\n+      });\r\n+\r\n+      peerRef.current?.close();\r\n+      peerRef.current = null;\r\n+\r\n+      if (localStream) {\r\n+        localStream.getTracks().forEach((track) => track.stop());\r\n+        setLocalStream(null);\r\n+      }\r\n+\r\n+      if (remoteStream) {\r\n+        remoteStream.getTracks().forEach((track) => track.stop());\r\n+        setRemoteStream(null);\r\n+      }\r\n+    } catch (err) {\r\n+      console.error(\"Cleanup error:\", err);\r\n+    }\r\n+  }, [localStream, remoteStream]);\r\n+\r\n+  /**\r\n+   * ðŸŽ¥ Initialize WebRTC\r\n+   */\r\n+  useEffect(() => {\r\n+    if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n+\r\n+    let isMounted = true;\r\n+\r\n+    const init = async () => {\r\n+      try {\r\n+        console.log(\"ðŸŽ¬ Initializing WebRTC...\");\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n+        });\r\n+        if (!isMounted) return;\r\n+\r\n+        // âœ… Apply mute state immediately after getting stream\r\n+        stream.getAudioTracks().forEach((track) => (track.enabled = !muted));\r\n+\r\n+        setLocalStream(stream);\r\n+\r\n+        const pc = new RTCPeerConnection(iceServers);\r\n+        peerRef.current = pc;\r\n+\r\n+        // Add local tracks\r\n+        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n+\r\n+        // Receive remote tracks\r\n+        pc.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Remote stream received\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n+\r\n+        // Handle ICE candidates\r\n+        pc.onicecandidate = (event) => {\r\n+          if (event.candidate) {\r\n+            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          }\r\n+        };\r\n+\r\n+        // Join room\r\n+        socket.emit(\"join-room\", roomId);\r\n+\r\n+        // Handle signaling events\r\n+        socket.on(\"joined-room\", async () => {\r\n+          if (isOfferer) {\r\n+            const offer = await pc.createOffer();\r\n+            await pc.setLocalDescription(offer);\r\n+            socket.emit(\"offer\", { offer, roomId });\r\n+          }\r\n+        });\r\n+\r\n+        socket.on(\"offer\", async ({ offer }) => {\r\n+          if (!pc.currentRemoteDescription) {\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+            const answer = await pc.createAnswer();\r\n+            await pc.setLocalDescription(answer);\r\n+            socket.emit(\"answer\", { answer, roomId });\r\n+          }\r\n+        });\r\n+\r\n+        socket.on(\"answer\", async ({ answer }) => {\r\n+          if (!pc.currentRemoteDescription) {\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          }\r\n+        });\r\n+\r\n+        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n+          try {\r\n+            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n+          } catch (err) {\r\n+            console.error(\"âŒ Failed to add ICE candidate:\", err);\r\n+          }\r\n+        });\r\n+      } catch (err) {\r\n+        console.error(\"âŒ WebRTC init error:\", err);\r\n+      }\r\n+    };\r\n+\r\n+    init();\r\n+\r\n+    return () => {\r\n+      isMounted = false;\r\n+      cleanup();\r\n+    };\r\n+  }, [roomId, isOfferer, isStarted, socket, cleanup, muted]);\r\n+\r\n+  /**\r\n+   * ðŸŽ¤ Sync mute state dynamically if user toggles mic\r\n+   */\r\n+  useEffect(() => {\r\n+    if (!localStream) return;\r\n+    try {\r\n+      localStream.getAudioTracks().forEach((track) => {\r\n+        track.enabled = !muted;\r\n+      });\r\n+    } catch (err) {\r\n+      console.warn(\"âš ï¸ Failed to toggle mic:\", err);\r\n+    }\r\n+  }, [muted, localStream]);\r\n+\r\n+  return { localStream, remoteStream, cleanup };\r\n+}\r\n"
                },
                {
                    "date": 1760113450979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n   roomId: string | null;\r\n   isOfferer: boolean | null;\r\n   isStarted: boolean;\r\n   socket: Socket | null;\r\n-  muted?: boolean; // âœ… Added optional muted prop\r\n+  muted?: boolean; // optional mic mute\r\n }\r\n \r\n export default function useWebRTC({\r\n   roomId,\r\n@@ -28,28 +28,30 @@\n     ],\r\n   };\r\n \r\n   /**\r\n-   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n+   * ðŸ§¹ Cleanup â€” stop tracks & close connection\r\n    */\r\n   const cleanup = useCallback(() => {\r\n-    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n-\r\n+    console.log(\"ðŸ§¹ Cleaning up WebRTC...\");\r\n     try {\r\n-      peerRef.current?.getSenders()?.forEach((sender) => {\r\n+      // Stop all tracks in peer connection\r\n+      peerRef.current?.getSenders().forEach((sender) => {\r\n         if (sender.track) sender.track.stop();\r\n       });\r\n \r\n       peerRef.current?.close();\r\n       peerRef.current = null;\r\n \r\n+      // Stop local stream\r\n       if (localStream) {\r\n-        localStream.getTracks().forEach((track) => track.stop());\r\n+        localStream.getTracks().forEach((t) => t.stop());\r\n         setLocalStream(null);\r\n       }\r\n \r\n+      // Stop remote stream\r\n       if (remoteStream) {\r\n-        remoteStream.getTracks().forEach((track) => track.stop());\r\n+        remoteStream.getTracks().forEach((t) => t.stop());\r\n         setRemoteStream(null);\r\n       }\r\n     } catch (err) {\r\n       console.error(\"Cleanup error:\", err);\r\n@@ -70,38 +72,32 @@\n         const stream = await navigator.mediaDevices.getUserMedia({\r\n           video: true,\r\n           audio: true,\r\n         });\r\n+\r\n         if (!isMounted) return;\r\n \r\n-        // âœ… Apply mute state immediately after getting stream\r\n+        // Apply initial mute\r\n         stream.getAudioTracks().forEach((track) => (track.enabled = !muted));\r\n-\r\n         setLocalStream(stream);\r\n \r\n         const pc = new RTCPeerConnection(iceServers);\r\n         peerRef.current = pc;\r\n \r\n-        // Add local tracks\r\n+        // Add tracks\r\n         stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n-        // Receive remote tracks\r\n-        pc.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Remote stream received\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n+        // Remote tracks\r\n+        pc.ontrack = (event) => setRemoteStream(event.streams[0]);\r\n \r\n-        // Handle ICE candidates\r\n+        // ICE candidates\r\n         pc.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-          }\r\n+          if (event.candidate) socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n         };\r\n \r\n         // Join room\r\n         socket.emit(\"join-room\", roomId);\r\n \r\n-        // Handle signaling events\r\n         socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n             const offer = await pc.createOffer();\r\n             await pc.setLocalDescription(offer);\r\n@@ -144,161 +140,15 @@\n     };\r\n   }, [roomId, isOfferer, isStarted, socket, cleanup, muted]);\r\n \r\n   /**\r\n-   * ðŸŽ¤ Sync mute state dynamically if user toggles mic\r\n+   * ðŸŽ¤ Dynamic mic toggle\r\n    */\r\n   useEffect(() => {\r\n     if (!localStream) return;\r\n-    try {\r\n-      localStream.getAudioTracks().forEach((track) => {\r\n-        track.enabled = !muted;\r\n-      });\r\n-    } catch (err) {\r\n-      console.warn(\"âš ï¸ Failed to toggle mic:\", err);\r\n-    }\r\n+    localStream.getAudioTracks().forEach((track) => {\r\n+      track.enabled = !muted;\r\n+    });\r\n   }, [muted, localStream]);\r\n \r\n   return { localStream, remoteStream, cleanup };\r\n }\r\n-import { useEffect, useRef, useState, useCallback } from \"react\";\r\n-import { Socket } from \"socket.io-client\";\r\n-\r\n-interface UseWebRTCProps {\r\n-  roomId: string | null;\r\n-  isOfferer: boolean | null;\r\n-  isStarted: boolean;\r\n-  socket: Socket | null;\r\n-}\r\n-\r\n-export default function useWebRTC({\r\n-  roomId,\r\n-  isOfferer,\r\n-  isStarted,\r\n-  socket,\r\n-}: UseWebRTCProps) {\r\n-  const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n-  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n-  const peerRef = useRef<RTCPeerConnection | null>(null);\r\n-\r\n-  const iceServers = {\r\n-    iceServers: [\r\n-      { urls: \"stun:stun.l.google.com:19302\" },\r\n-      { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // You can add a TURN server for production if needed\r\n-    ],\r\n-  };\r\n-\r\n-  /**\r\n-   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n-   */\r\n-  const cleanup = useCallback(() => {\r\n-    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n-\r\n-    try {\r\n-      peerRef.current?.getSenders()?.forEach((sender) => {\r\n-        if (sender.track) sender.track.stop();\r\n-      });\r\n-\r\n-      peerRef.current?.close();\r\n-      peerRef.current = null;\r\n-\r\n-      if (localStream) {\r\n-        localStream.getTracks().forEach((track) => track.stop());\r\n-        setLocalStream(null);\r\n-      }\r\n-\r\n-      if (remoteStream) {\r\n-        remoteStream.getTracks().forEach((track) => track.stop());\r\n-        setRemoteStream(null);\r\n-      }\r\n-    } catch (err) {\r\n-      console.error(\"Cleanup error:\", err);\r\n-    }\r\n-  }, [localStream, remoteStream]);\r\n-\r\n-  /**\r\n-   * ðŸŽ¥ Initialize WebRTC\r\n-   */\r\n-  useEffect(() => {\r\n-    if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n-\r\n-    let isMounted = true;\r\n-\r\n-    const init = async () => {\r\n-      try {\r\n-        console.log(\"ðŸŽ¬ Initializing WebRTC...\");\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n-        if (!isMounted) return;\r\n-        setLocalStream(stream);\r\n-\r\n-        const pc = new RTCPeerConnection(iceServers);\r\n-        peerRef.current = pc;\r\n-\r\n-        // Add local tracks\r\n-        stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n-\r\n-        // Receive remote tracks\r\n-        pc.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Remote stream received\");\r\n-          setRemoteStream(event.streams[0]);\r\n-        };\r\n-\r\n-        // Handle ICE candidates\r\n-        pc.onicecandidate = (event) => {\r\n-          if (event.candidate) {\r\n-            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n-          }\r\n-        };\r\n-\r\n-        // Join room\r\n-        socket.emit(\"join-room\", roomId);\r\n-\r\n-        // Handle signaling events\r\n-        socket.on(\"joined-room\", async () => {\r\n-          if (isOfferer) {\r\n-            const offer = await pc.createOffer();\r\n-            await pc.setLocalDescription(offer);\r\n-            socket.emit(\"offer\", { offer, roomId });\r\n-          }\r\n-        });\r\n-\r\n-        socket.on(\"offer\", async ({ offer }) => {\r\n-          if (!pc.currentRemoteDescription) {\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-            const answer = await pc.createAnswer();\r\n-            await pc.setLocalDescription(answer);\r\n-            socket.emit(\"answer\", { answer, roomId });\r\n-          }\r\n-        });\r\n-\r\n-        socket.on(\"answer\", async ({ answer }) => {\r\n-          if (!pc.currentRemoteDescription) {\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-          }\r\n-        });\r\n-\r\n-        socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n-          try {\r\n-            await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n-          } catch (err) {\r\n-            console.error(\"âŒ Failed to add ICE candidate:\", err);\r\n-          }\r\n-        });\r\n-      } catch (err) {\r\n-        console.error(\"âŒ WebRTC init error:\", err);\r\n-      }\r\n-    };\r\n-\r\n-    init();\r\n-\r\n-    return () => {\r\n-      isMounted = false;\r\n-      cleanup();\r\n-    };\r\n-  }, [roomId, isOfferer, isStarted, socket, cleanup]);\r\n-\r\n-  return { localStream, remoteStream, cleanup };\r\n-}\r\n"
                },
                {
                    "date": 1760114051824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,17 +5,15 @@\n   roomId: string | null;\r\n   isOfferer: boolean | null;\r\n   isStarted: boolean;\r\n   socket: Socket | null;\r\n-  muted?: boolean; // optional mic mute\r\n }\r\n \r\n export default function useWebRTC({\r\n   roomId,\r\n   isOfferer,\r\n   isStarted,\r\n   socket,\r\n-  muted = false,\r\n }: UseWebRTCProps) {\r\n   const [localStream, setLocalStream] = useState<MediaStream | null>(null);\r\n   const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n   const peerRef = useRef<RTCPeerConnection | null>(null);\r\n@@ -23,35 +21,33 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // Add TURN server for production if needed\r\n+      // You can add a TURN server for production if needed\r\n     ],\r\n   };\r\n \r\n   /**\r\n-   * ðŸ§¹ Cleanup â€” stop tracks & close connection\r\n+   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n    */\r\n   const cleanup = useCallback(() => {\r\n-    console.log(\"ðŸ§¹ Cleaning up WebRTC...\");\r\n+    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n+\r\n     try {\r\n-      // Stop all tracks in peer connection\r\n-      peerRef.current?.getSenders().forEach((sender) => {\r\n+      peerRef.current?.getSenders()?.forEach((sender) => {\r\n         if (sender.track) sender.track.stop();\r\n       });\r\n \r\n       peerRef.current?.close();\r\n       peerRef.current = null;\r\n \r\n-      // Stop local stream\r\n       if (localStream) {\r\n-        localStream.getTracks().forEach((t) => t.stop());\r\n+        localStream.getTracks().forEach((track) => track.stop());\r\n         setLocalStream(null);\r\n       }\r\n \r\n-      // Stop remote stream\r\n       if (remoteStream) {\r\n-        remoteStream.getTracks().forEach((t) => t.stop());\r\n+        remoteStream.getTracks().forEach((track) => track.stop());\r\n         setRemoteStream(null);\r\n       }\r\n     } catch (err) {\r\n       console.error(\"Cleanup error:\", err);\r\n@@ -72,32 +68,34 @@\n         const stream = await navigator.mediaDevices.getUserMedia({\r\n           video: true,\r\n           audio: true,\r\n         });\r\n-\r\n         if (!isMounted) return;\r\n-\r\n-        // Apply initial mute\r\n-        stream.getAudioTracks().forEach((track) => (track.enabled = !muted));\r\n         setLocalStream(stream);\r\n \r\n         const pc = new RTCPeerConnection(iceServers);\r\n         peerRef.current = pc;\r\n \r\n-        // Add tracks\r\n+        // Add local tracks\r\n         stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n-        // Remote tracks\r\n-        pc.ontrack = (event) => setRemoteStream(event.streams[0]);\r\n+        // Receive remote tracks\r\n+        pc.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Remote stream received\");\r\n+          setRemoteStream(event.streams[0]);\r\n+        };\r\n \r\n-        // ICE candidates\r\n+        // Handle ICE candidates\r\n         pc.onicecandidate = (event) => {\r\n-          if (event.candidate) socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          if (event.candidate) {\r\n+            socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n+          }\r\n         };\r\n \r\n         // Join room\r\n         socket.emit(\"join-room\", roomId);\r\n \r\n+        // Handle signaling events\r\n         socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n             const offer = await pc.createOffer();\r\n             await pc.setLocalDescription(offer);\r\n@@ -137,18 +135,8 @@\n     return () => {\r\n       isMounted = false;\r\n       cleanup();\r\n     };\r\n-  }, [roomId, isOfferer, isStarted, socket, cleanup, muted]);\r\n+  }, [roomId, isOfferer, isStarted, socket, cleanup]);\r\n \r\n-  /**\r\n-   * ðŸŽ¤ Dynamic mic toggle\r\n-   */\r\n-  useEffect(() => {\r\n-    if (!localStream) return;\r\n-    localStream.getAudioTracks().forEach((track) => {\r\n-      track.enabled = !muted;\r\n-    });\r\n-  }, [muted, localStream]);\r\n-\r\n   return { localStream, remoteStream, cleanup };\r\n }\r\n"
                },
                {
                    "date": 1760115083418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n-import { useEffect, useRef, useState, useCallback } from \"react\";\r\n+import { useEffect, useRef, useState } from \"react\";\r\n import { Socket } from \"socket.io-client\";\r\n \r\n interface UseWebRTCProps {\r\n   roomId: string | null;\r\n   isOfferer: boolean | null;\r\n   isStarted: boolean;\r\n-  socket: Socket | null;\r\n+  socket: Socket | null; // Reuse the socket from useSocket\r\n }\r\n \r\n export default function useWebRTC({\r\n   roomId,\r\n@@ -21,81 +21,46 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // You can add a TURN server for production if needed\r\n+      // Add TURN server for production\r\n     ],\r\n   };\r\n \r\n-  /**\r\n-   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n-   */\r\n-  const cleanup = useCallback(() => {\r\n-    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n-\r\n-    try {\r\n-      peerRef.current?.getSenders()?.forEach((sender) => {\r\n-        if (sender.track) sender.track.stop();\r\n-      });\r\n-\r\n-      peerRef.current?.close();\r\n-      peerRef.current = null;\r\n-\r\n-      if (localStream) {\r\n-        localStream.getTracks().forEach((track) => track.stop());\r\n-        setLocalStream(null);\r\n-      }\r\n-\r\n-      if (remoteStream) {\r\n-        remoteStream.getTracks().forEach((track) => track.stop());\r\n-        setRemoteStream(null);\r\n-      }\r\n-    } catch (err) {\r\n-      console.error(\"Cleanup error:\", err);\r\n-    }\r\n-  }, [localStream, remoteStream]);\r\n-\r\n-  /**\r\n-   * ðŸŽ¥ Initialize WebRTC\r\n-   */\r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n \r\n     let isMounted = true;\r\n \r\n     const init = async () => {\r\n       try {\r\n-        console.log(\"ðŸŽ¬ Initializing WebRTC...\");\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n+        // âœ… Get local media\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         if (!isMounted) return;\r\n         setLocalStream(stream);\r\n \r\n+        // âœ… Create RTCPeerConnection\r\n         const pc = new RTCPeerConnection(iceServers);\r\n         peerRef.current = pc;\r\n \r\n         // Add local tracks\r\n         stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n         // Receive remote tracks\r\n         pc.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Remote stream received\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // Handle ICE candidates\r\n+        // Send ICE candidates\r\n         pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n             socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // Join room\r\n+        // Join room and handle offer/answer\r\n         socket.emit(\"join-room\", roomId);\r\n \r\n-        // Handle signaling events\r\n         socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n             const offer = await pc.createOffer();\r\n             await pc.setLocalDescription(offer);\r\n@@ -103,29 +68,26 @@\n           }\r\n         });\r\n \r\n         socket.on(\"offer\", async ({ offer }) => {\r\n-          if (!pc.currentRemoteDescription) {\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-            const answer = await pc.createAnswer();\r\n-            await pc.setLocalDescription(answer);\r\n-            socket.emit(\"answer\", { answer, roomId });\r\n-          }\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await pc.createAnswer();\r\n+          await pc.setLocalDescription(answer);\r\n+          socket.emit(\"answer\", { answer, roomId });\r\n         });\r\n \r\n         socket.on(\"answer\", async ({ answer }) => {\r\n-          if (!pc.currentRemoteDescription) {\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-          }\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n         socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n             await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (err) {\r\n-            console.error(\"âŒ Failed to add ICE candidate:\", err);\r\n+            console.error(\"Failed to add ICE candidate:\", err);\r\n           }\r\n         });\r\n+\r\n       } catch (err) {\r\n         console.error(\"âŒ WebRTC init error:\", err);\r\n       }\r\n     };\r\n@@ -133,10 +95,12 @@\n     init();\r\n \r\n     return () => {\r\n       isMounted = false;\r\n-      cleanup();\r\n+      peerRef.current?.close();\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n+      peerRef.current = null;\r\n     };\r\n-  }, [roomId, isOfferer, isStarted, socket, cleanup]);\r\n+  }, [roomId, isOfferer, isStarted, socket]);\r\n \r\n-  return { localStream, remoteStream, cleanup };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                },
                {
                    "date": 1760115104999,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n-import { useEffect, useRef, useState } from \"react\";\r\n+import { useEffect, useRef, useState, useCallback } from \"react\";\r\n import { Socket } from \"socket.io-client\";\r\n \r\n interface UseWebRTCProps {\r\n   roomId: string | null;\r\n   isOfferer: boolean | null;\r\n   isStarted: boolean;\r\n-  socket: Socket | null; // Reuse the socket from useSocket\r\n+  socket: Socket | null;\r\n }\r\n \r\n export default function useWebRTC({\r\n   roomId,\r\n@@ -21,46 +21,81 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // Add TURN server for production\r\n+      // You can add a TURN server for production if needed\r\n     ],\r\n   };\r\n \r\n+  /**\r\n+   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n+   */\r\n+  const cleanup = useCallback(() => {\r\n+    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n+\r\n+    try {\r\n+      peerRef.current?.getSenders()?.forEach((sender) => {\r\n+        if (sender.track) sender.track.stop();\r\n+      });\r\n+\r\n+      peerRef.current?.close();\r\n+      peerRef.current = null;\r\n+\r\n+      if (localStream) {\r\n+        localStream.getTracks().forEach((track) => track.stop());\r\n+        setLocalStream(null);\r\n+      }\r\n+\r\n+      if (remoteStream) {\r\n+        remoteStream.getTracks().forEach((track) => track.stop());\r\n+        setRemoteStream(null);\r\n+      }\r\n+    } catch (err) {\r\n+      console.error(\"Cleanup error:\", err);\r\n+    }\r\n+  }, [localStream, remoteStream]);\r\n+\r\n+  /**\r\n+   * ðŸŽ¥ Initialize WebRTC\r\n+   */\r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n \r\n     let isMounted = true;\r\n \r\n     const init = async () => {\r\n       try {\r\n-        // âœ… Get local media\r\n-        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n+        console.log(\"ðŸŽ¬ Initializing WebRTC...\");\r\n+        const stream = await navigator.mediaDevices.getUserMedia({\r\n+          video: true,\r\n+          audio: true,\r\n+        });\r\n         if (!isMounted) return;\r\n         setLocalStream(stream);\r\n \r\n-        // âœ… Create RTCPeerConnection\r\n         const pc = new RTCPeerConnection(iceServers);\r\n         peerRef.current = pc;\r\n \r\n         // Add local tracks\r\n         stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n         // Receive remote tracks\r\n         pc.ontrack = (event) => {\r\n+          console.log(\"ðŸ“¡ Remote stream received\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // Send ICE candidates\r\n+        // Handle ICE candidates\r\n         pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n             socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // Join room and handle offer/answer\r\n+        // Join room\r\n         socket.emit(\"join-room\", roomId);\r\n \r\n+        // Handle signaling events\r\n         socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n             const offer = await pc.createOffer();\r\n             await pc.setLocalDescription(offer);\r\n@@ -68,26 +103,29 @@\n           }\r\n         });\r\n \r\n         socket.on(\"offer\", async ({ offer }) => {\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-          const answer = await pc.createAnswer();\r\n-          await pc.setLocalDescription(answer);\r\n-          socket.emit(\"answer\", { answer, roomId });\r\n+          if (!pc.currentRemoteDescription) {\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+            const answer = await pc.createAnswer();\r\n+            await pc.setLocalDescription(answer);\r\n+            socket.emit(\"answer\", { answer, roomId });\r\n+          }\r\n         });\r\n \r\n         socket.on(\"answer\", async ({ answer }) => {\r\n-          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          if (!pc.currentRemoteDescription) {\r\n+            await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n+          }\r\n         });\r\n \r\n         socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n             await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (err) {\r\n-            console.error(\"Failed to add ICE candidate:\", err);\r\n+            console.error(\"âŒ Failed to add ICE candidate:\", err);\r\n           }\r\n         });\r\n-\r\n       } catch (err) {\r\n         console.error(\"âŒ WebRTC init error:\", err);\r\n       }\r\n     };\r\n@@ -95,12 +133,10 @@\n     init();\r\n \r\n     return () => {\r\n       isMounted = false;\r\n-      peerRef.current?.close();\r\n-      localStream?.getTracks().forEach((t) => t.stop());\r\n-      peerRef.current = null;\r\n+      cleanup();\r\n     };\r\n-  }, [roomId, isOfferer, isStarted, socket]);\r\n+  }, [roomId, isOfferer, isStarted, socket, cleanup]);\r\n \r\n-  return { localStream, remoteStream };\r\n+  return { localStream, remoteStream, cleanup };\r\n }\r\n"
                },
                {
                    "date": 1760115577301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n-import { useEffect, useRef, useState, useCallback } from \"react\";\r\n+import { useEffect, useRef, useState } from \"react\";\r\n import { Socket } from \"socket.io-client\";\r\n \r\n interface UseWebRTCProps {\r\n   roomId: string | null;\r\n   isOfferer: boolean | null;\r\n   isStarted: boolean;\r\n-  socket: Socket | null;\r\n+  socket: Socket | null; // Reuse the socket from useSocket\r\n }\r\n \r\n export default function useWebRTC({\r\n   roomId,\r\n@@ -21,81 +21,46 @@\n   const iceServers = {\r\n     iceServers: [\r\n       { urls: \"stun:stun.l.google.com:19302\" },\r\n       { urls: \"stun:stun1.l.google.com:19302\" },\r\n-      // You can add a TURN server for production if needed\r\n+      // Add TURN server for production\r\n     ],\r\n   };\r\n \r\n-  /**\r\n-   * ðŸ§¹ Cleanup â€” stops all streams and closes the peer connection\r\n-   */\r\n-  const cleanup = useCallback(() => {\r\n-    console.log(\"ðŸ§¹ Cleaning up WebRTC resources...\");\r\n-\r\n-    try {\r\n-      peerRef.current?.getSenders()?.forEach((sender) => {\r\n-        if (sender.track) sender.track.stop();\r\n-      });\r\n-\r\n-      peerRef.current?.close();\r\n-      peerRef.current = null;\r\n-\r\n-      if (localStream) {\r\n-        localStream.getTracks().forEach((track) => track.stop());\r\n-        setLocalStream(null);\r\n-      }\r\n-\r\n-      if (remoteStream) {\r\n-        remoteStream.getTracks().forEach((track) => track.stop());\r\n-        setRemoteStream(null);\r\n-      }\r\n-    } catch (err) {\r\n-      console.error(\"Cleanup error:\", err);\r\n-    }\r\n-  }, [localStream, remoteStream]);\r\n-\r\n-  /**\r\n-   * ðŸŽ¥ Initialize WebRTC\r\n-   */\r\n   useEffect(() => {\r\n     if (!roomId || isOfferer === null || !isStarted || !socket) return;\r\n \r\n     let isMounted = true;\r\n \r\n     const init = async () => {\r\n       try {\r\n-        console.log(\"ðŸŽ¬ Initializing WebRTC...\");\r\n-        const stream = await navigator.mediaDevices.getUserMedia({\r\n-          video: true,\r\n-          audio: true,\r\n-        });\r\n+        // âœ… Get local media\r\n+        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n         if (!isMounted) return;\r\n         setLocalStream(stream);\r\n \r\n+        // âœ… Create RTCPeerConnection\r\n         const pc = new RTCPeerConnection(iceServers);\r\n         peerRef.current = pc;\r\n \r\n         // Add local tracks\r\n         stream.getTracks().forEach((track) => pc.addTrack(track, stream));\r\n \r\n         // Receive remote tracks\r\n         pc.ontrack = (event) => {\r\n-          console.log(\"ðŸ“¡ Remote stream received\");\r\n           setRemoteStream(event.streams[0]);\r\n         };\r\n \r\n-        // Handle ICE candidates\r\n+        // Send ICE candidates\r\n         pc.onicecandidate = (event) => {\r\n           if (event.candidate) {\r\n             socket.emit(\"ice-candidate\", { candidate: event.candidate, roomId });\r\n           }\r\n         };\r\n \r\n-        // Join room\r\n+        // Join room and handle offer/answer\r\n         socket.emit(\"join-room\", roomId);\r\n \r\n-        // Handle signaling events\r\n         socket.on(\"joined-room\", async () => {\r\n           if (isOfferer) {\r\n             const offer = await pc.createOffer();\r\n             await pc.setLocalDescription(offer);\r\n@@ -103,29 +68,26 @@\n           }\r\n         });\r\n \r\n         socket.on(\"offer\", async ({ offer }) => {\r\n-          if (!pc.currentRemoteDescription) {\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n-            const answer = await pc.createAnswer();\r\n-            await pc.setLocalDescription(answer);\r\n-            socket.emit(\"answer\", { answer, roomId });\r\n-          }\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n+          const answer = await pc.createAnswer();\r\n+          await pc.setLocalDescription(answer);\r\n+          socket.emit(\"answer\", { answer, roomId });\r\n         });\r\n \r\n         socket.on(\"answer\", async ({ answer }) => {\r\n-          if (!pc.currentRemoteDescription) {\r\n-            await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n-          }\r\n+          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n         });\r\n \r\n         socket.on(\"ice-candidate\", async ({ candidate }) => {\r\n           try {\r\n             await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n           } catch (err) {\r\n-            console.error(\"âŒ Failed to add ICE candidate:\", err);\r\n+            console.error(\"Failed to add ICE candidate:\", err);\r\n           }\r\n         });\r\n+\r\n       } catch (err) {\r\n         console.error(\"âŒ WebRTC init error:\", err);\r\n       }\r\n     };\r\n@@ -133,10 +95,12 @@\n     init();\r\n \r\n     return () => {\r\n       isMounted = false;\r\n-      cleanup();\r\n+      peerRef.current?.close();\r\n+      localStream?.getTracks().forEach((t) => t.stop());\r\n+      peerRef.current = null;\r\n     };\r\n-  }, [roomId, isOfferer, isStarted, socket, cleanup]);\r\n+  }, [roomId, isOfferer, isStarted, socket]);\r\n \r\n-  return { localStream, remoteStream, cleanup };\r\n+  return { localStream, remoteStream };\r\n }\r\n"
                }
            ],
            "date": 1752230051942,
            "name": "Commit-0",
            "content": "// features/anonymousChat/hooks/useWebRTC.ts\r\n\r\nimport { useEffect, useRef, useState } from \"react\";\r\nimport { io, Socket } from \"socket.io-client\";\r\n\r\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:3001\";\r\n\r\nexport default function useWebRTC(roomId: string) {\r\n  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\r\n  const localStreamRef = useRef<MediaStream | null>(null);\r\n  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\r\n  const socketRef = useRef<Socket | null>(null);\r\n\r\n  const iceServers = {\r\n    iceServers: [\r\n      { urls: \"stun:stun.l.google.com:19302\" },\r\n      { urls: \"stun:stun1.l.google.com:19302\" },\r\n    ],\r\n  };\r\n\r\n  useEffect(() => {\r\n    const init = async () => {\r\n      socketRef.current = io(SOCKET_URL);\r\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\r\n\r\n      socketRef.current.emit(\"join-room\", roomId);\r\n\r\n      peerConnectionRef.current = new RTCPeerConnection(iceServers);\r\n\r\n      // Add local tracks\r\n      localStreamRef.current.getTracks().forEach((track) => {\r\n        peerConnectionRef.current?.addTrack(track, localStreamRef.current as MediaStream);\r\n      });\r\n\r\n      // Handle remote stream\r\n      peerConnectionRef.current.ontrack = (event) => {\r\n        setRemoteStream(event.streams[0]);\r\n      };\r\n\r\n      // ICE candidates\r\n      peerConnectionRef.current.onicecandidate = (event) => {\r\n        if (event.candidate) {\r\n          socketRef.current?.emit(\"ice-candidate\", event.candidate, roomId);\r\n        }\r\n      };\r\n\r\n      socketRef.current.on(\"offer\", async (offer: RTCSessionDescriptionInit) => {\r\n        await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(offer));\r\n        const answer = await peerConnectionRef.current?.createAnswer();\r\n        await peerConnectionRef.current?.setLocalDescription(answer);\r\n        socketRef.current?.emit(\"answer\", answer, roomId);\r\n      });\r\n\r\n      socketRef.current.on(\"answer\", async (answer: RTCSessionDescriptionInit) => {\r\n        await peerConnectionRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\r\n      });\r\n\r\n      socketRef.current.on(\"ice-candidate\", async (candidate: RTCIceCandidateInit) => {\r\n        try {\r\n          await peerConnectionRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\r\n        } catch (error) {\r\n          console.error(\"Error adding received ice candidate\", error);\r\n        }\r\n      });\r\n\r\n      // Create offer if second user joins\r\n      socketRef.current.on(\"user-joined\", async () => {\r\n        const offer = await peerConnectionRef.current?.createOffer();\r\n        await peerConnectionRef.current?.setLocalDescription(offer);\r\n        socketRef.current?.emit(\"offer\", offer, roomId);\r\n      });\r\n    };\r\n\r\n    init();\r\n\r\n    return () => {\r\n      peerConnectionRef.current?.close();\r\n      socketRef.current?.disconnect();\r\n    };\r\n  }, [roomId]);\r\n\r\n  return { localStream: localStreamRef.current, remoteStream };\r\n}\r\n"
        }
    ]
}